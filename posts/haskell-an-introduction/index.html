<!doctype html><html><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><title>
    jsdw - Haskell, and Why It Might Just Be My New Favourite Language
</title><link href="https://fonts.googleapis.com/css?family=IBM+Plex+Serif|Open+Sans" rel=stylesheet><link href=https://jsdw.me/app.css rel=stylesheet><link href=https://jsdw.me/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><link href=https://jsdw.me/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=https://jsdw.me/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=https://jsdw.me/site.webmanifest rel=manifest><link color=#5bbad5 href=https://jsdw.me/safari-pinned-tab.svg rel=mask-icon><meta content=#f9409c name=msapplication-TileColor><meta content=#ffffff name=theme-color><body><div class="body post"><header><div class=title-inner><div class=jsdw><a href=https://jsdw.me>JSDW</a></div><nav><a href=https://jsdw.me/posts/>posts</a><a href=https://jsdw.me/projects/>projects</a></nav></div></header><section><div class=top><div class=top-scene><svg class="polygon two" viewbox="0 0 100 100" height=100% style=fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421 version=1.1 width=100% xml:space=preserve xmlns=http://www.w3.org/2000/svg xmlns:serif=http://www.serif.com/ xmlns:xlink=http://www.w3.org/1999/xlink><polygon points="0 100, 15 40, 60 0, 100 30"/></svg><svg class="polygon one" viewbox="0 0 100 100" height=100% style=fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421 version=1.1 width=100% xml:space=preserve xmlns=http://www.w3.org/2000/svg xmlns:serif=http://www.serif.com/ xmlns:xlink=http://www.w3.org/1999/xlink><polygon points="0 40, 30 0, 80 33, 100 100"/></svg></div><div class=top-inner><h1 class=title>Haskell, and Why It Might Just Be My New Favourite Language <span class=date>2014-05-25</span></h1></div></div><div class=content-inner><div class=post><p>As I am currently working mostly in front-end Web Development, Javascript is the language I have most experience in nowadays. In my spare time however, I've been doing what a lot of programmers do and searching for one language to rule all others. For me, that's a language that's concise and elegant in its construction, and one that is versatile enough that it lets the programmer create things similar to those features the language itself provides.<h1 id=golang-didn-t-quite-cut-it>Golang didn't quite cut it</h1><p>Recently, I came across <em>Go</em>, Google's programming language (version 1.2). It had some nice features, including:<ul><li>A decent package system<li>Implicit interfaces with duck typing<li>Pretty simple parallel programming (at least from the point of view of someone coming from languages like C++ and Javascript) with safe communication via channels<li>Full support for closures<li>Block scoping of variables<li>Strong typing<li>Functions can be attached to any type (you can have a number with functions attached to it!)<li>Extremely fast compile times.</ul><p>The list no doubt goes on.<p>Go certainly has a lot to offer, but there are some significant omissions that I could never quite come to terms with. For one thing, Go lacks any sort of function overloading, so you can't do things like:<pre class=language-go data-lang=go style=background:#272822;color:#f8f8f2><code class=language-go data-lang=go><span style=font-style:italic;color:#66d9ef>func </span><span style=color:#a6e22e>GetValue</span><span>() </span><span style=font-style:italic;color:#66d9ef>Value </span><span>{ </span><span style=color:#75715e>/* get default value */ </span><span>}
</span><span style=font-style:italic;color:#66d9ef>func </span><span style=color:#a6e22e>GetValue</span><span>(</span><span style=font-style:italic;color:#fd971f>idx </span><span style=font-style:italic;color:#66d9ef>int</span><span>) </span><span style=font-style:italic;color:#66d9ef>Value </span><span>{ </span><span style=color:#75715e>/* get value given an int */ </span><span>}
</span><span style=font-style:italic;color:#66d9ef>func </span><span style=color:#a6e22e>GetValue</span><span>(</span><span style=font-style:italic;color:#fd971f>idx </span><span style=font-style:italic;color:#66d9ef>string</span><span>) </span><span style=font-style:italic;color:#66d9ef>Value </span><span>{ </span><span style=color:#75715e>/* get value given a string */ </span><span>}
</span><span>
</span></code></pre><p>Instead, you have give every variation a unique name like:<pre class=language-go data-lang=go style=background:#272822;color:#f8f8f2><code class=language-go data-lang=go><span style=font-style:italic;color:#66d9ef>func </span><span style=color:#a6e22e>GetValue</span><span>() </span><span style=font-style:italic;color:#66d9ef>Value </span><span>{ </span><span style=color:#75715e>/* get default value */ </span><span>}
</span><span style=font-style:italic;color:#66d9ef>func </span><span style=color:#a6e22e>GetValueFromInt</span><span>(</span><span style=font-style:italic;color:#fd971f>idx </span><span style=font-style:italic;color:#66d9ef>int</span><span>) </span><span style=font-style:italic;color:#66d9ef>Value </span><span>{ </span><span style=color:#75715e>/* get value given an int */ </span><span>}
</span><span style=font-style:italic;color:#66d9ef>func </span><span style=color:#a6e22e>GetValueFromString</span><span>(</span><span style=font-style:italic;color:#fd971f>idx </span><span style=font-style:italic;color:#66d9ef>string</span><span>) </span><span style=font-style:italic;color:#66d9ef>Value </span><span>{ </span><span style=color:#75715e>/* get value given a string */ </span><span>}</span><span style=color:#e6db74>`
</span><span style=color:#e6db74>
</span></code></pre><p>Which I can't help but find ugly. Another thing I didn't like is that magic functions exist which you can't reproduce, for instance the <em>map</em>, of which both the type of key and stored value can be defined. This is not possible in any custom types, which sort of bugs me, as there is no form of type generics/templating in Go.<p>Some of these things can be overcome. Go has the notion of interfaces, which consist of a number of function signatures. Any type that has matching function signatures is automatically a member of that interface. Functions can then take in interfaces instead of types to be used more generically. Any type is a member of an empty interface. It also has type reflection and type based switches, which allows a function to react according to type, at a performance cost.<p>Overall though, I may well find myself using Go again, but I didn't gel with it as much as I would have liked.<h1 id=enter-haskell>Enter Haskell</h1><p><img alt="Haskell Logo: using the lambda symbol in tribute to lambda calculus" src=https://jsdw.me/posts/haskell-an-introduction/haskell.jpg><p>Haskell is a very different kettle of fish to anything I has used before. In short, it is a pure, strongly typed, lazy functional language. Some things that I have come to like about it include:<ul><li>An interpreter, so you can play with and test things without having to go through a proper compile cycle. Haskell can also be used as a scripting language using the provided <code>runhaskell</code> binary, avoiding explicit compilation altogether.<li>Laziness, which lets you keep your data and your processing separate, and pull off some rather cool feats like infinite lists.<li>Purity. You can (almost always) guarantee in Haskell that, given the same arguments, a function will always return the same results. They don't modify global state or anything like that.<li>An amazing type system. Coming from C++ templates, this is a breath of fresh air.<li>Excellent type inference, while we're on topic. You could easy forget that Haskell wasn't a dynamic language at times, as you can often omit any mention of type and let Haskell figure out what they should be given the context.<li>Functions can be glued together and reused very easily.<li>Pattern matching and guards make writing functions more elegant.<li>One can recreate imperative-like constructs in the language if they like, such is its versatility.<li>In fact, almost anything in the language core can be created by the programmer.</ul><p>Let's have a look at some of these points and see what the hell they actually mean, and why they are pretty neat. I'll start with laziness, as it's probably the most significant difference coming from an imperative world.<h2 id=laziness-can-be-an-asset>Laziness can be an Asset</h2><p>One of the most boggling concepts to get your head around when starting with Haskell, and something I am still learning, is this whole concept of laziness. One way to think about it is that in most languages, statements are evaluated inside out. That is, if you take a line like this in Javascript:<pre class=language-javascript data-lang=javascript style=background:#272822;color:#f8f8f2><code class=language-javascript data-lang=javascript><span style=font-style:italic;color:#66d9ef>function </span><span style=color:#a6e22e>doSomething</span><span>(</span><span style=font-style:italic;color:#fd971f>val</span><span>){ </span><span style=color:#f92672>return </span><span>val </span><span style=color:#f92672>+ </span><span style=color:#ae81ff>4</span><span>; }
</span><span style=font-style:italic;color:#66d9ef>function </span><span style=color:#a6e22e>anotherFunc</span><span>(</span><span style=font-style:italic;color:#fd971f>val</span><span>){ </span><span style=color:#f92672>return </span><span>val </span><span style=color:#f92672>- </span><span style=color:#ae81ff>2</span><span>; }
</span><span style=color:#a6e22e>doSomething</span><span>( </span><span style=color:#a6e22e>anotherFunc</span><span>(</span><span style=color:#ae81ff>3</span><span>)</span><span style=color:#f92672>+</span><span style=color:#ae81ff>12 </span><span>);
</span></code></pre><p>before <code>doSomething</code> is called on line 3, first <code>anotherFunc(3)</code> is evaluated (which returns 1), and then <code>1+12</code> is evaluated, giving us 13. Finally, <code>doSomething(13)</code> can be evaluated, returning 17. We work from the inside out until everything is evaluated.<p>Haskell on the other hand is lazy, and only bothers to actually evaluate a statement when it needs the answer. You can think of it as working from the outside in when given an expression, but going only as far in as it needs to to get back what it needs.<p>The above would be something like this in Haskell:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>doSomething val </span><span style=color:#f92672>=</span><span> val </span><span style=color:#f92672>+ </span><span style=color:#ae81ff>4
</span><span>anotherFunc val </span><span style=color:#f92672>=</span><span> val </span><span style=color:#f92672>- </span><span style=color:#ae81ff>2
</span><span style=color:#75715e>-- don't worry about the $. it just means, do everything to
</span><span style=color:#75715e>-- the right of me before giving the result to what's on the left.
</span><span style=color:#75715e>-- essentially, it saves needing extra brackets:
</span><span>output </span><span style=color:#f92672>=</span><span> (doSomething </span><span style=color:#f92672>$</span><span> anotherFunc </span><span style=color:#ae81ff>3</span><span>)</span><span style=color:#f92672>+</span><span style=color:#ae81ff>12
</span></code></pre><p>where we have assigned a value to the final result. If <code>output</code> is not later used (for example, printed out to the console), the result of <code>(doSomething (anotherFunc 3))+12</code> is never computed. Laziness allows us to do things like:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- create an infinite list where every value is twice the previous one.
</span><span style=color:#75715e>-- this just constructs a list where the first part is 1, and the next part
</span><span style=color:#75715e>-- is the same list with values doubled in size:
</span><span>myDoubles </span><span style=color:#f92672>= </span><span style=color:#ae81ff>1 </span><span style=color:#f92672>:</span><span> map (*</span><span style=color:#ae81ff>2</span><span>) myDoubles
</span><span style=color:#75715e>-- take the first 10 elements from this infinite list to use somewhere:
</span><span>firstBatch </span><span style=color:#f92672>=</span><span> take </span><span style=color:#ae81ff>10</span><span> myDoubles
</span><span>
</span><span style=color:#75715e>-- create a list of all fibonacci numbers:
</span><span>fibs </span><span style=color:#f92672>= </span><span style=color:#ae81ff>0 </span><span style=color:#f92672>: </span><span style=color:#ae81ff>1 </span><span style=color:#f92672>:</span><span> zipWith </span><span style=color:#a6e22e>(+)</span><span> fibs (tail fibs)
</span><span style=color:#75715e>-- ignoring the first 50 values, take 100 Fibonacci numbers:
</span><span>someFibs </span><span style=color:#f92672>=</span><span> take </span><span style=color:#ae81ff>100 </span><span style=color:#f92672>$</span><span> drop </span><span style=color:#ae81ff>50 </span><span style=color:#f92672>$</span><span> fibs
</span><span>
</span><span style=color:#75715e>-- create a list of all primes:
</span><span>primes </span><span style=color:#f92672>= </span><span style=color:#ae81ff>2</span><span style=color:#f92672>: </span><span style=color:#ae81ff>3</span><span style=color:#f92672>:</span><span> sieve (tail primes) [</span><span style=color:#ae81ff>5</span><span>,</span><span style=color:#ae81ff>7</span><span style=color:#f92672>..</span><span>]
</span><span>   </span><span style=color:#f92672>where</span><span> sieve (p</span><span style=color:#f92672>:</span><span>ps) xs </span><span style=color:#f92672>=</span><span> h </span><span style=color:#f92672>++</span><span> sieve ps [x </span><span style=color:#f92672>|</span><span> x </span><span style=color:#f92672>&LT-</span><span> t, rem x p </span><span style=color:#f92672>/=</span><span style=color:#ae81ff>0</span><span>]
</span><span>               </span><span style=color:#f92672>where</span><span> (h,</span><span style=color:#f92672>~</span><span>(_</span><span style=color:#f92672>:</span><span>t)) </span><span style=color:#f92672>=</span><span> span(</span><span style=color:#f92672><</span><span> p*p) xs
</span><span>
</span></code></pre><p>Which I think you'll agree is pretty cool. There will be more efficient ways to get Fibonacci and prime numbers, but the end result is the same. These examples are helped by the fact that Haskell has an Integer number type that can be arbitrarily large.<p>Laziness can also be a stumbling block however, because if you don't understand how it works, seemingly simple programs can run into problems:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- countValue is given two numbers, val and count
</span><span style=color:#75715e>-- if val > 0, it runs itself again, adding 1 to count and removing 1 from val
</span><span style=color:#75715e>-- when val hits 0, count is returned.
</span><span>countValue val count
</span><span>	</span><span style=color:#f92672>|</span><span> val </span><span style=color:#f92672>> </span><span style=color:#ae81ff>0 </span><span style=color:#f92672>=</span><span> countValue (val</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span>) (count</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span><span>)
</span><span>	</span><span style=color:#f92672>|</span><span> otherwise </span><span style=color:#f92672>=</span><span> count
</span><span>
</span><span style=color:#75715e>-- if I print output to my console, memory usage goes bonkers:
</span><span>main </span><span style=color:#f92672>=</span><span> print </span><span style=color:#f92672>$</span><span> countValue </span><span style=color:#ae81ff>1000000000 0
</span><span>
</span></code></pre><p>Why does the above program, which appears to be very simple, use up all of my RAM? Well, because <code>count</code> is not evaluated until it is necessary to print it to screen, a record showing what needs to be evaluated is instead built up every time we pass <code>count+1</code> to the next iteration of the function. Thus, instead of just incrementing the value of count each loop, Haskell stores something like:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>count </span><span style=color:#f92672>=</span><span> (((((</span><span style=color:#ae81ff>0</span><span>)</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span><span>)</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span><span>)</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span><span>)</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span><span>)</span><span style=color:#f92672>...
</span></code></pre><p>It avoids actually performing the actual computation (adding 1) each step because its lazy and doesn't need it for anything yet, but it still has to remember what computation it'll eventually need to do! By the way, this record of what to compute is known as a <em>thunk</em> in Haskell terminology.<p>Fortunately, when you understand the concept of laziness you can find ways to work around it if necessary. In this case, we can just tell Haskell that we want <code>count</code> to be evaluated when passed in to <code>countValue</code> by enabling a language extension called <em>BangPatterns</em> and adding a <code>!</code> in front of count in the function declaration as so:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>{-# </span><span style=color:#f92672>LANGUAGE</span><span> BangPatterns #-}
</span><span>
</span><span>countValue val </span><span style=color:#f92672>!</span><span>count
</span><span>	</span><span style=color:#f92672>|</span><span> val </span><span style=color:#f92672>> </span><span style=color:#ae81ff>0 </span><span style=color:#f92672>=</span><span> countValue (val</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span>) (count</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span><span>)
</span><span>	</span><span style=color:#f92672>|</span><span> otherwise </span><span style=color:#f92672>=</span><span> count
</span></code></pre><p>All in all, laziness is one of the core fundamental differences between Haskell and any other language I've known. It makes it possible to do some pretty amazing things, like creating infinite lists representing things we might want to work with, like prime numbers or Fibonacci numbers. On the other hand, it can make it harder to reason about when your program will be using memory and CPU, especially if you are not used to the concept of laziness, which most of us won't be to begin with.<h2 id=pure-functions>Pure Functions</h2><p>In Haskell, functions can't modify global state or anything like that. If you have a function that takes in some variables, then you can guarantee that it will return the same result whenever those variables are the same. This makes it very easy to test functions in isolation. Consider in Javascript I could do something like:<pre style=background:#272822;color:#f8f8f2><code><span>var a = 12
</span><span>function doSomething(){
</span><span>	return a++;
</span><span>}
</span></code></pre><p>Every time <code>doSomething</code> is called, we get something different back. The language provides no guarantees about what will be returned. In Haskell, this sort of thing simply won't work:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>a </span><span style=color:#f92672>= </span><span style=color:#ae81ff>12
</span><span>
</span><span>main </span><span style=color:#f92672>= do
</span><span>	a </span><span style=color:#f92672>= </span><span style=color:#ae81ff>13 </span><span style=color:#75715e>--this line is not valid Haskell
</span><span>	return </span><span style=color:#ae81ff>()
</span><span>
</span><span>a </span><span style=color:#f92672>= </span><span style=color:#ae81ff>13 </span><span style=color:#75715e>--this line causes a compilation error, as "a" is defined already.
</span></code></pre><p>There is really no such thing as a variable at all. Everything is effectively a <code>const</code>, and once declared cannot be altered. As a result, there aren't really any loops either, because iterating over a loop requires a variable that can be updated. Instead, Haskell relies on recursion and list manipulation to take the place of loops.<p>Take the problem of printing out all numbers below 1000 that are multiples of 3 or 5 (problem 1 in <a href=https://projecteuler.net>Project Euler</a>). In Javascript one might do the following:<pre style=background:#272822;color:#f8f8f2><code><span>function getMultiples(){
</span><span>	var out = [];
</span><span>	for(var i = 0; i < 1000; i++){
</span><span>		if(i % 3 == 0 || i % 5 == 0) out.push(i);
</span><span>	}
</span><span>	return out;
</span><span>}
</span><span>
</span><span>console.log( getMultiples() );
</span></code></pre><p>The equivalent in Haskell substitutes a traditional loop for a list which we filter to return the desired values:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- take a list from 0-999, and filter out all numbers not multiples of 3 or 5:
</span><span>getMultiples </span><span style=color:#f92672>=</span><span> filter fn [</span><span style=color:#ae81ff>1</span><span style=color:#f92672>..</span><span style=color:#ae81ff>999</span><span>]
</span><span>	</span><span style=color:#f92672>where
</span><span>		fn n </span><span style=color:#f92672>=</span><span> n </span><span style=color:#f92672>`rem` </span><span style=color:#ae81ff>3 </span><span style=color:#f92672>== </span><span style=color:#ae81ff>0 </span><span style=color:#f92672>||</span><span> n </span><span style=color:#f92672>`rem` </span><span style=color:#ae81ff>5 </span><span style=color:#f92672>== </span><span style=color:#ae81ff>0
</span><span>
</span><span style=color:#75715e>-- print the sum of the above:
</span><span>main </span><span style=color:#f92672>=</span><span> print </span><span style=color:#f92672>$</span><span> sum getMultiples
</span></code></pre><p>Of course, sometimes you need to take in user input, print things out to the screen, etcetera. That's ok though, because you can write functions that take in a special object of type <em>IO</em>. <code>main</code>, the entry point in Haskell programs, has this type.<p>This semi-magical type <em>IO</em> can be seen as a little box, which when asked for something from the real world, say a line of user input from the console, pops off and fetches it for you. Needless to say, it allows for the purity to hold in the sense that this box, like the real world, is always a little different, so if a function takes in this IO box, it is perfectly able to return a different value each time it does so.<h3 id=pattern-matching>Pattern Matching</h3><p>In Haskell and a bunch of other functional-esque languages, pattern matching is available to us. Pattern matching allows us to essentially overload functions based on the constructors used in arguments. The most common pattern match perhaps is matching a list by breaking it into its first and other elements:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>
</span><span style=color:#75715e>-- a list is really a recursive application of the list constructor,
</span><span style=color:#75715e>-- where the thing to the left of (:) is a list item, and to the right
</span><span style=color:#75715e>-- a list to append it to. [] is an empty list:
</span><span>myList </span><span style=color:#f92672>= </span><span style=color:#ae81ff>1 </span><span style=color:#f92672>: </span><span style=color:#ae81ff>2 </span><span style=color:#f92672>: </span><span style=color:#ae81ff>3 </span><span style=color:#f92672>: </span><span style=color:#ae81ff>[]
</span><span>
</span><span style=color:#75715e>-- this can also be written as:
</span><span>myList </span><span style=color:#f92672>=</span><span> [</span><span style=color:#ae81ff>1</span><span>,</span><span style=color:#ae81ff>2</span><span>,</span><span style=color:#ae81ff>3</span><span>]
</span></code></pre><p>Knowing how lists are constructed, we can pattern match against values in the constructor (seen either side of the constructor, <code>:</code>).<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- lets redefine the map function, which applies some function to
</span><span style=color:#75715e>-- every element of a list, returning the new list as a result.
</span><span style=color:#75715e>-- we match using the list constructor (:) and the empty list []:
</span><span>map' fn (a</span><span style=color:#f92672>:</span><span>rest) </span><span style=color:#f92672>=</span><span> (fn a)</span><span style=color:#f92672>:</span><span>(map2 fn rest)
</span><span>map' fn </span><span style=color:#ae81ff>[] </span><span style=color:#f92672>= </span><span style=color:#ae81ff>[]
</span><span>
</span><span style=color:#75715e>-- usage same as map:
</span><span>
</span><span style=color:#75715e>-- doubled = [2,4,6]:
</span><span>doubled </span><span style=color:#f92672>=</span><span> map' (*</span><span style=color:#ae81ff>2</span><span>) [</span><span style=color:#ae81ff>1</span><span>,</span><span style=color:#ae81ff>2</span><span>,</span><span style=color:#ae81ff>3</span><span>]
</span><span>
</span><span style=color:#75715e>-- added = [5,6,7]:
</span><span>added </span><span style=color:#f92672>=</span><span> map' (</span><span style=color:#f92672>+</span><span style=color:#ae81ff>4</span><span>) [</span><span style=color:#ae81ff>1</span><span>,</span><span style=color:#ae81ff>2</span><span>,</span><span style=color:#ae81ff>3</span><span>]
</span></code></pre><p>Pattern matching also extends to custom type constructors. Above, (:) is the list constructor. Here's how we declare a simple type:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- declare a 'Colour' type:
</span><span style=color:#f92672>data </span><span style=color:#ae81ff>Colour </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Red </span><span style=color:#f92672>| </span><span style=color:#ae81ff>Orange </span><span style=color:#f92672>| </span><span style=color:#ae81ff>Yellow </span><span style=color:#f92672>| </span><span style=color:#ae81ff>Value Int
</span><span>
</span><span style=color:#75715e>-- Colour constructors are on the right, and can be used to construct
</span><span style=color:#75715e>-- Colour types as follows, noting that one of our constructors can take
</span><span style=color:#75715e>-- an Int as an argument in this example:
</span><span>iAmRed </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Red
</span><span>iAmValued </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Value 100
</span></code></pre><p>Given this Colour type, we can write functions that pattern match according to constructor used:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- returns True if the Colour passed in is Red, False in every other case:
</span><span>isRed </span><span style=color:#ae81ff>Red </span><span style=color:#f92672>= </span><span style=color:#ae81ff>True
</span><span>isRed _ </span><span style=color:#f92672>= </span><span style=color:#ae81ff>False
</span><span>
</span><span style=color:#75715e>-- returns True if the Colour passed in is a Value over 100, False otherwise:
</span><span>isOver100 (</span><span style=color:#ae81ff>Value</span><span> n) </span><span style=color:#f92672>=</span><span> n </span><span style=color:#f92672>> </span><span style=color:#ae81ff>100
</span><span>isOver100 _ </span><span style=color:#f92672>= </span><span style=color:#ae81ff>False
</span><span>
</span><span style=color:#75715e>-- returns True if the Colour passed in is a Value of exactly 100, false otherwise:
</span><span>isExactly100 (</span><span style=color:#ae81ff>Value 100</span><span>) </span><span style=color:#f92672>= </span><span style=color:#ae81ff>True
</span><span>isExactly100 _ </span><span style=color:#f92672>= </span><span style=color:#ae81ff>False
</span><span>
</span><span style=color:#75715e>-- thus, these statements are all true:
</span><span>isOver100 (</span><span style=color:#ae81ff>Value 101</span><span>) </span><span style=color:#f92672>== </span><span style=color:#ae81ff>True
</span><span>isOver100 </span><span style=color:#ae81ff>Orange </span><span style=color:#f92672>== </span><span style=color:#ae81ff>False
</span><span>isRed </span><span style=color:#ae81ff>Red </span><span style=color:#f92672>== </span><span style=color:#ae81ff>True
</span><span>isRed </span><span style=color:#ae81ff>Yellow </span><span style=color:#f92672>==</span><span> false
</span></code></pre><p>As we can see, pattern matching helps ensure that by the time the body of the function even runs, we've already successfully matched against a constructor. Guards extend this idea to run code depending on conditional checks:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>numberToString n
</span><span>	</span><span style=color:#f92672>|</span><span> n </span><span style=color:#f92672>< </span><span style=color:#ae81ff>100 </span><span style=color:#f92672>= </span><span style=color:#e6db74>"quite small"
</span><span>	</span><span style=color:#f92672>|</span><span> n </span><span style=color:#f92672>== </span><span style=color:#ae81ff>100 </span><span style=color:#f92672>= </span><span style=color:#e6db74>"exactly 100"
</span><span>	</span><span style=color:#f92672>|</span><span> n </span><span style=color:#f92672>> </span><span style=color:#ae81ff>100 </span><span style=color:#f92672>= </span><span style=color:#e6db74>"pretty big!"
</span><span>
</span><span style=color:#75715e>-- given the above, these hold true:
</span><span>numberToString </span><span style=color:#ae81ff>50 </span><span style=color:#f92672>== </span><span style=color:#e6db74>"quite small"
</span><span>numberToString </span><span style=color:#ae81ff>100 </span><span style=color:#f92672>== </span><span style=color:#e6db74>"exactly 100"
</span><span>
</span></code></pre><p>Both guards and pattern matches are syntactic sugar for if/elseif and case expressions respectively, which are also available in Haskell. <code>if</code>, being an expression which always evaluates to a result, can be used inline in place of the ternary operator available in many other languages. This, for instance, is perfectly valid:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- return 1+2 if n < 100, or 100+2 otherwise:
</span><span>getValue n </span><span style=color:#f92672>=</span><span> (</span><span style=color:#f92672>if</span><span> n </span><span style=color:#f92672>< </span><span style=color:#ae81ff>100 </span><span style=color:#f92672>then </span><span style=color:#ae81ff>1 </span><span style=color:#f92672>else </span><span style=color:#ae81ff>100</span><span>) </span><span style=color:#f92672>+ </span><span style=color:#ae81ff>2
</span><span>
</span><span style=color:#75715e>-- also could be written as:
</span><span>getValue n
</span><span>	</span><span style=color:#f92672>|</span><span> n </span><span style=color:#f92672>< </span><span style=color:#ae81ff>100 </span><span style=color:#f92672>= </span><span style=color:#ae81ff>1 </span><span style=color:#f92672>+ </span><span style=color:#ae81ff>2
</span><span>	</span><span style=color:#f92672>|</span><span> otherwise </span><span style=color:#f92672>= </span><span style=color:#ae81ff>100 </span><span style=color:#f92672>+ </span><span style=color:#ae81ff>2
</span></code></pre><h2 id=an-amazing-type-system>An Amazing Type System</h2><p>Haskell has the best type system I have used in a language, hands down. Basic types in Haskell can be defined and used really easily as we've done so above. Let's work from a similar example:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- define a type Colour, of which instances can be made by calling Red, Orange or Yellow,
</span><span style=color:#75715e>-- which are the types constructor functions:
</span><span style=color:#f92672>data </span><span style=color:#ae81ff>Colour </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Red </span><span style=color:#f92672>| </span><span style=color:#ae81ff>Orange </span><span style=color:#f92672>| </span><span style=color:#ae81ff>Yellow
</span></code></pre><p>Haskell has the notion of type classes, which are much like interfaces in other languages. A type class defines a set of functions that a type can then implement in order to be an instance of that class. Several built in type classes exist, for example <code>Eq</code>, which simply states that one can compare instances of the type against eachother to compare for equality (or non equality). To be a member, we need to define what either the <code>==</code> or <code>/=</code> operator does for our new type:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>--let's add colour to the Eq class:
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>Eq Colour </span><span style=color:#f92672>where
</span><span>	</span><span style=color:#a6e22e>(==) </span><span style=color:#ae81ff>Red Red </span><span style=color:#f92672>= </span><span style=color:#ae81ff>True
</span><span>	</span><span style=color:#a6e22e>(==) </span><span style=color:#ae81ff>Orange Orange </span><span style=color:#f92672>= </span><span style=color:#ae81ff>True
</span><span>	</span><span style=color:#a6e22e>(==) </span><span style=color:#ae81ff>Yellow Yellow </span><span style=color:#f92672>= </span><span style=color:#ae81ff>True
</span><span>	</span><span style=color:#a6e22e>(==)</span><span> _ _ </span><span style=color:#f92672>= </span><span style=color:#ae81ff>False
</span><span>
</span><span style=color:#75715e>--now, these hold true:
</span><span>(</span><span style=color:#ae81ff>Red </span><span style=color:#f92672>== </span><span style=color:#ae81ff>Red</span><span>) </span><span style=color:#f92672>== </span><span style=color:#ae81ff>True
</span><span>(</span><span style=color:#ae81ff>Red </span><span style=color:#f92672>== </span><span style=color:#ae81ff>Green</span><span>) </span><span style=color:#f92672>== </span><span style=color:#ae81ff>False
</span></code></pre><p>Haskell streamlines this by allowing the compiler to automatically figure out this instance code for some built in type classes like Eq, Read, Show, Ord, and Enum, for our custom type:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>data </span><span style=color:#ae81ff>Colour </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Red </span><span style=color:#f92672>| </span><span style=color:#ae81ff>Orange </span><span style=color:#f92672>| </span><span style=color:#ae81ff>Yellow </span><span style=color:#f92672>deriving</span><span> (</span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>Eq</span><span>, </span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>Ord</span><span>, </span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>Enum</span><span>, </span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>Show</span><span>, </span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>Read</span><span>)
</span><span>
</span><span style=color:#75715e>-- now, our Colour type is a member of these classes, so these hold True:
</span><span>
</span><span style=color:#75715e>-- Eq, allows testing for equality or not:
</span><span>(</span><span style=color:#ae81ff>Red </span><span style=color:#f92672>== </span><span style=color:#ae81ff>Red</span><span>) </span><span style=color:#f92672>== </span><span style=color:#ae81ff>True
</span><span>(</span><span style=color:#ae81ff>Red </span><span style=color:#f92672>/= </span><span style=color:#ae81ff>Orange</span><span>) </span><span style=color:#f92672>==</span><span> true
</span><span>
</span><span style=color:#75715e>-- Ord, allows for greater than/less than comparisons:
</span><span style=color:#ae81ff>Red </span><span style=color:#f92672>< </span><span style=color:#ae81ff>Orange </span><span style=color:#f92672>== </span><span style=color:#ae81ff>True
</span><span style=color:#ae81ff>Yellow </span><span style=color:#f92672>> </span><span style=color:#ae81ff>Orange </span><span style=color:#f92672>== </span><span style=color:#ae81ff>True
</span><span>
</span><span style=color:#75715e>-- Enum, allows for ranges to be constructed:
</span><span>[</span><span style=color:#ae81ff>Red </span><span style=color:#f92672>..</span><span>] </span><span style=color:#f92672>==</span><span> [</span><span style=color:#ae81ff>Red</span><span>,</span><span style=color:#ae81ff>Orange</span><span>,</span><span style=color:#ae81ff>Yellow</span><span>]
</span><span>
</span><span style=color:#75715e>-- Show (allows output to console for this type):
</span><span>show </span><span style=color:#ae81ff>Red </span><span style=color:#f92672>== </span><span style=color:#e6db74>"Red"
</span><span>show </span><span style=color:#ae81ff>Orange </span><span style=color:#f92672>== </span><span style=color:#e6db74>"Orange"
</span><span>
</span><span style=color:#75715e>-- Read (opposite of show; input from string to type). We need to tell
</span><span style=color:#75715e>-- Haskell what type we're dealing with here with a ':: typename':
</span><span>read </span><span style=color:#e6db74>"Red" </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>Colour </span><span style=color:#f92672>== </span><span style=color:#ae81ff>Red
</span><span>
</span></code></pre><p>You may notice that things like Enum and Ord are based on the order in which the constructors were defined in the first place. As well as using built in type classes, we can define our own. This effectively lets us define custom interfaces for our types:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- define a silly class (think of it as an interface):
</span><span style=color:#f92672>class </span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>Syllable </span><span>a </span><span style=color:#f92672>where
</span><span>	</span><span style=color:#a6e22e>syllables </span><span style=color:#f92672>:: </span><span>a </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>Integer
</span><span>
</span><span style=color:#75715e>-- make Colour a member of it:
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>Syllable Colour </span><span style=color:#f92672>where
</span><span>	syllables </span><span style=color:#ae81ff>Red </span><span style=color:#f92672>= </span><span style=color:#ae81ff>1
</span><span>	syllables </span><span style=color:#ae81ff>Orange </span><span style=color:#f92672>= </span><span style=color:#ae81ff>2
</span><span>	syllables </span><span style=color:#ae81ff>Yellow </span><span style=color:#f92672>= </span><span style=color:#ae81ff>2
</span><span>
</span></code></pre><p>As in other languages that have interfaces, functions in Haskell can be crafted that will only take in arguments that satisfy some type class or collection of type classes, for example:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- we give this function a type signture to make clear
</span><span style=color:#75715e>-- what types it supports rather than let Haskell guess.
</span><span style=color:#a6e22e>countSyllables </span><span style=color:#f92672>::</span><span> (</span><span style=font-style:italic;color:#66d9ef>Syllable </span><span>a) </span><span style=color:#f92672>=></span><span> [a] </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>Integer
</span><span style=color:#75715e>-- this function counts up all the syllables in whatever
</span><span style=color:#75715e>-- we give it:
</span><span>countSyllables list </span><span style=color:#f92672>=</span><span> foldl </span><span style=color:#a6e22e>(+) </span><span style=color:#ae81ff>0 </span><span style=color:#f92672>$</span><span> map syllables list
</span></code></pre><p>This only scratches the surface of types in Haskell, but needless to say they are very powerful and versatile yet remain simple to use. Up until this last example, I have not even added type signatures to anything; Haskell is perfectly happy to figure it out for itself on the whole, though occasionally you will want to be explicit to remove any ambiguity.<h2 id=function-composition>Function Composition</h2><p>The way in which functions work in Haskell makes them very flexible with regard to composing them together into larger functions. Let's look at some type signatures to get an idea for how they work:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- the type signature for a number could be:
</span><span style=color:#a6e22e>simpleType </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Integer
</span><span style=color:#75715e>-- which is followed by the actual declaration:
</span><span>simpleType </span><span style=color:#f92672>= </span><span style=color:#ae81ff>12
</span><span>
</span><span style=color:#75715e>-- the type signature for a function could be more involved:
</span><span style=color:#a6e22e>greaterThan </span><span style=color:#f92672>::</span><span> (</span><span style=font-style:italic;color:#66d9ef>Ord </span><span>a) </span><span style=color:#f92672>=> </span><span>a </span><span style=color:#f92672>-> </span><span>a </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>Bool
</span><span>greaterThan a b </span><span style=color:#f92672>=</span><span> a </span><span style=color:#f92672><</span><span> b
</span><span>
</span></code></pre><p>In the first case, we say that simplyType has a type of Integer. We then go on to define it as being 12. In the second case, we say that greaterThan is a function that takes in some type which must be a member of the Ord typeclass. This returns a function which takes in another thing of the same type, which returns a Bool. So, functions sort of take in one argument at a time. Using <em>ghci</em>, the Haskell interpreter, you can create functions on the fly (using notation akin to being inside a <em>do</em> block, so adding let before definitions) and inspect their type:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>> let</span><span> greaterThan a b </span><span style=color:#f92672>=</span><span> a </span><span style=color:#f92672><</span><span> b
</span><span style=color:#f92672>> :type</span><span> greaterThan
</span><span style=color:#a6e22e>greaterThan </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Ord </span><span>a </span><span style=color:#f92672>=> </span><span>a </span><span style=color:#f92672>-> </span><span>a </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>Bool
</span><span>
</span><span style=color:#f92672>> :type</span><span> greaterThan </span><span style=color:#ae81ff>9
</span><span>greaterThan </span><span style=color:#ae81ff>9 </span><span style=color:#f92672>::</span><span> (</span><span style=color:#ae81ff>Num</span><span> a, </span><span style=color:#ae81ff>Ord</span><span> a) </span><span style=color:#f92672>=></span><span> a </span><span style=color:#f92672>-> </span><span style=color:#ae81ff>Bool
</span><span>
</span><span style=color:#f92672>> :type</span><span> greaterThan </span><span style=color:#ae81ff>9 12
</span><span>greaterThan </span><span style=color:#ae81ff>9 12 </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>Bool
</span><span>
</span></code></pre><p>Here, we see that to begin with, greaterThan is automatically assigned the type I explicitly gave it above. The type of <code>greaterThan 9</code> is more restricted, as we have provided an instance of <code>a</code>, and know now that it is a number of some sort. It has also lost an <code>a -></code> from its type signature, as that argument has now been provided, so it can only take in one more <code>a</code>. Finally, <code>greaterThan 9 12</code> is fully applied, so the other <code>a -></code> is gone, leaving something of the final type, Bool.<p>Given the nature of functions, we can do things like:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- this defines a new function by partially applying
</span><span style=color:#75715e>-- greaterThan, which can take in one argument:
</span><span>greaterThanNine </span><span style=color:#f92672>=</span><span> greaterThan </span><span style=color:#ae81ff>9
</span><span>
</span><span style=color:#75715e>-- we provide the final argument to get the final
</span><span style=color:#75715e>-- result back:
</span><span>greaterThanNine </span><span style=color:#ae81ff>6 </span><span style=color:#f92672>== </span><span style=color:#ae81ff>False
</span><span>greaterThanNine </span><span style=color:#ae81ff>12 </span><span style=color:#f92672>== </span><span style=color:#ae81ff>True
</span></code></pre><p>Haskell also has composition operators (which, by the way, you could define yourself). For instance:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>times2 a </span><span style=color:#f92672>=</span><span> a * </span><span style=color:#ae81ff>2
</span><span style=color:#75715e>-- could also be written as: times2 = (*2)
</span><span>
</span><span>minus4 a </span><span style=color:#f92672>=</span><span> a </span><span style=color:#f92672>- </span><span style=color:#ae81ff>4
</span><span>plus10 a </span><span style=color:#f92672>=</span><span> a </span><span style=color:#f92672>+ </span><span style=color:#ae81ff>10
</span><span>
</span><span style=color:#75715e>-- this function multiples a value by 2, then minuses 4,
</span><span style=color:#75715e>-- then adds 10, returning the result:
</span><span>doTheAbove </span><span style=color:#f92672>=</span><span> plus10 </span><span style=color:#f92672>.</span><span> minus4 </span><span style=color:#f92672>.</span><span> times2
</span></code></pre><p>To do the same in Javascript would be rather more verbose:<pre class=language-javascript data-lang=javascript style=background:#272822;color:#f8f8f2><code class=language-javascript data-lang=javascript><span style=font-style:italic;color:#66d9ef>function </span><span style=color:#a6e22e>times2</span><span>(</span><span style=font-style:italic;color:#fd971f>a</span><span>){ </span><span style=color:#f92672>return </span><span>a</span><span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span>; }
</span><span style=font-style:italic;color:#66d9ef>function </span><span style=color:#a6e22e>minus4</span><span>(</span><span style=font-style:italic;color:#fd971f>a</span><span>){ </span><span style=color:#f92672>return </span><span>a</span><span style=color:#f92672>-</span><span style=color:#ae81ff>4</span><span>; }
</span><span style=font-style:italic;color:#66d9ef>function </span><span style=color:#a6e22e>plus10</span><span>(</span><span style=font-style:italic;color:#fd971f>a</span><span>){ </span><span style=color:#f92672>return </span><span>a</span><span style=color:#f92672>+</span><span style=color:#ae81ff>10</span><span>; }
</span><span>
</span><span style=color:#75715e>// this is not only more verbose but not type checked at compile time,
</span><span style=color:#75715e>// so doTheAbove([1,2,3]) would only throw an error at runtime, whereas
</span><span style=color:#75715e>// haskell would catch the issue at compile time..
</span><span style=font-style:italic;color:#66d9ef>function </span><span style=color:#a6e22e>doTheAbove</span><span>(</span><span style=font-style:italic;color:#fd971f>a</span><span>){
</span><span>	</span><span style=color:#f92672>return </span><span style=color:#a6e22e>plus10</span><span>( </span><span style=color:#a6e22e>minus4</span><span>( </span><span style=color:#a6e22e>times2</span><span>(a) ) );
</span><span>}
</span></code></pre><p>Functions can also take in other functions:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- this (silly) function takes in a thing, and a function which takes in
</span><span style=color:#75715e>-- a thing of the same type and returns a Bool, and then returns a string:
</span><span style=color:#a6e22e>isValid </span><span style=color:#f92672>::</span><span> (a </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>Bool</span><span>) </span><span style=color:#f92672>-> </span><span>a </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>String
</span><span>isValid fn val
</span><span>	</span><span style=color:#f92672>|</span><span> (fn val) </span><span style=color:#f92672>== </span><span style=color:#ae81ff>True </span><span style=color:#f92672>= </span><span style=color:#e6db74>"Yup"
</span><span>	</span><span style=color:#f92672>|</span><span> otherwise </span><span style=color:#f92672>= </span><span style=color:#e6db74>"Nope"
</span><span>
</span><span style=color:#75715e>-- we can partially apply this by giving it a function:
</span><span>lessThan10 </span><span style=color:#f92672>=</span><span> isValid (</span><span style=color:#f92672>\</span><span>n </span><span style=color:#f92672>-> if</span><span> n </span><span style=color:#f92672>< </span><span style=color:#ae81ff>10 </span><span style=color:#f92672>then </span><span style=color:#ae81ff>True </span><span style=color:#f92672>else </span><span style=color:#ae81ff>False</span><span>)
</span><span>
</span><span style=color:#75715e>-- then, these hold true:
</span><span>lessThan10 </span><span style=color:#ae81ff>13 </span><span style=color:#f92672>== </span><span style=color:#e6db74>"Nope"
</span><span>lessThan10 </span><span style=color:#ae81ff>5 </span><span style=color:#f92672>== </span><span style=color:#e6db74>"Yup"
</span><span>
</span></code></pre><p>The same (but not type checked) in Javascript would look something like:<pre class=language-javascript data-lang=javascript style=background:#272822;color:#f8f8f2><code class=language-javascript data-lang=javascript><span style=font-style:italic;color:#66d9ef>function </span><span style=color:#a6e22e>isValid</span><span>(</span><span style=font-style:italic;color:#fd971f>fn</span><span>, </span><span style=font-style:italic;color:#fd971f>a</span><span>){
</span><span>	</span><span style=color:#f92672>if</span><span>( </span><span style=color:#a6e22e>fn</span><span>(a) ) </span><span style=color:#f92672>return </span><span style=color:#e6db74>"Yup"</span><span>;
</span><span>	</span><span style=color:#f92672>return </span><span style=color:#e6db74>"Nope"</span><span>;
</span><span>}
</span><span>
</span><span style=color:#75715e>// bind the first arg of isValid to a function:
</span><span style=font-style:italic;color:#66d9ef>var </span><span>lessThan10 </span><span style=color:#f92672>= </span><span>isValid.</span><span style=color:#a6e22e>bind</span><span>(</span><span style=color:#ae81ff>null</span><span>, </span><span style=font-style:italic;color:#66d9ef>function</span><span>(</span><span style=font-style:italic;color:#fd971f>a</span><span>){
</span><span>	</span><span style=color:#f92672>if</span><span>(a </span><span style=color:#f92672>< </span><span style=color:#ae81ff>10</span><span>) </span><span style=color:#f92672>return </span><span style=color:#ae81ff>true</span><span>;
</span><span>	</span><span style=color:#f92672>return </span><span style=color:#ae81ff>false</span><span>;
</span><span>});
</span><span>
</span><span style=color:#75715e>// these hold true:
</span><span style=color:#a6e22e>lessThan10</span><span>(</span><span style=color:#ae81ff>13</span><span>) </span><span style=color:#f92672>== </span><span style=color:#e6db74>"Nope"
</span><span style=color:#a6e22e>lessThan10</span><span>(</span><span style=color:#ae81ff>5</span><span>) </span><span style=color:#f92672>== </span><span style=color:#e6db74>"Yup"
</span></code></pre><p>We can see that the bracketless syntax of Haskell just makes sense when things like composing and partially applying functions are so common in it.<h1 id=wrapping-things-up>Wrapping Things Up</h1><p>Well, if you made it this far, well done! I hope that I have helped to demonstrate some of the things that make Haskell a language worthy of your attention. I have found it to be a rather steep learning curve to date, but only really because of how different it is from the languages I have learned to date, rather than because the language itself is overly complex. Things like Monads are still slightly scary territory, though I understand the principles behind them now (they just represent a more advanced combination of the above features rather than anything new).<p>It is unfortunate in a way that Haskell is so different from anything that I have learned before, in that given some task I will still feel more confident using a "conventional" language to get the job done, and thus straying away from the likes of Haskell. Regardless of whether Haskell carves out a solid place in my toolbox, it has definitely expanded my insight into what is possible.</div></div></section><footer></footer></div><script src=https://jsdw.me/page.js></script>