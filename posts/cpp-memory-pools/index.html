<!doctype html><html><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><title>
    jsdw - C++ Optimization: Making use of Memory Pools
</title><link href="https://fonts.googleapis.com/css?family=IBM+Plex+Serif|Open+Sans" rel=stylesheet><link href=https://jsdw.me/app.css rel=stylesheet><link href=https://jsdw.me/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><link href=https://jsdw.me/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=https://jsdw.me/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=https://jsdw.me/site.webmanifest rel=manifest><link color=#5bbad5 href=https://jsdw.me/safari-pinned-tab.svg rel=mask-icon><meta content=#f9409c name=msapplication-TileColor><meta content=#ffffff name=theme-color><body><div class="body post"><header><div class=title-inner><div class=jsdw><a href=https://jsdw.me>JSDW</a></div><nav><a href=https://jsdw.me/posts/>posts</a><a href=https://jsdw.me/projects/>projects</a></nav></div></header><section><div class=top><div class=top-scene><svg class="polygon two" viewbox="0 0 100 100" height=100% style=fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421 version=1.1 width=100% xml:space=preserve xmlns=http://www.w3.org/2000/svg xmlns:serif=http://www.serif.com/ xmlns:xlink=http://www.w3.org/1999/xlink><polygon points="0 100, 15 40, 60 0, 100 30"/></svg><svg class="polygon one" viewbox="0 0 100 100" height=100% style=fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421 version=1.1 width=100% xml:space=preserve xmlns=http://www.w3.org/2000/svg xmlns:serif=http://www.serif.com/ xmlns:xlink=http://www.w3.org/1999/xlink><polygon points="0 40, 30 0, 80 33, 100 100"/></svg></div><div class=top-inner><h1 class=title>C++ Optimization: Making use of Memory Pools <span class=date>2013-05-03</span></h1></div></div><div class=content-inner><div class=post><p>This post will explore the creating of a flexible memory pool in C++, and the performance benefits of using it.<h1 id=introduction>Introduction</h1><p>Allocating and deallocating memory are expensive operations. In cases where you are creating and destroying a lot of instances of some object, you will be doing a lot of memory allocation and deallocation. Particularly in the case of very small objects, the cost of finding a chunk of memory to allocate for them is somewhat disproportionate to the cost of initializing the object to some desired state.<p>A number of common scenarios are allocation heavy. For instance, in computer games you may have object representing bullets fired, which are constantly being created and destroyed as the bullets go into and out of existence. Another example may be in linked list structures, where items are frequently being inserted and removed.<p>Wouldn't it be nice then if we could reuse the memory that we allocate for these objects, rather than spending our time freeing memory up, only to assign new chunks of memory soon after. By doing so, we can significantly reduce these expensive costs. This is where memory pools come in.<p>Memory pools take control of the creating and destroying of objects. In the simplest case, rather than freeing up memory every time an object is destroyed, we hold onto its memory location - known as adding it to the pool - knowing we'll be needing it again. Next time an object wants to be created, we look to see if there is any free memory available in the pool. If there is, we use that, saving the cost of looking for and allocating a new chunk of memory for it. If not, we simply allocate it normally.<p>A slightly more complex approach has us allocate large blocks of memory, from which we can slice bits off for our objects as we need them. This can also be combined with the above approach, to use and reuse the same chunks multiple times.<h1 id=some-prerequisite-knowledge>Some Prerequisite Knowledge</h1><p>C++ has one particularly useful feature to help pull this off; placement new. This is used similarly to how the <code>new</code> operator is used to create new instances of some object dynamically, except that we provide it with a memory location to do the constructing in, rather than allowing it to allocate a suitable chunk of memory. Here it is in action:<pre class=language-cpp data-lang=cpp style=background:#272822;color:#f8f8f2><code class=language-cpp data-lang=cpp><span>
</span><span style=font-style:italic;color:#66d9ef>struct </span><span>SomeObject
</span><span>	{
</span><span>	</span><span style=font-style:italic;color:#66d9ef>int</span><span> val;
</span><span>	</span><span style=color:#a6e22e>SomeObject</span><span>(</span><span style=font-style:italic;color:#66d9ef>int </span><span style=font-style:italic;color:#fd971f>val_in</span><span>): val(val_in) {}
</span><span>	};
</span><span>
</span><span style=font-style:italic;color:#66d9ef>int </span><span style=color:#a6e22e>main</span><span>()
</span><span>	{
</span><span>
</span><span>	</span><span style=color:#75715e>//use the global operator new to allocate some bytes memory:
</span><span>	</span><span style=font-style:italic;color:#66d9ef>void </span><span style=color:#f92672>*</span><span> free_space </span><span style=color:#f92672>= </span><span>::operator </span><span style=color:#f92672>new</span><span>(</span><span style=color:#f92672>sizeof</span><span>(SomeObject));
</span><span>
</span><span>	</span><span style=color:#75715e>//use placement new, to stick an instance of SomeObject there:
</span><span>	SomeObject </span><span style=color:#f92672>*</span><span> o </span><span style=color:#f92672>= new </span><span>(free_space) SomeObject(</span><span style=color:#ae81ff>100</span><span>);
</span><span>
</span><span>	</span><span style=color:#75715e>//prints 100:
</span><span>	std::cout </span><span style=color:#f92672><<</span><span> o->val </span><span style=color:#f92672><<</span><span> std::endl;
</span><span>
</span><span>	</span><span style=color:#75715e>//call the destructor on the object:
</span><span>	o->~SomeObject();
</span><span>
</span><span>	</span><span style=color:#75715e>//delete the memory created for it:
</span><span>   ::operator </span><span style=color:#f92672>delete</span><span>(free_space);
</span><span>
</span><span>	</span><span style=color:#f92672>return </span><span style=color:#ae81ff>0</span><span>;
</span><span>	}
</span></code></pre><p>In the above, we also see the global <code>operator new</code> and <code>operator delete</code> functions used. The former simply allocates some number of bytes of memory (much like <code>malloc</code> in <em>C</em>), and returns a pointer to them. The latter frees up the memory at the address provided. In our case, we want to allocate enough memory to fit an instance of <code>SomeObject</code>, so we use <code>sizeof</code> to return the number of bytes required to hold it, and allocate that number of bytes in memory.<p>Next, we use the placement new operator to construct an instance of our object at a given location in memory. We pass it our <code>free_space</code> pointer, which points to the memory location we wish to construct it at. The syntax of placement new, as seen above, is simply:<pre class=language-cpp data-lang=cpp style=background:#272822;color:#f8f8f2><code class=language-cpp data-lang=cpp><span style=color:#f92672>new </span><span>(memory_location) ClassName(constructor_arguments);
</span></code></pre><p>When we are done with the object, we perform the reverse of the above, by first explicitly calling the object destructor (which quickly becomes necessary in anything much more complex than the above), and then using the global operator delete to free up the memory again.<h1 id=making-our-first-object-pool>Making our First Object Pool</h1><p>Given the above, we can start to put together our first object pool. Let's get straight to the code:<pre class=language-cpp data-lang=cpp style=background:#272822;color:#f8f8f2><code class=language-cpp data-lang=cpp><span style=font-style:italic;color:#66d9ef>template</span><span><</span><span style=font-style:italic;color:#66d9ef>typename</span><span> Type>
</span><span style=font-style:italic;color:#66d9ef>class </span><span style=text-decoration:underline;color:#a6e22e>BasicPool
</span><span>    {
</span><span>    </span><span style=color:#f92672>public</span><span>:
</span><span>    </span><span style=color:#75715e>//constructor (we don't need to do anything here)
</span><span>    </span><span style=color:#a6e22e>BasicPool</span><span>() {}
</span><span>
</span><span>    </span><span style=color:#75715e>//delete the copy constructor; we can't copy it:
</span><span>    </span><span style=color:#a6e22e>BasicPool</span><span>(</span><span style=color:#f92672>const</span><span> BasicPool </span><span style=color:#f92672>&</span><span>)</span><span style=color:#f92672>=delete</span><span>;
</span><span>
</span><span>    </span><span style=color:#75715e>//move constructor, so we can move it:
</span><span>    </span><span style=color:#a6e22e>BasicPool</span><span>(BasicPool </span><span style=color:#f92672>&& </span><span style=font-style:italic;color:#fd971f>other</span><span>)
</span><span>        {
</span><span>        this->free(std::move(other.free));
</span><span>        }
</span><span>
</span><span>    </span><span style=color:#75715e>//allocate a chunk of memory as big as Type needs:
</span><span>    </span><span style=font-style:italic;color:#66d9ef>void </span><span style=color:#f92672>* </span><span style=color:#a6e22e>allocate</span><span>()
</span><span>        {
</span><span>        </span><span style=font-style:italic;color:#66d9ef>void </span><span style=color:#f92672>*</span><span> place;
</span><span>        </span><span style=color:#f92672>if</span><span>(</span><span style=color:#f92672>!</span><span>free.empty())
</span><span>            {
</span><span>            place </span><span style=color:#f92672>= static_cast</span><span><</span><span style=font-style:italic;color:#66d9ef>void</span><span style=color:#f92672>*</span><span>>(free.top());
</span><span>            free.pop();
</span><span>            }
</span><span>        </span><span style=color:#f92672>else
</span><span>            {
</span><span>            place </span><span style=color:#f92672>= </span><span>::operator </span><span style=color:#f92672>new</span><span>(</span><span style=color:#f92672>sizeof</span><span>(Type));
</span><span>            }
</span><span>        </span><span style=color:#f92672>return</span><span> place;
</span><span>        }
</span><span>
</span><span>    </span><span style=color:#75715e>//mark some memory as available (no longer used):
</span><span>    </span><span style=font-style:italic;color:#66d9ef>void </span><span style=color:#a6e22e>deallocate</span><span>(</span><span style=font-style:italic;color:#66d9ef>void </span><span style=color:#f92672>* </span><span style=font-style:italic;color:#fd971f>o</span><span>)
</span><span>        {
</span><span>        free.push(</span><span style=color:#f92672>static_cast</span><span>&LTType</span><span style=color:#f92672>*</span><span>>(o));
</span><span>        }
</span><span>
</span><span>    </span><span style=color:#75715e>//delete all of the available memory chunks:
</span><span>    </span><span style=color:#a6e22e>~BasicPool</span><span>()
</span><span>        {
</span><span>        </span><span style=color:#f92672>while</span><span>(</span><span style=color:#f92672>!</span><span>free.empty())
</span><span>            {
</span><span>            ::operator </span><span style=color:#f92672>delete</span><span>(free.top());
</span><span>            free.pop();
</span><span>            }
</span><span>        }
</span><span>
</span><span>    </span><span style=color:#f92672>private</span><span>:
</span><span>
</span><span>    </span><span style=color:#75715e>//stack to hold pointers to free chunks:
</span><span>    std::stack&LTType</span><span style=color:#f92672>*</span><span>> free;
</span><span>    };
</span></code></pre><p>This is a template class, enabling us to create a pool for any object type that we want. It could be used as follows:<pre class=language-cpp data-lang=cpp style=background:#272822;color:#f8f8f2><code class=language-cpp data-lang=cpp><span style=font-style:italic;color:#66d9ef>struct </span><span>SomeObject
</span><span>    {
</span><span>    </span><span style=font-style:italic;color:#66d9ef>int</span><span> val;
</span><span>    </span><span style=color:#a6e22e>SomeObject</span><span>(</span><span style=font-style:italic;color:#66d9ef>int </span><span style=font-style:italic;color:#fd971f>val_in</span><span>): val(val_in) {}
</span><span>    };
</span><span>
</span><span style=font-style:italic;color:#66d9ef>int </span><span style=color:#a6e22e>main</span><span>()
</span><span>    {
</span><span>    BasicPool&LTSomeObject> p;
</span><span>
</span><span>    </span><span style=color:#75715e>//create an instance of SomeObject from our pool:
</span><span>    </span><span style=font-style:italic;color:#66d9ef>void </span><span style=color:#f92672>*</span><span> free_space </span><span style=color:#f92672>=</span><span> p.allocate();
</span><span>    SomeObject </span><span style=color:#f92672>*</span><span> o </span><span style=color:#f92672>= new </span><span>(free_space) SomeObject(</span><span style=color:#ae81ff>10</span><span>);
</span><span>
</span><span>    </span><span style=color:#75715e>//destroy it:
</span><span>    p.deallocate(o);
</span><span>    o->~SomeObject();
</span><span>
</span><span>    </span><span style=color:#f92672>return </span><span style=color:#ae81ff>0</span><span>;
</span><span>    }
</span></code></pre><p>The main functions then are just <code>allocate</code> and <code>deallocate</code>. The former outputs a pointer to an available chunk of memory. It does so by checking whether there is any free memory pointed to in the stack named <code>free</code>. If there is not, it creates a new chunk of the required size. The <code>deallocate</code> function simply adds the memory at the given location back into the pool, so that it can be handed out next time an object of type <code>SomeObject</code> needs memory. The memory location passed to <code>deallocate</code> must be of the same size as those handed out by <code>allocate</code>, otherwise we'll end up with issues.<p>It would be nice if we could simplify the interface to this a little, and remove this potential issue. Thankfully, with C++11 variadic templates (read my previous post <a href=https://jsdw.me/posts/cpp-memory-pools/./posts/cpp11-new-additions/index.md>here</a> for more about those) we can. We add two functions to our memory pool, create and remove, that hide the mess away for us:<pre class=language-cpp data-lang=cpp style=background:#272822;color:#f8f8f2><code class=language-cpp data-lang=cpp><span style=font-style:italic;color:#66d9ef>template</span><span><</span><span style=font-style:italic;color:#66d9ef>typename</span><span> Type>
</span><span style=font-style:italic;color:#66d9ef>class </span><span style=text-decoration:underline;color:#a6e22e>BasicPool
</span><span>    {
</span><span>    </span><span style=color:#f92672>public</span><span>:
</span><span>    </span><span style=color:#a6e22e>BasicPool</span><span>() {}
</span><span>
</span><span>    </span><span style=color:#75715e>//delete the copy constructor; we can't copy it:
</span><span>    </span><span style=color:#a6e22e>BasicPool</span><span>(</span><span style=color:#f92672>const</span><span> BasicPool </span><span style=color:#f92672>&</span><span>)</span><span style=color:#f92672>=delete</span><span>;
</span><span>
</span><span>    </span><span style=color:#75715e>//move constructor; we can move it:
</span><span>    </span><span style=color:#a6e22e>BasicPool</span><span>(BasicPool </span><span style=color:#f92672>&& </span><span style=font-style:italic;color:#fd971f>other</span><span>)
</span><span>        {
</span><span>        this->free(std::move(other.free));
</span><span>        }
</span><span>
</span><span>    </span><span style=color:#75715e>//#### create an instance of Type:
</span><span>    </span><span style=font-style:italic;color:#66d9ef>template</span><span><</span><span style=font-style:italic;color:#66d9ef>typename</span><span style=color:#f92672>...</span><span> Args>
</span><span>    Type </span><span style=color:#f92672>* </span><span style=color:#a6e22e>create</span><span>(Args </span><span style=color:#f92672>&& ...</span><span style=font-style:italic;color:#fd971f>args</span><span>)
</span><span>        {
</span><span>        Type </span><span style=color:#f92672>*</span><span> place </span><span style=color:#f92672>= </span><span>(Type</span><span style=color:#f92672>*</span><span>)(allocate());
</span><span>        </span><span style=color:#f92672>try</span><span>{ </span><span style=color:#f92672>new </span><span>(place) Type(std::forward&LTArgs>(args)</span><span style=color:#f92672>...</span><span>); }
</span><span>        </span><span style=color:#f92672>catch</span><span>(</span><span style=color:#f92672>...</span><span>) { free.push(place); </span><span style=color:#f92672>throw</span><span>; }
</span><span>        </span><span style=color:#f92672>return</span><span> place;
</span><span>        }
</span><span>
</span><span>    </span><span style=color:#75715e>//#### remove an instance of Type (add memory to the pool):
</span><span>    </span><span style=font-style:italic;color:#66d9ef>void </span><span style=color:#a6e22e>remove</span><span>(Type </span><span style=color:#f92672>* </span><span style=font-style:italic;color:#fd971f>o</span><span>)
</span><span>        {
</span><span>        o->~Type();
</span><span>        free.push(o);
</span><span>        }
</span><span>
</span><span>    </span><span style=color:#75715e>//allocate a chunk of memory as big as Type needs:
</span><span>    </span><span style=font-style:italic;color:#66d9ef>void </span><span style=color:#f92672>* </span><span style=color:#a6e22e>allocate</span><span>()
</span><span>        {
</span><span>        </span><span style=font-style:italic;color:#66d9ef>void </span><span style=color:#f92672>*</span><span> place;
</span><span>        </span><span style=color:#f92672>if</span><span>(</span><span style=color:#f92672>!</span><span>free.empty())
</span><span>            {
</span><span>            place </span><span style=color:#f92672>= static_cast</span><span><</span><span style=font-style:italic;color:#66d9ef>void</span><span style=color:#f92672>*</span><span>>(free.top());
</span><span>            free.pop();
</span><span>            }
</span><span>        </span><span style=color:#f92672>else
</span><span>            {
</span><span>            place </span><span style=color:#f92672>= operator new</span><span>(</span><span style=color:#f92672>sizeof</span><span>(Type));
</span><span>            }
</span><span>        </span><span style=color:#f92672>return</span><span> place;
</span><span>        }
</span><span>
</span><span>    </span><span style=color:#75715e>//mark some memory as available (no longer used):
</span><span>    </span><span style=font-style:italic;color:#66d9ef>void </span><span style=color:#a6e22e>deallocate</span><span>(</span><span style=font-style:italic;color:#66d9ef>void </span><span style=color:#f92672>* </span><span style=font-style:italic;color:#fd971f>o</span><span>)
</span><span>        {
</span><span>        free.push(</span><span style=color:#f92672>static_cast</span><span>&LTType</span><span style=color:#f92672>*</span><span>>(o));
</span><span>        }
</span><span>
</span><span>    </span><span style=color:#75715e>//delete all of the available memory chunks:
</span><span>    </span><span style=color:#a6e22e>~BasicPool</span><span>()
</span><span>        {
</span><span>        </span><span style=color:#f92672>while</span><span>(</span><span style=color:#f92672>!</span><span>free.empty())
</span><span>            {
</span><span>            ::operator </span><span style=color:#f92672>delete</span><span>(free.top());
</span><span>            free.pop();
</span><span>            }
</span><span>        }
</span><span>
</span><span>    </span><span style=color:#f92672>private</span><span>:
</span><span>
</span><span>    </span><span style=color:#75715e>//stack to hold pointers to free chunks:
</span><span>    std::stack&LTType</span><span style=color:#f92672>*</span><span>> free;
</span><span>    };
</span></code></pre><p>What's going on here then? Well, the <code>create</code> function takes in a variable number of arguments (whatever we would normally pass to the constructor). It then uses the <code>allocate</code> function as before to provide a chunk of memory to use, but in addition, it forwards the arguments passed in to the constructor of whatever <code>Type</code> is, and constructs an instance of the object using <em>placement new</em>. It then returns a pointer of <code>Type</code> which points to that instance.<p>It is important to note the try/catch block surrounding the placement new; if for some reason our object type throws an error on construction, we want to free up that memory again to avoid potential leaks.<p>The <code>remove</code> function simply adds a pointer to the location in memory that is passed in to the <code>free</code> stack, just like <code>deallocate</code>, but in addition calls the destructor of the object to do any cleaning up that it requires.<p>Now, we can very easily create and destroy objects, like this:<pre class=language-cpp data-lang=cpp style=background:#272822;color:#f8f8f2><code class=language-cpp data-lang=cpp><span style=font-style:italic;color:#66d9ef>int </span><span style=color:#a6e22e>main</span><span>()
</span><span>    {
</span><span>    BasicPool&LTSomeObject> p;
</span><span>
</span><span>    </span><span style=color:#75715e>//create an instance of SomeObject from the pool:
</span><span>    SomeObject </span><span style=color:#f92672>*</span><span> o </span><span style=color:#f92672>=</span><span> p.create(</span><span style=color:#ae81ff>10</span><span>);
</span><span>
</span><span>    </span><span style=color:#75715e>//destroy it when done, putting memory back into the pool:
</span><span>    p.remove(o);
</span><span>
</span><span>    </span><span style=color:#f92672>return </span><span style=color:#ae81ff>0</span><span>;
</span><span>    }
</span></code></pre><p>Nice and simple! You'll probably also want to add a function to deallocate all of the free memory currently held in the pool, but I'll leave that as an exercise for you.<h1 id=a-comparison>A Comparison</h1><p>So, how exactly does using the simple object pool we created above compare with just using the <code>new</code> and <code>delete</code> operators to handle our memory management? Well, that obviously depends on how you use it; the more that objects are deleted and later created again - in other words, the more allocation and deallocation we can save by using a pool - the more benefit you'll see. Here is a simple test set-up, where we do a bunch of creating and deleting of our very simple object:<pre class=language-cpp data-lang=cpp style=background:#272822;color:#f8f8f2><code class=language-cpp data-lang=cpp><span style=font-style:italic;color:#66d9ef>void </span><span style=color:#a6e22e>usePool</span><span>()
</span><span>    {
</span><span>    std::stack</span><span style=color:#f92672><</span><span>SomeObject</span><span style=color:#f92672>*></span><span> s;
</span><span>    BasicPool&LTSomeObject> p;
</span><span>    </span><span style=color:#f92672>for</span><span>(</span><span style=font-style:italic;color:#66d9ef>unsigned</span><span> i </span><span style=color:#f92672>= </span><span style=color:#ae81ff>0</span><span>; i </span><span style=color:#f92672>< </span><span style=color:#ae81ff>100</span><span>; i</span><span style=color:#f92672>++</span><span>)
</span><span>        {
</span><span>        </span><span style=color:#f92672>for</span><span>(</span><span style=font-style:italic;color:#66d9ef>unsigned</span><span> j </span><span style=color:#f92672>= </span><span style=color:#ae81ff>0</span><span>; j </span><span style=color:#f92672>< </span><span style=color:#ae81ff>1000</span><span>; j</span><span style=color:#f92672>++</span><span>)
</span><span>            {
</span><span>            s.push(p.create(</span><span style=color:#ae81ff>1</span><span>));
</span><span>            }
</span><span>        </span><span style=color:#f92672>while</span><span>(</span><span style=color:#f92672>!</span><span>s.empty())
</span><span>            {
</span><span>            p.remove(s.top());
</span><span>            s.pop();
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>
</span><span style=font-style:italic;color:#66d9ef>void </span><span style=color:#a6e22e>noPool</span><span>()
</span><span>    {
</span><span>    std::stack</span><span style=color:#f92672><</span><span>SomeObject</span><span style=color:#f92672>*></span><span> s;
</span><span>    </span><span style=color:#f92672>for</span><span>(</span><span style=font-style:italic;color:#66d9ef>unsigned</span><span> i </span><span style=color:#f92672>= </span><span style=color:#ae81ff>0</span><span>; i </span><span style=color:#f92672>< </span><span style=color:#ae81ff>100</span><span>; i</span><span style=color:#f92672>++</span><span>)
</span><span>        {
</span><span>        </span><span style=color:#f92672>for</span><span>(</span><span style=font-style:italic;color:#66d9ef>unsigned</span><span> j </span><span style=color:#f92672>= </span><span style=color:#ae81ff>0</span><span>; j </span><span style=color:#f92672>< </span><span style=color:#ae81ff>1000</span><span>; j</span><span style=color:#f92672>++</span><span>)
</span><span>            {
</span><span>            s.push(</span><span style=color:#f92672>new </span><span>SomeObject(</span><span style=color:#ae81ff>1</span><span>));
</span><span>            }
</span><span>        </span><span style=color:#f92672>while</span><span>(</span><span style=color:#f92672>!</span><span>s.empty())
</span><span>            {
</span><span>            </span><span style=color:#f92672>delete</span><span> s.top();
</span><span>            s.pop();
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>
</span><span style=font-style:italic;color:#66d9ef>int </span><span style=color:#a6e22e>main</span><span>()
</span><span>    {
</span><span>    usePool();
</span><span>    noPool();
</span><span>    </span><span style=color:#f92672>return </span><span style=color:#ae81ff>0</span><span>;
</span><span>    }
</span></code></pre><p>All this test does is push a bunch of pointers to dynamically created instances of <code>SomeObject</code> - our structure holding a single integer - to a stack, and then delete them from that stack. The <code>usePool</code> function does this using our memory pool, and the <code>noPool</code> function does this using <code>new</code> and <code>delete</code>. Using Valgrind, the number of instructions for each can be counted (fewer is better). The result:<pre class=language-txt data-lang=txt style=background:#272822;color:#f8f8f2><code class=language-txt data-lang=txt><span>usePool(): 7,925,308
</span><span>noPool(): 25,636,536
</span></code></pre><p>So, the <code>usePool</code> function look less than a third the amount of time to execute! This highlights exactly how much time is spent allocating and deallocating memory, and consequently how much time can be saved by reducing it. The pool version is faster even when the outer loop is executed only twice (~12%), saving just 1000 <code>int</code> sized deallocations and allocations. Increasing the number of variables held in SomeObject from 1 to 5 also has very little impact, but favours using the memory pool slightly more.<p>Running this comparison without the overhead of a stack of pointers can result in a far more noticeable difference (I found a 10x speed up in other tests comparing the object pool above with <code>new</code> and <code>delete</code>).<h1 id=further-improvements>Further Improvements</h1><p>Of course, we can try to improve on this further by preallocating memory in larger blocks, rather than per instance, and then assigning parts of the block to instances of our desired type. However, this does come with the drawback of being harder to free up the blocks of memory once they have been created, as it is harder to keep track of what memory within a given block is still in use at any point in time.<p>In my experience, the simple version above cut somewhere about 30% off the execution time of my C++ Sequitur implementation, which does quite a lot of symbol creating/destroying over the course of its lifetime. Using a block allocation variant resulted in a further speedup of another 9%, but on balance was not worth the difficulty in freeing up the potentially significant amount of memory used.<h2 id=inheriting-memory-pool-functionality>Inheriting Memory Pool Functionality</h2><p>Another thing that we can do to make our object pool almost entirely transparent, is to override the member <code>operator new</code> and <code>operator delete</code> functions for a class to use it. Like the global versions, these handle allocating and deleting the memory only, not constructing or destructing the instance. As such, the <code>allocate</code> and <code>deallocate</code> functions of our object pool come in handy.<p>I did this myself by writing a small template class, which could be inherited from to give the inheriting class this transparent functionality; it looks something like the following:<pre class=language-cpp data-lang=cpp style=background:#272822;color:#f8f8f2><code class=language-cpp data-lang=cpp><span style=font-style:italic;color:#66d9ef>template</span><span><</span><span style=font-style:italic;color:#66d9ef>typename</span><span> Child, </span><span style=font-style:italic;color:#66d9ef>template</span><span><</span><span style=font-style:italic;color:#66d9ef>typename</span><span style=color:#f92672>=</span><span>Child> </span><span style=font-style:italic;color:#66d9ef>class</span><span> PoolClass </span><span style=color:#f92672>=</span><span> BasicPool >
</span><span style=font-style:italic;color:#66d9ef>class </span><span style=text-decoration:underline;color:#a6e22e>InheritablePool
</span><span>  {
</span><span>  </span><span style=color:#f92672>public</span><span>:
</span><span>  </span><span style=color:#75715e>//provide access from the inheriting object to clear the pool:
</span><span>  </span><span style=color:#f92672>static </span><span style=font-style:italic;color:#66d9ef>void </span><span style=color:#a6e22e>clearPool</span><span>()
</span><span>      {
</span><span>      pool.clear();
</span><span>      }
</span><span>
</span><span>  </span><span style=color:#f92672>static </span><span style=font-style:italic;color:#66d9ef>void </span><span style=color:#f92672>*</span><span> operator </span><span style=color:#f92672>new</span><span>(</span><span style=font-style:italic;color:#66d9ef>size_t</span><span>)
</span><span>      {
</span><span>      </span><span style=color:#f92672>return</span><span> pool.allocate();
</span><span>      }
</span><span>  </span><span style=color:#f92672>static </span><span style=font-style:italic;color:#66d9ef>void</span><span> operator </span><span style=color:#f92672>delete</span><span>(</span><span style=font-style:italic;color:#66d9ef>void</span><span style=color:#f92672>*</span><span> in)
</span><span>      {
</span><span>      pool.deallocate(in);
</span><span>      }
</span><span>
</span><span>  </span><span style=color:#f92672>private</span><span>:
</span><span>  </span><span style=color:#75715e>//protected ctors so only Child can make instances:
</span><span>  </span><span style=color:#a6e22e>InheritablePool</span><span>() {}
</span><span>  </span><span style=color:#a6e22e>InheritablePool</span><span>(</span><span style=color:#f92672>const</span><span> InheritablePool </span><span style=color:#f92672>&</span><span>) {}
</span><span>
</span><span>  </span><span style=color:#75715e>//our object pool (where PoolClass defaults to BasicPool):
</span><span>  </span><span style=color:#f92672>static</span><span> PoolClass&LTChild> pool;
</span><span>
</span><span>  </span><span style=color:#75715e>//Child class can make instances:
</span><span>  </span><span style=color:#f92672>friend</span><span> Child;
</span><span>  };
</span><span>
</span><span style=color:#75715e>//define the static pool variable:
</span><span style=font-style:italic;color:#66d9ef>template</span><span><</span><span style=font-style:italic;color:#66d9ef>typename</span><span> Child, </span><span style=font-style:italic;color:#66d9ef>template</span><span><</span><span style=font-style:italic;color:#66d9ef>typename</span><span>> </span><span style=font-style:italic;color:#66d9ef>class</span><span> PoolClass>
</span><span>PoolClass&LTChild> InheritablePool&LTChild,PoolClass>::pool;
</span><span>
</span><span style=color:#75715e>//make inheriting a little less wordy using a define:
</span><span style=color:#f92672>#define </span><span style=color:#a6e22e>UseObjectPool</span><span>( </span><span style=font-style:italic;color:#fd971f>x </span><span>) public </span><span style=color:#f92672>virtual</span><span> InheritablePool&LTx>
</span></code></pre><p>This can then be used as follows, using the example of our <code>SomeObject</code> class:<pre class=language-cpp data-lang=cpp style=background:#272822;color:#f8f8f2><code class=language-cpp data-lang=cpp><span style=font-style:italic;color:#66d9ef>struct </span><span>SomeObject: </span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>UseObjectPool</span><span>(</span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>SomeObject</span><span>)
</span><span>    {
</span><span>    </span><span style=font-style:italic;color:#66d9ef>int</span><span> val;
</span><span>    </span><span style=color:#a6e22e>SomeObject</span><span>(</span><span style=font-style:italic;color:#66d9ef>int </span><span style=font-style:italic;color:#fd971f>val_in</span><span>): val(val_in) {}
</span><span>    };
</span></code></pre><p>Resulting in the benefits of using a memory pool, combined with the transparency of using the standard syntax. The function <code>SomeObject::clearPool()</code> would free up any memory held onto by the object pool, if it became necessary to do so (for example, we had deleted all instances of our object and wanted our memory back!).<p>A downside to this approach is that the class should not be inherited from by anything that adds new member variables. In the above case, the use of <code>friend Child;</code> combined with the private constructor and copy constructor, and the virtual inheritance (which is simplified by the <code>#define</code>), prevents any instantiations of classes that inherit from anything using the <code>InheritablePool</code> class. As such, the <code>SomeObject</code> class, as defined above, can not be inherited from.<p>Whether or not you would choose to block the inheritance in this way, or indeed make use of object pools like this, is up to you. In my case, I would probably have preferred to use them explicitly, but the modifications to existing code would have taken significantly more effort and coupled things together more than I would have liked, whereas the class inheritance solution above allows object pools to very easily be made use of by existing classes.<p>If you do inherit object pool functionality as above, make sure to free up any available memory left in the pool when necessary. In the above case, the line:<pre class=language-cpp data-lang=cpp style=background:#272822;color:#f8f8f2><code class=language-cpp data-lang=cpp><span>SomeObject::</span><span style=color:#a6e22e>clearPool</span><span>();
</span></code></pre><p>Would do just that.<h1 id=final-remarks>Final Remarks</h1><p>Anyway, This has been a relatively brief but hopefully useful tutorial on C++ memory pools. Writing the code is relatively easy, and integrating them into existing code using features such as inheritance is relatively easy to do. The performance gains made are substantial, making them invaluable in high performance code.<p>Feel free to make use of any of the code above (you will need C++11 support), and get in touch if you have any queries or comments!</div></div></section><footer></footer></div><script src=https://jsdw.me/page.js></script>