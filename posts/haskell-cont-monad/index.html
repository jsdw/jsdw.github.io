<!doctype html><html><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><title>
    jsdw - Haskell: A Look at the Continuation Monad
</title><link href="https://fonts.googleapis.com/css?family=IBM+Plex+Serif|Open+Sans" rel=stylesheet><link href=https://jsdw.me/app.css rel=stylesheet><link href=https://jsdw.me/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><link href=https://jsdw.me/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=https://jsdw.me/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=https://jsdw.me/site.webmanifest rel=manifest><link color=#5bbad5 href=https://jsdw.me/safari-pinned-tab.svg rel=mask-icon><meta content=#f9409c name=msapplication-TileColor><meta content=#ffffff name=theme-color><body><div class="body post"><header><div class=title-inner><div class=jsdw><a href=https://jsdw.me>JSDW</a></div><nav><a href=https://jsdw.me/posts/>posts</a><a href=https://jsdw.me/projects/>projects</a></nav></div></header><section><div class=top><div class=top-scene><svg class="polygon two" viewbox="0 0 100 100" height=100% style=fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421 version=1.1 width=100% xml:space=preserve xmlns=http://www.w3.org/2000/svg xmlns:serif=http://www.serif.com/ xmlns:xlink=http://www.w3.org/1999/xlink><polygon points="0 100, 15 40, 60 0, 100 30"/></svg><svg class="polygon one" viewbox="0 0 100 100" height=100% style=fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421 version=1.1 width=100% xml:space=preserve xmlns=http://www.w3.org/2000/svg xmlns:serif=http://www.serif.com/ xmlns:xlink=http://www.w3.org/1999/xlink><polygon points="0 40, 30 0, 80 33, 100 100"/></svg></div><div class=top-inner><h1 class=title>Haskell: A Look at the Continuation Monad <span class=date>2015-06-07</span></h1></div></div><div class=content-inner><div class=post><p>Some notes on Continuations in Haskell. What are they, how are they used and what are they good for? All of the following code can be found <a href=https://jsdw.me/posts/haskell-cont-monad/examples.hs>here</a> ready to be plugged into GHCI and played with.<h1 id=introduction-to-continuations>Introduction to Continuations</h1><p>Continuations work by providing their result to a callback that's passed in, rather than directly. Starting simple, here is how values can be presented in the form of continuations.<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>twoC </span><span style=color:#f92672>= \</span><span>out </span><span style=color:#f92672>-></span><span> out </span><span style=color:#ae81ff>2
</span><span>helloC </span><span style=color:#f92672>= \</span><span>out </span><span style=color:#f92672>-></span><span> out </span><span style=color:#e6db74>"hello"
</span></code></pre><p>These take the form <code>(a -> r) -> r</code>, where <code>a</code> is the output from the continuation and <code>r</code> the final result after the callback is applied. <code>id</code> is a function that simply takes a value and returns it (<code>\a -> a</code>), and so I'll use it to pull values out of continuations quite a lot below.<p>We can use it to extract values from the above continuations as follows:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>twoC id </span><span style=color:#f92672>== </span><span style=color:#ae81ff>2
</span><span>helloC id </span><span style=color:#f92672>== </span><span style=color:#e6db74>"hello"
</span></code></pre><p>We could simplify creating these values with a simple function that takes a value and gives back a continuation just like one of the above:<pre style=background:#272822;color:#f8f8f2><code><span>ret val = \out -> out val
</span></code></pre><p>So now we can create continuations like so:<pre style=background:#272822;color:#f8f8f2><code><span>anotherTwoC = ret 2
</span><span>anotherHelloC = ret "hello"
</span></code></pre><h1 id=chaining-continuations>Chaining Continuations</h1><p>Once we can create continuations, the next thing to do that would be useful is joining them together so that we can work with them. We'll do as Monads would do and create a function called <code>bind</code> that takes a continuation and a function which is provided the value of it and returns a new continuation as a result:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>inC </span><span style=color:#f92672>`bind`</span><span> fn </span><span style=color:#f92672>= \</span><span>out </span><span style=color:#f92672>-></span><span> inC (</span><span style=color:#f92672>\</span><span>inCval </span><span style=color:#f92672>-></span><span> (fn inCval) out)
</span></code></pre><p>Since continuations work by passing their result into the provided function, to make use of the value given back from the first continuation we pass it a function that will be provided this value (<code>inC (\inCval -> ...)</code>). We then pass the value to our <code>fn</code>, which is expected to return a continuation itself. Finally, we wrap this in a continuation whose callback we pass to the new continuation created from <code>fn inCval</code>.<p>Things will become more clear when we see this <code>bind</code> function in action:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- a simple example that doubles the value handed back from twoC:
</span><span>fourC </span><span style=color:#f92672>=</span><span> twoC </span><span style=color:#f92672>`bind` \</span><span>two </span><span style=color:#f92672>-></span><span> ret (two*</span><span style=color:#ae81ff>2</span><span>)
</span><span>
</span><span style=color:#75715e>-- a more complex example combining the results of two continuations:
</span><span>twoHelloC </span><span style=color:#f92672>=</span><span> twoC </span><span style=color:#f92672>`bind` \</span><span>two </span><span style=color:#f92672>->
</span><span>              helloC </span><span style=color:#f92672>`bind` \</span><span>hello </span><span style=color:#f92672>->
</span><span>                ret </span><span style=color:#f92672>$</span><span> (show two)</span><span style=color:#f92672>++</span><span>hello
</span></code></pre><p>The result of running these new continuations is:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>fourC id </span><span style=color:#f92672>== </span><span style=color:#ae81ff>4
</span><span>twoHelloC id </span><span style=color:#f92672>== </span><span style=color:#e6db74>"2hello"
</span></code></pre><p>The interesting thing is that when chaining continuations with <code>bind</code>, we alter the effect of the callback on the result of each previous continuations value. What happens then if you pass a function that doesn't use its callback?<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>badC </span><span style=color:#f92672>= \</span><span>out </span><span style=color:#f92672>-> </span><span style=color:#e6db74>"boom!"
</span><span>
</span><span>twoBadC </span><span style=color:#f92672>=</span><span> twoC </span><span style=color:#f92672>`bind` \</span><span>two </span><span style=color:#f92672>->
</span><span>            badC </span><span style=color:#f92672>`bind` \</span><span>hello </span><span style=color:#f92672>->
</span><span>              ret </span><span style=color:#f92672>$</span><span> (show two)</span><span style=color:#f92672>++</span><span>hello
</span></code></pre><p>Since we never use the callback, all subsequent continuations (that each effect only the callback function provided to those before them), including the final function we apply when we want to get the value out (above that's been "id") are simply ignored, and thus we end up with:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>twoBadC id </span><span style=color:#f92672>== </span><span style=color:#e6db74>"boom!"
</span></code></pre><h1 id=mapping-a-function-over-some-continuation>Mapping a Function over some Continuation</h1><p>The same approach we took to chain continuations with our <code>bind</code> function can be used to write a map function, that runs some function on the eventual result of some continuation. Once again, it does this by wrapping the callback provided to the input continuation to alter the value before returning it to <code>out</code>:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>mapC fn inC </span><span style=color:#f92672>= \</span><span>out </span><span style=color:#f92672>-></span><span> inC (</span><span style=color:#f92672>\</span><span>inCval </span><span style=color:#f92672>-></span><span> out (fn inCval))
</span><span>
</span><span style=color:#75715e>-- Note that we are applying inCval to fn, and then out. Thus,
</span><span style=color:#75715e>-- this can be simplified using point free notation to:
</span><span>mapC' fn inC </span><span style=color:#f92672>= \</span><span>out </span><span style=color:#f92672>-></span><span> inC (out </span><span style=color:#f92672>.</span><span> fn)
</span></code></pre><p>To test it works, make sure it has the right result with continuations that use their callback <strong>and</strong> those that don't. Thus, these should hold true:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>mapC (*</span><span style=color:#ae81ff>2</span><span>) (</span><span style=color:#f92672>\</span><span>out </span><span style=color:#f92672>-></span><span> out </span><span style=color:#ae81ff>5</span><span>) id </span><span style=color:#f92672>== </span><span style=color:#ae81ff>10
</span><span>mapC (*</span><span style=color:#ae81ff>2</span><span>) (</span><span style=color:#f92672>\</span><span>out </span><span style=color:#f92672>-> </span><span style=color:#ae81ff>5</span><span>) id </span><span style=color:#f92672>== </span><span style=color:#ae81ff>5
</span></code></pre><p>A continuation that doesn't use its callback is essentially ignoring all subsequent functions and exiting early. A naive approach to mapping might have been to run the input continuation with id to get its result and then work on that:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>badMapC fn inC </span><span style=color:#f92672>= \</span><span>out </span><span style=color:#f92672>-> let</span><span> val </span><span style=color:#f92672>=</span><span> fn (inC id)
</span><span>                         </span><span style=color:#f92672>in</span><span> out val
</span></code></pre><p>While this seems to work at first, this would apply map regardless of whether the continuation uses its callback or not, and so would result in:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>badMapC (*</span><span style=color:#ae81ff>2</span><span>) (</span><span style=color:#f92672>\</span><span>out </span><span style=color:#f92672>-></span><span> out </span><span style=color:#ae81ff>5</span><span>) id </span><span style=color:#f92672>== </span><span style=color:#ae81ff>10
</span><span>badMapC (*</span><span style=color:#ae81ff>2</span><span>) (</span><span style=color:#f92672>\</span><span>out </span><span style=color:#f92672>-> </span><span style=color:#ae81ff>5</span><span>) id </span><span style=color:#f92672>== </span><span style=color:#ae81ff>10 </span><span style=color:#75715e>-- wrong, should be 5
</span></code></pre><h1 id=the-cont-monad>The Cont Monad</h1><p>This continuation framework already exists in the form of the Cont Monad. The entire basic definition of the Cont monad (with applicative and map lark to satisfy the Monad typeclass) can be seen below. In effect, we take exactly what we have devised above and wrap it into a new type so that we can create typeclass instances for it.<p>Haskell itself defines this in terms of monad transformers. I have removed that aspect here for simplicity:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- wrap continuation functions into Cont type:
</span><span style=color:#f92672>newtype </span><span style=color:#ae81ff>Cont</span><span> r a </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Cont</span><span> { runCont </span><span style=color:#f92672>::</span><span> (a </span><span style=color:#f92672>-></span><span> r) </span><span style=color:#f92672>-></span><span> r }
</span><span>
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>Functor</span><span> (</span><span style=font-style:italic;color:#66d9ef>Cont </span><span>r) </span><span style=color:#f92672>where
</span><span>    </span><span style=color:#75715e>-- same as our mapC' but unwrapping/wrapping Cont:
</span><span>    fmap fn (</span><span style=color:#ae81ff>Cont</span><span> inC) </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Cont </span><span style=color:#f92672>$ \</span><span>out </span><span style=color:#f92672>-></span><span> inC (out </span><span style=color:#f92672>.</span><span> fn)
</span><span>
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>Applicative</span><span> (</span><span style=font-style:italic;color:#66d9ef>Cont </span><span>r) </span><span style=color:#f92672>where
</span><span>    </span><span style=color:#75715e>-- same as ret but wrapping in Cont
</span><span>    pure val </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Cont </span><span style=color:#f92672>$ \</span><span>out </span><span style=color:#f92672>-></span><span> out val
</span><span>    </span><span style=color:#75715e>-- similar to fmap excapt we need to get fn out of a Cont as well.
</span><span>    (</span><span style=color:#ae81ff>Cont</span><span> fnC) </span><span style=color:#f92672><</span><span>*</span><span style=color:#f92672>></span><span> (</span><span style=color:#ae81ff>Cont</span><span> inC) </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Cont </span><span style=color:#f92672>$ \</span><span>out </span><span style=color:#f92672>-></span><span> fnC </span><span style=color:#f92672>$ \</span><span>fn </span><span style=color:#f92672>-></span><span> inC (out </span><span style=color:#f92672>.</span><span> fn)
</span><span>
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>Monad</span><span> (</span><span style=font-style:italic;color:#66d9ef>Cont </span><span>r) </span><span style=color:#f92672>where
</span><span>    </span><span style=color:#75715e>-- same as ret but wrapping in Cont
</span><span>    return </span><span style=color:#f92672>=</span><span> pure
</span><span>    </span><span style=color:#75715e>-- same as `bind` but wrapping/unwrapping Cont:
</span><span>    (</span><span style=color:#ae81ff>Cont</span><span> inC) </span><span style=color:#f92672>>>=</span><span> fn </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Cont </span><span style=color:#f92672>$ \</span><span>out </span><span style=color:#f92672>-></span><span> inC (</span><span style=color:#f92672>\</span><span>a </span><span style=color:#f92672>-></span><span> (runCont (fn a)) out)
</span><span>
</span><span style=color:#75715e>--
</span><span style=color:#75715e>-- We get these functions from the Cont definition as well, the
</span><span style=color:#75715e>-- latter being a simple alias in our non-transformer version
</span><span style=color:#75715e>-- (in the transformer version it hides away the identity monad).
</span><span style=color:#75715e>-- We'll see callCC in action later.
</span><span style=color:#75715e>--
</span><span style=color:#a6e22e>callCC </span><span style=color:#f92672>::</span><span> ((a </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>Cont </span><span>r b) </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>Cont </span><span>r a) </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>Cont </span><span>r a
</span><span>callCC fn </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Cont </span><span style=color:#f92672>$ \</span><span>out </span><span style=color:#f92672>-></span><span> runCont (fn (</span><span style=color:#f92672>\</span><span>a </span><span style=color:#f92672>-> </span><span style=color:#ae81ff>Cont </span><span style=color:#f92672>$ \</span><span>_ </span><span style=color:#f92672>-></span><span> out a)) out
</span><span>
</span><span style=color:#a6e22e>cont </span><span style=color:#f92672>::</span><span> ((a </span><span style=color:#f92672>-> </span><span>r) </span><span style=color:#f92672>-> </span><span>r) </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>Cont </span><span>r a
</span><span>cont </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Cont
</span></code></pre><p>The <code>do</code> notation that the <code>Monad</code> typeclass provides gives us a nicer way to write our earlier examples:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>twoC' </span><span style=color:#f92672>=</span><span> return </span><span style=color:#ae81ff>2
</span><span>helloC' </span><span style=color:#f92672>=</span><span> return </span><span style=color:#e6db74>"hello"
</span><span>
</span><span>twoHelloC' </span><span style=color:#f92672>= do
</span><span>    two </span><span style=color:#f92672>&LT-</span><span> twoC'
</span><span>    hello </span><span style=color:#f92672>&LT-</span><span> helloC'
</span><span>    return </span><span style=color:#f92672>$</span><span> (show two)</span><span style=color:#f92672>++</span><span>hello
</span><span>
</span><span style=color:#75715e>-- remember this desugars to the following, which should look very similar
</span><span style=color:#75715e>-- to our first non-wrapped attempt:
</span><span>twoHelloC'' </span><span style=color:#f92672>=</span><span> twoC' </span><span style=color:#f92672>>>= \</span><span>two </span><span style=color:#f92672>->
</span><span>                helloC' </span><span style=color:#f92672>>>= \</span><span>hello </span><span style=color:#f92672>->
</span><span>                  return </span><span style=color:#f92672>$</span><span> (show two)</span><span style=color:#f92672>++</span><span>hello
</span></code></pre><p>Other than getting to use nicer syntax, the only other change is that, since our continuations are wrapped up in this <code>Cont</code> type, we need to unwrap them to pull values out now:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>(runCont twoHelloC') id </span><span style=color:#f92672>== </span><span style=color:#e6db74>"2hello"
</span></code></pre><h1 id=playing-with-multiple-callback-invocations>Playing with Multiple Callback Invocations</h1><p>As well as escaping early, we can also call the callback more than once. Remember, the callback has (as a result of how <code>bind</code> works) wrapped into it all of our surrounding computations, including that from the final function we use to pull out a value. Lets see:<pre style=background:#272822;color:#f8f8f2><code><span>twoMultiC = do
</span><span>    two &LT- twoC'
</span><span>    hello &LT- cont $ \out -> out "hello" ++ out "hello"
</span><span>    return $ (show two)++hello
</span></code></pre><p>Here, we call our continuation callback twice and join the results. Each invocation of <code>out "hello"</code> runs the rest of the computation and returns the end result, both of which are concatenated. Thus, the following holds true:<pre style=background:#272822;color:#f8f8f2><code><span>runCont twoMultiC id == "2hello2hello"
</span><span>runCont twoMultiC (++"BOOM!") == "2helloBOOM!2helloBOOM!"
</span></code></pre><p>Repetition anywhere has the same effect, the result of running these being identical to above:<pre style=background:#272822;color:#f8f8f2><code><span>twoMultiC' = do
</span><span>    two &LT- cont $ \out -> out 2 ++ out 2
</span><span>    hello &LT- helloC'
</span><span>    return $ (show two)++hello
</span><span>
</span><span>twoMultiC'' = do
</span><span>    two &LT- twoC'
</span><span>    hello &LT- helloC'
</span><span>    cont $ \out -> out ((show two)++hello) ++ out ((show two)++hello)
</span></code></pre><p>In either case, running <code>out</code> with some value leads to every subsequent computation also being run on that value, which will amount to the same result regardless of where you call it. It's a bit mind bending but the more you play with it, the more it starts to make sense! It might help to look at a de-sugared (and in-lined) version of the above:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>desugaredTwoMultiC' </span><span style=color:#f92672>=
</span><span>    (cont </span><span style=color:#f92672>$ \</span><span>out1 </span><span style=color:#f92672>-></span><span> out1 </span><span style=color:#ae81ff>2 </span><span style=color:#f92672>++</span><span> out1 </span><span style=color:#ae81ff>2</span><span>) </span><span style=color:#f92672>>>= \</span><span>two </span><span style=color:#f92672>->
</span><span>        (cont </span><span style=color:#f92672>$ \</span><span>out2 </span><span style=color:#f92672>-></span><span> out2 </span><span style=color:#e6db74>"hello"</span><span>) </span><span style=color:#f92672>>>= \</span><span>hello </span><span style=color:#f92672>->
</span><span>            (cont </span><span style=color:#f92672>$ \</span><span>out3 </span><span style=color:#f92672>-></span><span> out3 </span><span style=color:#f92672>$</span><span> (show two)</span><span style=color:#f92672>++</span><span>hello)
</span></code></pre><p>Each time <code>out1</code> is passed a result, the continuation that is provided the callback <code>out2</code> is called, and each time <code>out2</code> is passed a result, the continuation provided out3 is called. the result of <code>out1 2</code> then is <code>out2 "hello"</code>, which itself is <code>out3 $ (show 2)++"hello</code>. <code>out3</code> is whatever we pass to the continuation when we use <code>runCont</code>, in most examples above <code>id</code>. We can see that it too is then run every time a callback is called.<p>Using this branching feature continuations provide us we can generate combinations of values, for instance:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>multiMultiC </span><span style=color:#f92672>= do
</span><span>    n </span><span style=color:#f92672>&LT-</span><span> cont </span><span style=color:#f92672>$ \</span><span>out </span><span style=color:#f92672>-></span><span> out </span><span style=color:#e6db74>"1" </span><span style=color:#f92672>++</span><span> out </span><span style=color:#e6db74>"2"
</span><span>    l </span><span style=color:#f92672>&LT-</span><span> cont </span><span style=color:#f92672>$ \</span><span>out </span><span style=color:#f92672>-></span><span> out </span><span style=color:#e6db74>"a" </span><span style=color:#f92672>++</span><span> out </span><span style=color:#e6db74>"b"
</span><span>    x </span><span style=color:#f92672>&LT-</span><span> cont </span><span style=color:#f92672>$ \</span><span>out </span><span style=color:#f92672>-></span><span> out </span><span style=color:#e6db74>"X" </span><span style=color:#f92672>++</span><span> out </span><span style=color:#e6db74>"Y"
</span><span>    return </span><span style=color:#f92672>$</span><span> n</span><span style=color:#f92672>++</span><span>l</span><span style=color:#f92672>++</span><span>x</span><span style=color:#f92672>++</span><span style=color:#e6db74>" "
</span></code></pre><p>For which the below is true:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>runCont multiMultiC id </span><span style=color:#f92672>== </span><span style=color:#e6db74>"1aX 1aY 1bX 1bY 2aX 2aY 2bX 2bY "
</span></code></pre><h2 id=exiting-early-from-branches>Exiting Early from Branches</h2><p>Exiting early at different points would limit the amount of branching that takes place. Crucially though, we could not guarantee that we would only exit early once, as other branches would still run. Thus, the following would be true:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>boom1C </span><span style=color:#f92672>= do
</span><span>    n </span><span style=color:#f92672>&LT-</span><span> cont </span><span style=color:#f92672>$ \</span><span>out </span><span style=color:#f92672>-> </span><span style=color:#e6db74>"boom! "
</span><span>    l </span><span style=color:#f92672>&LT-</span><span> cont </span><span style=color:#f92672>$ \</span><span>out </span><span style=color:#f92672>-></span><span> out </span><span style=color:#e6db74>"a" </span><span style=color:#f92672>++</span><span> out </span><span style=color:#e6db74>"b"
</span><span>    x </span><span style=color:#f92672>&LT-</span><span> cont </span><span style=color:#f92672>$ \</span><span>out </span><span style=color:#f92672>-></span><span> out </span><span style=color:#e6db74>"X" </span><span style=color:#f92672>++</span><span> out </span><span style=color:#e6db74>"Y"
</span><span>    return </span><span style=color:#f92672>$</span><span> n</span><span style=color:#f92672>++</span><span>l</span><span style=color:#f92672>++</span><span>x</span><span style=color:#f92672>++</span><span style=color:#e6db74>" "
</span><span>
</span><span style=color:#75715e>-- here, our first line never calls out, so we just return the string:
</span><span style=color:#75715e>-- runCont boom1C id == "boom! "
</span><span>
</span><span>boom2C </span><span style=color:#f92672>= do
</span><span>    n </span><span style=color:#f92672>&LT-</span><span> cont </span><span style=color:#f92672>$ \</span><span>out </span><span style=color:#f92672>-></span><span> out </span><span style=color:#e6db74>"1" </span><span style=color:#f92672>++</span><span> out </span><span style=color:#e6db74>"2"
</span><span>    l </span><span style=color:#f92672>&LT-</span><span> cont </span><span style=color:#f92672>$ \</span><span>out </span><span style=color:#f92672>-> </span><span style=color:#e6db74>"boom! "
</span><span>    x </span><span style=color:#f92672>&LT-</span><span> cont </span><span style=color:#f92672>$ \</span><span>out </span><span style=color:#f92672>-></span><span> out </span><span style=color:#e6db74>"X" </span><span style=color:#f92672>++</span><span> out </span><span style=color:#e6db74>"Y"
</span><span>    return </span><span style=color:#f92672>$</span><span> n</span><span style=color:#f92672>++</span><span>l</span><span style=color:#f92672>++</span><span>x</span><span style=color:#f92672>++</span><span style=color:#e6db74>" "
</span><span>
</span><span style=color:#75715e>-- here, our we call out twice, each one hitting the second continuation and
</span><span style=color:#75715e>-- exiting with boom, so we get two of them appended because out "1" and out "2" are:
</span><span style=color:#75715e>-- runCont boom2C id == "boom! boom! "
</span><span>
</span><span>boom3C </span><span style=color:#f92672>= do
</span><span>    n </span><span style=color:#f92672>&LT-</span><span> cont </span><span style=color:#f92672>$ \</span><span>out </span><span style=color:#f92672>-></span><span> out </span><span style=color:#e6db74>"1" </span><span style=color:#f92672>++</span><span> out </span><span style=color:#e6db74>"2"
</span><span>    l </span><span style=color:#f92672>&LT-</span><span> cont </span><span style=color:#f92672>$ \</span><span>out </span><span style=color:#f92672>-></span><span> out </span><span style=color:#e6db74>"a" </span><span style=color:#f92672>++</span><span> out </span><span style=color:#e6db74>"b"
</span><span>    x </span><span style=color:#f92672>&LT-</span><span> cont </span><span style=color:#f92672>$ \</span><span>out </span><span style=color:#f92672>-> </span><span style=color:#e6db74>"boom! "
</span><span>    return </span><span style=color:#f92672>$</span><span> n</span><span style=color:#f92672>++</span><span>l</span><span style=color:#f92672>++</span><span>x</span><span style=color:#f92672>++</span><span style=color:#e6db74>" "
</span><span>
</span><span style=color:#75715e>-- each contnuation calls its callback twice, so we end up hitting boom 4 times:
</span><span style=color:#75715e>-- runCont boom3C id == "boom! boom! boom! boom! "
</span></code></pre><h1 id=what-about-callcc>What about <code>callCC</code>?</h1><p><code>callCC</code> takes a function as an argument, and expects it to return a continuation. It passes the function an exit callback which, when called, returns a continuation that ignores its own callback and just returns a value to the outer continuation, breaking the inner continuation chain.<p>Essentially, callCC gives you a named escape hatch that you can use at any point to break free of the current continuation chain and immediately return a value.<p>These all return True, and never hit undefined (which would result in a runtime error):<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>callCCex1 </span><span style=color:#f92672>= do
</span><span>    val </span><span style=color:#f92672>&LT-</span><span> callCC </span><span style=color:#f92672>$ \</span><span>exit </span><span style=color:#f92672>-> do
</span><span>
</span><span>        exit </span><span style=color:#ae81ff>True
</span><span>        undefined
</span><span>
</span><span>    return val
</span><span>
</span><span style=color:#75715e>-- by unraveling callCC (flip for aesthetics) you can see it could be written as:
</span><span>callCCex2 </span><span style=color:#f92672>= do
</span><span>
</span><span>    val </span><span style=color:#f92672>&LT-</span><span> cont </span><span style=color:#f92672>$ \</span><span>out </span><span style=color:#f92672>-></span><span> flip runCont out </span><span style=color:#f92672>$ do
</span><span>
</span><span>        cont </span><span style=color:#f92672>$ \</span><span>_ </span><span style=color:#f92672>-></span><span> out </span><span style=color:#ae81ff>True
</span><span>        undefined
</span><span>
</span><span>    return val
</span><span>
</span><span style=color:#75715e>-- or in this simple case just by exiting the inner continuation early as we have
</span><span style=color:#75715e>-- done in previous examples
</span><span>callCCex3 </span><span style=color:#f92672>= do
</span><span>
</span><span>    val </span><span style=color:#f92672>&LT- do
</span><span>
</span><span>        cont </span><span style=color:#f92672>$ \</span><span>_ </span><span style=color:#f92672>-> </span><span style=color:#ae81ff>True
</span><span>        undefined
</span><span>
</span><span>    return val
</span></code></pre><p>By giving you an explicit callback to use to exit the continuation, <code>callCC</code> has the added advantage that you can nest uses of callCC and exit from any depth to any other with ease:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>callCCex4 </span><span style=color:#f92672>= do
</span><span>    val </span><span style=color:#f92672>&LT-</span><span> callCC </span><span style=color:#f92672>$ \</span><span>exit </span><span style=color:#f92672>-> do
</span><span>
</span><span>        innerval </span><span style=color:#f92672>&LT-</span><span> callCC </span><span style=color:#f92672>$ \</span><span>innerExit </span><span style=color:#f92672>-> do
</span><span>
</span><span>            exit </span><span style=color:#ae81ff>True
</span><span>            undefined
</span><span>
</span><span>        undefined
</span><span>
</span><span>    return val
</span></code></pre><p>Note that other structures can emulate breaking free of the control flow but none escape immediately as this does. For instance, the <code>Maybe</code> Monad ignores everything once it receives a <code>Nothing</code> value, but still runs though everything else in the chain (though that could well be optimised away in some cases).<h1 id=what-else-can-we-do-with-continuations>What else can we do with Continuations?</h1><p>Here are some samples of what one can create with continuations. You are encouraged to have a play with them yourself however and see what else you can create.<h2 id=1-a-for-loop-that-can-be-broken-out-of>1. A for loop that can be broken out of</h2><p>Many imperative languages have for loops that can be broken out of early if desired. Continuations are one way to do the same in Haskell:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>import qualified </span><span>Control.Monad.Trans.Cont  </span><span style=color:#f92672>as </span><span>C
</span><span style=color:#f92672>import           </span><span>Control.Monad.Trans.Class (</span><span style=color:#a6e22e>lift</span><span>)
</span><span>
</span><span style=color:#a6e22e>forLoop </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Monad </span><span>m </span><span style=color:#f92672>=></span><span> [a] </span><span style=color:#f92672>-></span><span> (a </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>C</span><span>.</span><span style=font-style:italic;color:#66d9ef>ContT </span><span style=color:#66d9ef>() </span><span>m c) </span><span style=color:#f92672>-> </span><span>m </span><span style=color:#66d9ef>()
</span><span>forLoop items fn </span><span style=color:#f92672>=
</span><span>    </span><span style=color:#f92672>let</span><span> contArr </span><span style=color:#f92672>=</span><span> fmap fn items
</span><span>    </span><span style=color:#f92672>in </span><span style=color:#ae81ff>C</span><span style=color:#f92672>.</span><span>runContT (sequence_ contArr) return
</span><span>
</span><span style=color:#a6e22e>breakOut </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Monad </span><span>m </span><span style=color:#f92672>=> </span><span style=font-style:italic;color:#66d9ef>C</span><span>.</span><span style=font-style:italic;color:#66d9ef>ContT </span><span style=color:#66d9ef>() </span><span>m c
</span><span>breakOut </span><span style=color:#f92672>= </span><span style=color:#ae81ff>C</span><span style=color:#f92672>.</span><span style=color:#ae81ff>ContT </span><span style=color:#f92672>$ \</span><span>_ </span><span style=color:#f92672>-></span><span> return </span><span style=color:#ae81ff>()
</span><span>
</span><span style=color:#a6e22e>breakOutIf </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Monad </span><span>m </span><span style=color:#f92672>=> </span><span style=font-style:italic;color:#66d9ef>Bool </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>C</span><span>.</span><span style=font-style:italic;color:#66d9ef>ContT </span><span style=color:#66d9ef>() </span><span>m </span><span style=color:#66d9ef>()
</span><span>breakOutIf b </span><span style=color:#f92672>= if</span><span> b </span><span style=color:#f92672>then </span><span style=color:#ae81ff>C</span><span style=color:#f92672>.</span><span style=color:#ae81ff>ContT </span><span style=color:#f92672>$ \</span><span>_ </span><span style=color:#f92672>-></span><span> return </span><span style=color:#ae81ff>() </span><span style=color:#f92672>else</span><span> return </span><span style=color:#ae81ff>()
</span></code></pre><p>Here's the loop in action. To test breaking out, its given an infinite array but breaks out safely after 10 iterations.<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>infiniteLoop </span><span style=color:#f92672>=</span><span> forLoop [</span><span style=color:#ae81ff>1</span><span style=color:#f92672>..</span><span>] </span><span style=color:#f92672>$ \</span><span>i </span><span style=color:#f92672>-> do
</span><span>    </span><span style=color:#f92672>if</span><span> i </span><span style=color:#f92672>> </span><span style=color:#ae81ff>10
</span><span>        </span><span style=color:#f92672>then</span><span> breakOut
</span><span>        </span><span style=color:#f92672>else</span><span> lift </span><span style=color:#f92672>$</span><span> putStrLn </span><span style=color:#f92672>$</span><span> show i
</span><span>
</span><span>infiniteLoop2 </span><span style=color:#f92672>=</span><span> forLoop [</span><span style=color:#ae81ff>1</span><span style=color:#f92672>..</span><span>] </span><span style=color:#f92672>$ \</span><span>i </span><span style=color:#f92672>-> do
</span><span>    breakOutIf (i </span><span style=color:#f92672>> </span><span style=color:#ae81ff>10</span><span>)
</span><span>    lift </span><span style=color:#f92672>$</span><span> putStrLn </span><span style=color:#f92672>$</span><span> show i
</span></code></pre><h2 id=2-goto>2. <code>goto</code></h2><p>This one is generally discouraged in most languages, but just for fun here it is:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>{-# </span><span style=color:#f92672>LANGUAGE</span><span> ScopedTypeVariables #-}
</span><span>
</span><span style=color:#f92672>import qualified </span><span>Control.Monad.Trans.Cont  </span><span style=color:#f92672>as </span><span>C
</span><span style=color:#f92672>import           </span><span>Control.Monad.Trans.Class (</span><span style=color:#a6e22e>lift</span><span>)
</span><span style=color:#f92672>import           </span><span>System.Random             </span><span style=color:#f92672>as </span><span>R
</span><span>
</span><span style=color:#75715e>--simple goto
</span><span>goto </span><span style=color:#f92672>= </span><span style=color:#ae81ff>C</span><span style=color:#f92672>.</span><span>callCC </span><span style=color:#f92672>$ \</span><span>out </span><span style=color:#f92672>-> let</span><span> fn </span><span style=color:#f92672>=</span><span> out fn
</span><span>                          </span><span style=color:#f92672>in</span><span> return fn
</span><span>
</span><span style=color:#75715e>-- we can also provide back other arguments, in this
</span><span style=color:#75715e>-- case some number, to allow more intelligent looping:
</span><span>gotoC </span><span style=color:#f92672>= </span><span style=color:#ae81ff>C</span><span style=color:#f92672>.</span><span>callCC </span><span style=color:#f92672>$ \</span><span>out </span><span style=color:#f92672>-> let</span><span> fn num </span><span style=color:#f92672>=</span><span> out (fn, num)
</span><span>                           </span><span style=color:#f92672>in</span><span> return (fn, </span><span style=color:#ae81ff>0</span><span>)
</span></code></pre><p>Our <code>goto</code>s in action:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- based on the output of a random number generator,
</span><span style=color:#75715e>-- we either go back to marker1, marker2, or finish
</span><span>gotoEx1 </span><span style=color:#f92672>=</span><span> flip </span><span style=color:#ae81ff>C</span><span style=color:#f92672>.</span><span>runContT return </span><span style=color:#f92672>$ do
</span><span>
</span><span>    marker1 </span><span style=color:#f92672>&LT-</span><span> goto
</span><span>    lift </span><span style=color:#f92672>$</span><span> putStrLn </span><span style=color:#e6db74>"one"
</span><span>
</span><span>    marker2 </span><span style=color:#f92672>&LT-</span><span> goto
</span><span>    lift </span><span style=color:#f92672>$</span><span> putStrLn </span><span style=color:#e6db74>"two"
</span><span>
</span><span>    (num </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>Int</span><span>) </span><span style=color:#f92672>&LT-</span><span> lift </span><span style=color:#f92672>$ </span><span style=color:#ae81ff>R</span><span style=color:#f92672>.</span><span>randomRIO (</span><span style=color:#ae81ff>0</span><span>,</span><span style=color:#ae81ff>2</span><span>)
</span><span>
</span><span>    </span><span style=color:#f92672>if</span><span> num </span><span style=color:#f92672>< </span><span style=color:#ae81ff>1 </span><span style=color:#f92672>then</span><span> marker1
</span><span>    </span><span style=color:#f92672>else if</span><span> num </span><span style=color:#f92672>< </span><span style=color:#ae81ff>2 </span><span style=color:#f92672>then</span><span> marker2
</span><span>    </span><span style=color:#f92672>else</span><span> lift </span><span style=color:#f92672>$</span><span> putStrLn </span><span style=color:#e6db74>"done"
</span><span>
</span><span style=color:#75715e>-- loop back some number of times before continuing on:
</span><span>gotoEx2 </span><span style=color:#f92672>=</span><span> flip </span><span style=color:#ae81ff>C</span><span style=color:#f92672>.</span><span>runContT return </span><span style=color:#f92672>$ do
</span><span>
</span><span>    (marker1,num) </span><span style=color:#f92672>&LT-</span><span> gotoC
</span><span>    lift </span><span style=color:#f92672>$</span><span> putStrLn (</span><span style=color:#e6db74>"count: "</span><span style=color:#f92672>++</span><span>show num)
</span><span>
</span><span>    </span><span style=color:#f92672>if</span><span> num </span><span style=color:#f92672>< </span><span style=color:#ae81ff>10 </span><span style=color:#f92672>then</span><span> marker1 (num</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span><span>)
</span><span>    </span><span style=color:#f92672>else</span><span> lift </span><span style=color:#f92672>$</span><span> putStrLn </span><span style=color:#e6db74>"done"
</span></code></pre><h2 id=3-the-list-monad>3. The List Monad</h2><p>We came quite close to this earlier when playing with multiple callback invocations.<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- we use (:[]) to make the output of running any callback
</span><span style=color:#75715e>-- an array, to ensure we can concatenate results at each stage.
</span><span>makeList </span><span style=color:#f92672>=</span><span> flip runCont (</span><span style=color:#f92672>:</span><span style=color:#ae81ff>[]</span><span>)
</span><span>each arr </span><span style=color:#f92672>=</span><span> cont </span><span style=color:#f92672>$ \</span><span>out </span><span style=color:#f92672>-></span><span> mconcat </span><span style=color:#f92672>$</span><span> fmap out arr
</span><span>
</span><span style=color:#75715e>-- break out of the continuation if some Bool is true by
</span><span style=color:#75715e>-- immediately returning an empty array which equates
</span><span style=color:#75715e>-- to nothing when our arrays are concatenated
</span><span>ignoreIf b </span><span style=color:#f92672>=</span><span> cont </span><span style=color:#f92672>$ \</span><span>out </span><span style=color:#f92672>-> if</span><span> b </span><span style=color:#f92672>then </span><span style=color:#ae81ff>[] </span><span style=color:#f92672>else</span><span> out </span><span style=color:#ae81ff>()
</span></code></pre><p>Now we've defined a couple of helpers, here it is in action:<pre style=background:#272822;color:#f8f8f2><code><span>eachEx1 :: [(Int,Int,Int)]
</span><span>eachEx1 = makeList $ do
</span><span>    n1 &LT- each [1,2,3]
</span><span>    n2 &LT- each [4,5,6]
</span><span>    n3 &LT- each [7,8,9]
</span><span>    ignoreIf (n3 == 8) --ignore any combinations where n3 is 8
</span><span>    return (n1,n2,n3)
</span><span>
</span><span>-- outputs:
</span><span>-- [(1,4,7),(1,4,9),(1,5,7),(1,5,9),(1,6,7),(1,6,9),(2,4,7),(2,4,9),(2,5,7),(2,5,9),(2,6,7),(2,6,9),(3,4,7),(3,4,9),(3,5,7),(3,5,9),(3,6,7),(3,6,9)]
</span></code></pre><h1 id=summary>Summary</h1><p>Continuations are a powerful tool that are quite mind bending on first encounter. Their main applications seem to be, manipulating control flow, combinatory work and early escaping. The latter has been used to generate more efficient versions of existing monads. With great power comes great responsibility though, and in many cases using Continuations may not be worth the added mental complexity over other simpler approaches.<p>Most of this code (and a couple of extra bits) is wrapped up into a file right <a href=https://jsdw.me/posts/haskell-cont-monad/examples.hs>here</a> ready to be plugged into GHCI. Have a play and let me know what you think!</div></div></section><footer></footer></div><script src=https://jsdw.me/page.js></script>