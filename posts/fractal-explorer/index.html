<!doctype html><html><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><title>
    jsdw - Web App: Fractal Explorer
</title><link href="https://fonts.googleapis.com/css?family=IBM+Plex+Serif|Open+Sans" rel=stylesheet><link href=https://jsdw.me/app.css rel=stylesheet><link href=https://jsdw.me/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><link href=https://jsdw.me/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=https://jsdw.me/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=https://jsdw.me/site.webmanifest rel=manifest><link color=#5bbad5 href=https://jsdw.me/safari-pinned-tab.svg rel=mask-icon><meta content=#f9409c name=msapplication-TileColor><meta content=#ffffff name=theme-color><body><div class="body post"><header><div class=title-inner><div class=jsdw><a href=https://jsdw.me>JSDW</a></div><nav><a href=https://jsdw.me/posts/>posts</a><a href=https://jsdw.me/projects/>projects</a></nav></div></header><section><div class=top><div class=top-scene><svg class="polygon two" viewbox="0 0 100 100" height=100% style=fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421 version=1.1 width=100% xml:space=preserve xmlns=http://www.w3.org/2000/svg xmlns:serif=http://www.serif.com/ xmlns:xlink=http://www.w3.org/1999/xlink><polygon points="0 100, 15 40, 60 0, 100 30"/></svg><svg class="polygon one" viewbox="0 0 100 100" height=100% style=fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421 version=1.1 width=100% xml:space=preserve xmlns=http://www.w3.org/2000/svg xmlns:serif=http://www.serif.com/ xmlns:xlink=http://www.w3.org/1999/xlink><polygon points="0 40, 30 0, 80 33, 100 100"/></svg></div><div class=top-inner><h1 class=title>Web App: Fractal Explorer <span class=date>2013-05-15</span></h1></div></div><div class=content-inner><div class=post><p>After completing my <a href=http://jsdw.github.io/js-competitive-learning-simulator/>competitive learning application</a>, I was eager to see quite what Javascript was actually capable of. At the same time, I knew vaguely what fractals were - but never much more - and I was keen to learn a little more about them. This post summarizes what a fractal is (specifically relating to the Mandelbrot set), and then describes my fractal explorer web application, which you can have a play with <a href=https://jsdw.github.io/js-fractal-explorer/>right here</a>.<p><img alt="An image of my Fractal Explorer in action" src=https://jsdw.me/posts/fractal-explorer/explorer.png><h1 id=introduction>Introduction</h1><p>Google defines a fractal as:<blockquote><p>A curve or geometric figure, each part of which has the same statistical character as the whole.</blockquote><p>So, a fractal is typically formed by applying some iterative algorithm to an initial (often mathematically generated) state, and displaying the results graphically somehow. As a result, it is typical that similar patterns can be seen across different parts of the image, and often across different magnifications.<p>One of the most famous fractals is created by visualising the <a href=http://en.wikipedia.org/wiki/Mandelbrot_set>Mandelbrot Set</a>. The mandelbrot set is generated by iteratively applying the simple looking equation <em>z = z<sup>2</sup> + c</em>, where both <em>z</em> and <em>c</em> are complex numbers. Complex numbers are numbers that are made out of two parts - a real and an imaginary part - for example <em>4 + 5i</em>. The maths used to work with imaginary numbers is not too complex, and is based around the fact that <em>i<sup>2</sup> = -1</em>, or conversely, the square root of <em>-1</em> is <em>i</em>. A quick google will bring up some great tutorials on imaginary numbers for more information.<p><img alt="A visualization of the Mandelbrot set, using my fractal explorer" src=https://jsdw.me/posts/fractal-explorer/mandelbrot.png><h1 id=visualizing-the-mandelbrot-set>Visualizing the Mandelbrot set</h1><p>To visualise the Mandelbrot set, we map the complex number <em>c</em> onto a grid of pixels, whereby the real part of <em>c</em> corresponds to the <em>x</em> coordinate, and the imaginary part corresponds to the <em>y</em> coordinate (for example, <em>0.2+0.5i</em> would correspond to the coordinates [0.2,0.5]). Next, we iteratively apply the equation <em>z = z<sup>2</sup> + c</em> for every set of coordinates <em>c</em> pertaining to a pixel we wish to colour in. <em>z</em> is set initially to <em>0+0i</em>.<p>Treating the output <em>z</em> as a set of coordinates too, we count the number of iterations taken for <em>z</em> to become further than a (Euclidean) distance of 2 away from the origin (0,0). That is, if you draw a circle around the origin (0,0) with a radius of 2, we stop counting the number of iterations once the value of <em>z</em> leaves this circle. If <em>z</em> does not leave the circle after some pre-set maximum number of iterations (for example, 400), we stop iterating, and set the number of iterations to whatever this maximum value is. Next, we select a colour based on the number of iterations counted. For example, if the maximum number of iterations allowed is 400, we could colour pixels such that the greater the number of iterations taken to leave the circle, the darker a given point becomes.<p>One thing worth noting here is that colouring by counting iterations leads to discrete bands of colour in the fractal. To combat this myself, I pulled in an equation I found lying in a forum somewhere, but I can't claim to know exactly how it works or remember specifically where from!<p>The exact code I used to calculate the value for each pixel was the following (where capital letters are in place of variables references elsewhere):<pre class=language-javascript data-lang=javascript style=background:#272822;color:#f8f8f2><code class=language-javascript data-lang=javascript><span style=font-style:italic;color:#66d9ef>function </span><span style=color:#a6e22e>mandelbrotGeneral</span><span>(</span><span style=font-style:italic;color:#fd971f>x</span><span>, </span><span style=font-style:italic;color:#fd971f>y</span><span>, </span><span style=font-style:italic;color:#fd971f>c1</span><span>, </span><span style=font-style:italic;color:#fd971f>c2</span><span>) {
</span><span>	</span><span style=font-style:italic;color:#66d9ef>var </span><span>x2 </span><span style=color:#f92672>= </span><span>x </span><span style=color:#f92672>* </span><span>x, y2 </span><span style=color:#f92672>= </span><span>y </span><span style=color:#f92672>* </span><span>y;
</span><span>	</span><span style=font-style:italic;color:#66d9ef>var </span><span>i </span><span style=color:#f92672>= </span><span style=color:#ae81ff>0</span><span>;
</span><span>	</span><span style=color:#f92672>while</span><span>(i </span><span style=color:#f92672>< </span><span>MAX_ITERATIONS </span><span style=color:#f92672>&& </span><span>x2</span><span style=color:#f92672>+</span><span>y2 </span><span style=color:#f92672>< </span><span>ER_SQUARED) {
</span><span>		y </span><span style=color:#f92672>= </span><span style=color:#ae81ff>2 </span><span style=color:#f92672>* </span><span>x </span><span style=color:#f92672>* </span><span>y </span><span style=color:#f92672>+ </span><span>c2;
</span><span>		x </span><span style=color:#f92672>= </span><span>x2 </span><span style=color:#f92672>- </span><span>y2 </span><span style=color:#f92672>+ </span><span>c1;
</span><span>		y2 </span><span style=color:#f92672>= </span><span>y </span><span style=color:#f92672>* </span><span>y;
</span><span>		x2 </span><span style=color:#f92672>= </span><span>x </span><span style=color:#f92672>* </span><span>x;
</span><span>		i</span><span style=color:#f92672>++</span><span>;
</span><span>	}
</span><span>
</span><span>	</span><span style=color:#75715e>//this bit just smooths the colour value out:
</span><span>	</span><span style=color:#f92672>if</span><span>(NO_SMOOTHING </span><span style=color:#f92672>== </span><span style=color:#ae81ff>true</span><span>) {
</span><span>		</span><span style=color:#f92672>return </span><span>i;
</span><span>	} </span><span style=color:#f92672>else </span><span>{
</span><span>		</span><span style=font-style:italic;color:#66d9ef>var </span><span>p </span><span style=color:#f92672>= </span><span style=color:#a6e22e>mathLog</span><span>(</span><span style=color:#66d9ef>Math</span><span>.</span><span style=color:#66d9ef>abs</span><span>(x2</span><span style=color:#f92672>+</span><span>y2),</span><span style=color:#ae81ff>2</span><span>)</span><span style=color:#f92672>/</span><span style=color:#a6e22e>mathLog</span><span>(ER_SQUARED,</span><span style=color:#ae81ff>2</span><span>);
</span><span>		</span><span style=font-style:italic;color:#66d9ef>var </span><span>frac </span><span style=color:#f92672>= </span><span style=color:#a6e22e>mathLog</span><span>(p);
</span><span>		</span><span style=color:#f92672>if</span><span>(</span><span style=color:#66d9ef>isNaN</span><span>(frac)) </span><span style=color:#f92672>return </span><span>i;
</span><span>		</span><span style=color:#f92672>else return </span><span>i </span><span style=color:#f92672>- </span><span>frac;
</span><span>	}
</span><span>}
</span><span>
</span><span style=font-style:italic;color:#66d9ef>function </span><span style=color:#a6e22e>mandelbrot</span><span>(</span><span style=font-style:italic;color:#fd971f>args</span><span>) {
</span><span>	</span><span style=color:#f92672>return </span><span style=color:#a6e22e>mandelbrotGeneral</span><span>(C1, C2, args[</span><span style=color:#ae81ff>0</span><span>], args[</span><span style=color:#ae81ff>1</span><span>]);
</span><span>}
</span><span>
</span><span style=font-style:italic;color:#66d9ef>function </span><span style=color:#a6e22e>julia</span><span>(</span><span style=font-style:italic;color:#fd971f>args</span><span>) {
</span><span>	</span><span style=color:#f92672>return </span><span style=color:#a6e22e>mandelbrotGeneral</span><span>(args[</span><span style=color:#ae81ff>0</span><span>], args[</span><span style=color:#ae81ff>1</span><span>], C1, C2);
</span><span>}
</span></code></pre><p>The top part of <code>mandelbrotGeneral</code> carries out the formula <em>z = z<sub>2</sub> + c</em> iteratively, where <code>x</code> and <code>y</code> are in fact the real and imaginary parts of <em>c</em>, and <code>c1</code> and <code>c2</code> are the real and imaginary parts of <em>z</em>. The iteration stops once the value exceeds <code>ER_SQUARED</code>, which is just the square of the escape radius (4 is a sensible value for this), and the number of iterations taken is smoothed (if <code>NO_SMOOTHING</code> is true) and returned. The functions <code>mandelbrot</code> and <code>julia</code> both take in an array of x and y coordinates, and pass these in place of either the <em>z</em> or <em>c</em> values to <code>mandelbrotGeneral</code>. So, by passing in the coordinates corresponding to each pixel we want to colour in, we get back a value between 0 and whatever <code>MAX_ITERATIONS</code> is set too, and can map this value to a colour.<p>The smoothing part of the function uses a slightly modified version of <code>Math.log</code>, which can optionally take in a base as its second argument. The function is shown below:<pre class=language-javascript data-lang=javascript style=background:#272822;color:#f8f8f2><code class=language-javascript data-lang=javascript><span style=font-style:italic;color:#66d9ef>function </span><span style=color:#a6e22e>mathLog</span><span>(</span><span style=font-style:italic;color:#fd971f>val</span><span>, </span><span style=font-style:italic;color:#fd971f>base</span><span>) {
</span><span>	</span><span style=color:#f92672>if</span><span>(</span><span style=color:#f92672>typeof </span><span>base </span><span style=color:#f92672>== </span><span style=color:#e6db74>"undefined"</span><span>) {
</span><span>		</span><span style=color:#f92672>return </span><span style=color:#66d9ef>Math</span><span>.</span><span style=color:#66d9ef>log</span><span>(val);
</span><span>	} </span><span style=color:#f92672>else </span><span>{
</span><span>		</span><span style=color:#f92672>return </span><span style=color:#66d9ef>Math</span><span>.</span><span style=color:#66d9ef>log</span><span>(val)</span><span style=color:#f92672>/</span><span style=color:#66d9ef>Math</span><span>.</span><span style=color:#66d9ef>log</span><span>(base);
</span><span>	}
</span><span>}
</span></code></pre><p>One of the fun things about fractals is the ability to endlessly zoom in to them. If you understood the last paragraph, it may now be quite obvious how this is done. Essentially, to draw the Mandelbrot fractal (among others) in the first place, you must map coordinates on a grid between say, (-2,-1) to (2,1) onto a 2 dimensional array of pixels. to Zoom in then, we simply change this mapping such that a smaller range of coordinates is mapped onto the same array of pixels. We can repeat this process to zoom in as far as possible, restricted only by the precision of the numbers used.<p><img alt="Zooming in on the Mandelbrot set" src=https://jsdw.me/posts/fractal-explorer/mandelbrot-zoom.png><h1 id=the-julia-set>The Julia set</h1><p>The Julia set is closely related to the Mandelbrot set. Essentially, the same equation is used, except that instead of using the complex number <em>c</em> as the coordinates of pixels to colour, we set the starting value of <em>z</em> to the coordinates of each pixel. Now, the value of <em>c</em> can be changed to produce various fractal patterns (which involves setting two constants actually; the real and imaginary part of <em>c</em>). This can be seen in the above code; the same equation is used, but the arguments are simply swapped around. The rest works the same, whereby we iteratively apply the formula with the previous value of <em>z</em>, until the value given lies outside a radius of 2 from (0,0), and then colour pixels based on the number of iterations taken to do this.<p><img alt="A fractal taken from the Julia set" src=https://jsdw.me/posts/fractal-explorer/julia.png><h1 id=my-fractal-explorer>My Fractal Explorer</h1><p>So, after having learned the above, I set about creating the fractal explorer which you can see <a href=https://jsdw.github.io/js-fractal-explorer/>here</a>. Some of the features of my Fractal Explorer application are as follows:<ul><li>Ability to explore both Mandelbrot and Julia set fractals.<li>Ability to modify the value of <em>z</em> (for the Mandelbrot set) or <em>c</em> (for the Julia set).<li>Zooming and panning as much as the precision of Javascript floats allows.<li>Multiple threads supported using Web Workers.<li>Fractals can be rendered at different quality levels (essentially a form of anti-aliasing).<li>Fractal images can be generated and saved at custom resolutions and aspect ratios.<li>Complete control over the colours used in rendering fractals (colour picker code written by David Durman).<li>Ability to change the maximum iteration count, for increased detail in some areas.<li>Ability to save and shorten the saved link to get back to your fractal or share it with others.</ul><p>Fractals are rendered over 2 passes using alternate lines so that you can see what you're looking at sooner and zoom or pan before it completes. Web workers essentially split the image into segments and apply this process to each segment instead, if you have the number of threads set to more than 0 in the dropdown options. Tests reveal multiple threads to be significantly faster, notably at higher quality settings, however there is some overhead in transmitting the relevant data back and forth between threads which can lead to worse performance in some cases (for example on single core machines or using only one thread).<p>Colours are assigned by taking the smoothed number of iterations taken for each pixel's coordinates to exceed the radius, and mapping that to a user defined gradient which is constructed from a series of colours at some set points, and a smooth transition from one colour to the next between these points. As a result, changing the colour scheme of the fractal is computationally easy compared to recalculating the fractal itself.<p>The available quality settings are created by essentially sampling the square of that quality value's number of regions within each pixel, and averaging out the values. So, for a quality of 1, the value is calculated for only the centre-point of each pixel, and so in reality, the colour is based on what is in the centre of that pixel only. A quality level of 3 on the other hand splits each pixel into a 3 by 3 grid of sub-regions, and calculates the value for the centre-points of all of these, averaging out the result (and making it 9 times slower). This leads to significantly smoother transitions between pixels, as the resulting value is more representative of the pixel as a whole.<p>Finally, saving images works by essentially running the fractal generator on a hidden canvas of the desired size and with the relevant settings (position, zoom etc), and then outputting the result of that canvas as an on screen image. I found this less likely to lead to memory issues than providing a direct download link, although large images will still be problematic. To shorten links (which are read in as the page is loaded to calibrate the settings accordingly), I simply make a call to Google's link shortening service and output the result.<p>So, I think that about sums that up. Have a play with it <a href=https://jsdw.github.io/js-fractal-explorer/>here</a> if you haven't already. If you have any questions or comments, please feel free to leave them below, and I'll get back to you when I can!<p><img alt="Playing with colours" src=https://jsdw.me/posts/fractal-explorer/red.png></div></div></section><footer></footer></div><script src=https://jsdw.me/page.js></script>