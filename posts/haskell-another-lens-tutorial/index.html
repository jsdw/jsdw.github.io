<!doctype html><html><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><title>
    jsdw - Haskell: Another Lens Tutorial
</title><link href="https://fonts.googleapis.com/css?family=IBM+Plex+Serif|Open+Sans" rel=stylesheet><link href=https://jsdw.me/app.css rel=stylesheet><link href=https://jsdw.me/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><link href=https://jsdw.me/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=https://jsdw.me/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=https://jsdw.me/site.webmanifest rel=manifest><link color=#5bbad5 href=https://jsdw.me/safari-pinned-tab.svg rel=mask-icon><meta content=#f9409c name=msapplication-TileColor><meta content=#ffffff name=theme-color><body><div class="body post"><header><div class=title-inner><div class=jsdw><a href=https://jsdw.me>JSDW</a></div><nav><a href=https://jsdw.me/posts/>posts</a><a href=https://jsdw.me/projects/>projects</a></nav></div></header><section><div class=top><div class=top-scene><svg class="polygon two" viewbox="0 0 100 100" height=100% style=fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421 version=1.1 width=100% xml:space=preserve xmlns=http://www.w3.org/2000/svg xmlns:serif=http://www.serif.com/ xmlns:xlink=http://www.w3.org/1999/xlink><polygon points="0 100, 15 40, 60 0, 100 30"/></svg><svg class="polygon one" viewbox="0 0 100 100" height=100% style=fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421 version=1.1 width=100% xml:space=preserve xmlns=http://www.w3.org/2000/svg xmlns:serif=http://www.serif.com/ xmlns:xlink=http://www.w3.org/1999/xlink><polygon points="0 40, 30 0, 80 33, 100 100"/></svg></div><div class=top-inner><h1 class=title>Haskell: Another Lens Tutorial <span class=date>2014-08-29</span></h1></div></div><div class=content-inner><div class=post><p>I recently stumbled across the <code>lens</code> package when I was working with JSON data. I was keen to start working with lenses more, but without really knowing what they were, at least at some level, I was hesitant. I spent the next few days on and off reading about lenses and trying to make sense of them. For me, the turning point was <a href=http://blog.jakubarnold.cz/2014/07/14/lens-tutorial-introduction-part-1.html>this post</a> by Jakob Arnold, so I very much encourage reading that as well. Anyway, let's get on with it. All of the code used in the examples is available in a single file <a href=https://jsdw.me/posts/haskell-another-lens-tutorial/code.hs>here</a>, ready to be loaded into ghci with a <code>ghci code.hs</code> command, so that you can easily follow along.<h1 id=what-s-so-good-about-lenses-anyway>What's so good about lenses anyway?</h1><p>In most imperative languages, data is mutable, and so you are provided with a nice syntax to update fields in data structures. Take the Javascript below:<pre class=language-js data-lang=js style=background:#272822;color:#f8f8f2><code class=language-js data-lang=js><span style=color:#75715e>//we have a "person":
</span><span style=font-style:italic;color:#66d9ef>var </span><span>person </span><span style=color:#f92672>= </span><span>{
</span><span>	name: </span><span style=color:#e6db74>"James"</span><span>,
</span><span>	age: </span><span style=color:#ae81ff>28</span><span>,
</span><span>	address: {
</span><span>		house: </span><span style=color:#ae81ff>42</span><span>,
</span><span>		street: </span><span style=color:#e6db74>"Some Road"</span><span>,
</span><span>		city: </span><span style=color:#e6db74>"London"
</span><span>	}
</span><span>};
</span><span>
</span><span style=color:#75715e>//it's simple to view his house number, or update it:
</span><span style=font-style:italic;color:#66d9ef>var </span><span>houseNumber </span><span style=color:#f92672>= </span><span>person.address.house;
</span><span>person.address.house </span><span style=color:#f92672>= </span><span style=color:#ae81ff>29</span><span>;
</span></code></pre><p>Haskell on the other hand doesn't allow you to mutate data like this. Instead, if you want to update a value you make a copy of the whole lot with the single value of interest changed. The Haskell equivalent to the above is something like:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- define our person and address data structures:
</span><span style=color:#f92672>data </span><span style=color:#ae81ff>Person </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Person</span><span> {
</span><span>	</span><span style=color:#a6e22e>name </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>String</span><span>,
</span><span>	</span><span style=color:#a6e22e>age </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Int</span><span>,
</span><span>	</span><span style=color:#a6e22e>address </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Address
</span><span>}
</span><span>
</span><span style=color:#f92672>data </span><span style=color:#ae81ff>Address </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Address</span><span> {
</span><span>	</span><span style=color:#a6e22e>house </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Int</span><span>,
</span><span>	</span><span style=color:#a6e22e>street </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>String</span><span>,
</span><span>	</span><span style=color:#a6e22e>city </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>String
</span><span>}
</span><span>
</span><span style=color:#75715e>-- make a new person:
</span><span>james </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Person</span><span> {
</span><span>	name </span><span style=color:#f92672>= </span><span style=color:#e6db74>"James"</span><span>,
</span><span>	age </span><span style=color:#f92672>= </span><span style=color:#ae81ff>28</span><span>,
</span><span>	address </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Address</span><span> {
</span><span>		house </span><span style=color:#f92672>= </span><span style=color:#ae81ff>42</span><span>,
</span><span>		street </span><span style=color:#f92672>= </span><span style=color:#e6db74>"Some Road"</span><span>,
</span><span>		city </span><span style=color:#f92672>= </span><span style=color:#e6db74>"London"
</span><span>	}
</span><span>}
</span><span>
</span><span style=color:#75715e>-- get his house number by first getting the address from james,
</span><span style=color:#75715e>-- and then getting the house number from address:
</span><span>houseNumber </span><span style=color:#f92672>=</span><span> house (address james)
</span><span>
</span><span style=color:#75715e>-- set his house number (creating a new person in the process):
</span><span>updatedJames </span><span style=color:#f92672>=</span><span> james { address </span><span style=color:#f92672>=</span><span> (address james) { house </span><span style=color:#f92672>= </span><span style=color:#ae81ff>43</span><span> } }
</span></code></pre><p>First, we had to create some data types, which although more verbose give us nice compile time guarantees that we won't ever set a house number to a <code>String</code> or something. Next, we use the accessor functions defined along with the record syntax to get at the address, and then the house number in that address. Setting is rather clumsy, and uses the record syntax style to update things. We can't compose these well, so if we wanted a shorthand way to access properties we'd have to define them all ourselves:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- get the persons address (address person) and update house/street to a new value,
</span><span style=color:#75715e>-- also updating person to use this updated address:
</span><span>setHouse person value </span><span style=color:#f92672>=</span><span> person { address </span><span style=color:#f92672>=</span><span> (address person) { house </span><span style=color:#f92672>=</span><span> value }  }
</span><span>setStreet person value </span><span style=color:#f92672>=</span><span> person { address </span><span style=color:#f92672>=</span><span> (address person) { street </span><span style=color:#f92672>=</span><span> value }  }
</span><span>
</span><span>newPerson1 </span><span style=color:#f92672>=</span><span> setHouse person </span><span style=color:#ae81ff>45
</span><span>newPerson2 </span><span style=color:#f92672>=</span><span> setStreet person </span><span style=color:#e6db74>"New Street"
</span></code></pre><p>You can imagine that this could all get very tedious, especially when you have to go deeper and deeper into the structures to make a change.<h1 id=creating-our-own-lens-type>Creating our own lens type</h1><p>Lenses are designed to make this sort of thing simpler. The general idea is that you define lenses to get at each property in your data structure (the lens package comes with a template Haskell function that'll do this for you, but we'll look at doing it all ourselves). You can then compose these lenses together to dig deeper and deeper into some structure, and then we can view and update the value focused in on.<p>on first attempt, you might define a general lens data type like:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>data </span><span style=color:#ae81ff>Lens</span><span>' thing prop </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Lens</span><span>' {
</span><span>	</span><span style=color:#a6e22e>view' </span><span style=color:#f92672>:: </span><span>thing </span><span style=color:#f92672>-> </span><span>prop,
</span><span>	</span><span style=color:#a6e22e>update' </span><span style=color:#f92672>::</span><span> (prop </span><span style=color:#f92672>-> </span><span>prop) </span><span style=color:#f92672>-> </span><span>thing </span><span style=color:#f92672>-> </span><span>thing
</span><span>}
</span></code></pre><p>So that we have this general type that supports the notion of viewing and updating values. <code>thing</code> and <code>prop</code> are both generic types that can refer to any concrete thing or prop. <code>thing</code> is the thing you want to dig into and <code>prop</code> is the value you want to get or update.<p>In our simple lens data type, we can see that <code>view</code> takes in some <code>thing</code>, and give us back the <code>prop</code> we're interested in. <code>update</code> takes in a function that changes a <code>prop</code> into a new <code>prop</code>, and a <code>thing</code> to perform this update on, and is expected to return a new <code>thing</code> that reflects this update. We could also define a set function which just updates some <code>prop</code> to a new value, based on this update function:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>set' </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Lens</span><span>' thing prop </span><span style=color:#f92672>-> </span><span>prop </span><span style=color:#f92672>-> </span><span>thing </span><span style=color:#f92672>-> </span><span>thing
</span><span>set' ln newValue thing </span><span style=color:#f92672>=</span><span> (update' ln) (</span><span style=color:#f92672>\</span><span>_ </span><span style=color:#f92672>-></span><span> newValue) thing
</span></code></pre><p>We could define lenses using this type as follows:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>addressLens </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Lens</span><span>' </span><span style=font-style:italic;color:#66d9ef>Person Address
</span><span>addressLens </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Lens</span><span>' address (</span><span style=color:#f92672>\</span><span>fn thing </span><span style=color:#f92672>-></span><span> thing { address </span><span style=color:#f92672>=</span><span> fn (address thing) })
</span><span>
</span><span style=color:#a6e22e>cityLens </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Lens</span><span>' </span><span style=font-style:italic;color:#66d9ef>Address String
</span><span>cityLens </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Lens</span><span>' city (</span><span style=color:#f92672>\</span><span>fn thing </span><span style=color:#f92672>-></span><span> thing { city </span><span style=color:#f92672>=</span><span> fn (city thing) })
</span></code></pre><p>You might wonder what the advantages of these are over the record syntax haskell already has. Well, for one thing, they compose a lot better. Here's how I might combine the address and city lens to create a new lens, or just a composite get/update function:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>personToCityLens </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Lens</span><span>' </span><span style=font-style:italic;color:#66d9ef>Person String
</span><span>personToCityLens </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Lens</span><span>' ((view' cityLens)</span><span style=color:#f92672>.</span><span>(view' addressLens)) ((update' addressLens)</span><span style=color:#f92672>.</span><span>(update' cityLens))
</span><span>
</span><span style=color:#75715e>--alternately, don't create a new lens and just compose the city and address lenses on the fly:
</span><span>viewCity person </span><span style=color:#f92672>=</span><span> (view' cityLens </span><span style=color:#f92672>.</span><span> view' addressLens) person
</span><span>updateCity fn person </span><span style=color:#f92672>=</span><span> (update' addressLens </span><span style=color:#f92672>.</span><span> update' cityLens) fn person
</span><span>
</span><span style=color:#75715e>--this could be abbreviated as was done in the lens definition to:
</span><span>viewCity </span><span style=color:#f92672>=</span><span> view' cityLens </span><span style=color:#f92672>.</span><span> view' addressLens
</span><span>updateCity </span><span style=color:#f92672>=</span><span> update' addressLens </span><span style=color:#f92672>.</span><span> update' cityLens
</span></code></pre><p>You might notice that function composition seems to be flipped between our <code>view</code> and <code>update</code> functions; we'll have a little look why later, but if you try creating an update function that composes two lenses in this way you'll naturally stumble into the same thing. Given our new lenses, we can have a play with them in <code>ghci</code> to make sure they do what we expect:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>></span><span> view' addressLens james
</span><span style=color:#ae81ff>Address</span><span> {house </span><span style=color:#f92672>= </span><span style=color:#ae81ff>42</span><span>, street </span><span style=color:#f92672>= </span><span style=color:#e6db74>"Some Road"</span><span>, city </span><span style=color:#f92672>= </span><span style=color:#e6db74>"London"</span><span>}
</span><span style=color:#f92672>></span><span> view' personToCityLens james
</span><span style=color:#e6db74>"London"
</span><span style=color:#f92672>></span><span> set' personToCityLens </span><span style=color:#e6db74>"Paris"</span><span> james
</span><span style=color:#ae81ff>Person</span><span> {name </span><span style=color:#f92672>= </span><span style=color:#e6db74>"James"</span><span>, age </span><span style=color:#f92672>= </span><span style=color:#ae81ff>28</span><span>, address </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Address</span><span> {house </span><span style=color:#f92672>= </span><span style=color:#ae81ff>42</span><span>, street </span><span style=color:#f92672>= </span><span style=color:#e6db74>"Some Road"</span><span>, city </span><span style=color:#f92672>= </span><span style=color:#e6db74>"Paris"</span><span>}}
</span><span style=color:#f92672>></span><span> update' personToCityLens (</span><span style=color:#f92672>++</span><span style=color:#e6db74>"!!!!"</span><span>) james
</span><span style=color:#ae81ff>Person</span><span> {name </span><span style=color:#f92672>= </span><span style=color:#e6db74>"James"</span><span>, age </span><span style=color:#f92672>= </span><span style=color:#ae81ff>28</span><span>, address </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Address</span><span> {house </span><span style=color:#f92672>= </span><span style=color:#ae81ff>42</span><span>, street </span><span style=color:#f92672>= </span><span style=color:#e6db74>"Some Road"</span><span>, city </span><span style=color:#f92672>= </span><span style=color:#e6db74>"London!!!!"</span><span>}}
</span><span style=color:#f92672>></span><span> (update' addressLens </span><span style=color:#f92672>.</span><span> update' cityLens) (</span><span style=color:#f92672>++</span><span style=color:#e6db74>"!!!!"</span><span>) james
</span><span style=color:#ae81ff>Person</span><span> {name </span><span style=color:#f92672>= </span><span style=color:#e6db74>"James"</span><span>, age </span><span style=color:#f92672>= </span><span style=color:#ae81ff>28</span><span>, address </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Address</span><span> {house </span><span style=color:#f92672>= </span><span style=color:#ae81ff>42</span><span>, street </span><span style=color:#f92672>= </span><span style=color:#e6db74>"Some Road"</span><span>, city </span><span style=color:#f92672>= </span><span style=color:#e6db74>"London!!!!"</span><span>}}
</span></code></pre><p>So, things are a little better already, but our simple lenses don't compose as well as we'd like still; for one thing it would be nicer if we could decouple the action (view/update in this case) from the lenses in our composition. Creating a data type also means that to use or create lenses elsewhere we have to import this type.<h1 id=looking-at-the-real-lens>Looking at the <em>real</em> lens</h1><p>One way to resolve both of these concerns is to represent this "lens" concept in terms of a single function, rather than a viewing and an updating function. That way, instead of creating a new data type, we just require that lenses match the function signature in order that they can be used together in a standard way. To make things a little simpler, we can create a type alias for this lens function signature.<p>As it turns out, that's exactly what's been done!<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- we need to add this to the top of our file now:
</span><span>{-# </span><span style=color:#f92672>LANGUAGE</span><span> RankNTypes #-}
</span><span>
</span><span style=color:#75715e>--the lens type alias:
</span><span style=color:#f92672>type </span><span style=color:#ae81ff>Lens</span><span> thing prop </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Functor</span><span> f </span><span style=color:#f92672>=></span><span> (prop </span><span style=color:#f92672>-></span><span> f prop) </span><span style=color:#f92672>-></span><span> thing </span><span style=color:#f92672>-></span><span> f thing
</span></code></pre><h2 id=a-brief-interlude-into-rankntypes>A brief interlude into RankNTypes</h2><p>You'll need to use the <code>RankNTypes</code> extension for this to work. Briefly, if you pass a function into a function, we have to declare the types that the function takes in and returns (albeit with a generic letter). To pass in a function that will work on every type (potentially subject to some bounds like <code>Functor f</code>) we need to be a little more explicit in some cases. We enable <code>RankNTypes</code> to make this possible. Example code is the easiest way to summarize the issue:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>{-# </span><span style=color:#f92672>LANGUAGE</span><span> RankNTypes #-}
</span><span>
</span><span style=color:#75715e>-- for any type signature, we need to declare the variables we'll use with forall.
</span><span style=color:#75715e>-- and then declare any constraints on them (Functor f for instance). ghc does this
</span><span style=color:#75715e>-- implicitly for us by declaring all variables at the top, so these are the same:
</span><span style=color:#a6e22e>lens </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Functor </span><span>f </span><span style=color:#f92672>=></span><span> (prop </span><span style=color:#f92672>-> </span><span>f prop) </span><span style=color:#f92672>-> </span><span>thing </span><span style=color:#f92672>-> </span><span>f thing
</span><span style=color:#a6e22e>lens </span><span style=color:#f92672>:: </span><span>forall f prop thing. </span><span style=font-style:italic;color:#66d9ef>Functor </span><span>f </span><span style=color:#f92672>=></span><span> (prop </span><span style=color:#f92672>-> </span><span>f prop) </span><span style=color:#f92672>-> </span><span>thing </span><span style=color:#f92672>-> </span><span>f thing
</span><span>
</span><span style=color:#75715e>-- but what about if we used it as part of another function, say:
</span><span>workWithLens a ln </span><span style=color:#f92672>::</span><span> a </span><span style=color:#f92672>-></span><span> (</span><span style=color:#ae81ff>Functor</span><span> f </span><span style=color:#f92672>=></span><span> (prop </span><span style=color:#f92672>-></span><span> f prop) </span><span style=color:#f92672>-></span><span> thing </span><span style=color:#f92672>-></span><span> f thing)
</span><span>
</span><span style=color:#75715e>-- the problem here is that the variable declaration and constraint (Functor f)
</span><span style=color:#75715e>-- are no longer declared in the same place.
</span><span>workWithLens a ln </span><span style=color:#f92672>::</span><span> forall a prop thing f</span><span style=color:#f92672>.</span><span> a </span><span style=color:#f92672>-></span><span> (</span><span style=color:#ae81ff>Functor</span><span> f </span><span style=color:#f92672>=></span><span> (prop </span><span style=color:#f92672>-></span><span> f prop) </span><span style=color:#f92672>-></span><span> thing </span><span style=color:#f92672>-></span><span> f thing)
</span><span>
</span><span style=color:#75715e>-- if we were writing this out by hand without a type signature, we'd avoid
</span><span style=color:#75715e>-- the problem by moving the constraint to the front as in:
</span><span>workWithLens a ln </span><span style=color:#f92672>::</span><span> forall a prop thing f</span><span style=color:#f92672>. </span><span style=color:#ae81ff>Functor</span><span> f </span><span style=color:#f92672>=></span><span> a </span><span style=color:#f92672>-></span><span> ((prop </span><span style=color:#f92672>-></span><span> f prop) </span><span style=color:#f92672>-></span><span> thing </span><span style=color:#f92672>-></span><span> f thing)
</span><span>
</span><span style=color:#75715e>-- which is just the same as the following, as ghc adds our top level declarations:
</span><span>workWithLens a ln </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>Functor</span><span> f </span><span style=color:#f92672>=></span><span> a </span><span style=color:#f92672>-></span><span> ((prop </span><span style=color:#f92672>-></span><span> f prop) </span><span style=color:#f92672>-></span><span> thing </span><span style=color:#f92672>-></span><span> f thing)
</span><span>
</span><span style=color:#75715e>-- however the alternate approach is adding a new variable declaration in the
</span><span style=color:#75715e>-- inner function, which is what RankNTypes would do for us when we add a class
</span><span style=color:#75715e>-- constraint:
</span><span>workWithLens a ln </span><span style=color:#f92672>::</span><span> forall a prop thing</span><span style=color:#f92672>.</span><span> a </span><span style=color:#f92672>-></span><span> (forall f</span><span style=color:#f92672>. </span><span style=color:#ae81ff>Functor</span><span> f </span><span style=color:#f92672>=></span><span> (prop </span><span style=color:#f92672>-></span><span> f prop) </span><span style=color:#f92672>-></span><span> thing </span><span style=color:#f92672>-></span><span> f thing)
</span></code></pre><p>It's important to note here that where the variable is declared with <code>forall</code> is important. If a variable is declared at the front of the type signature then it can only be one type throughout the signature. If the variable is declared with <code>forall</code> in a nested function, it can only be one type throughout that function, but the function itself could be called with many different types. Let's have a quick look at this with an example:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- we don't know anything about 'a', but we can, say, wrap it up:
</span><span style=color:#a6e22e>justA </span><span style=color:#f92672>:: </span><span>a </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>Maybe </span><span>a
</span><span>justA a </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Just</span><span> a
</span><span>
</span><span style=color:#75715e>-- with implicit forall added to declare 'a', we have:
</span><span style=color:#a6e22e>justA </span><span style=color:#f92672>:: </span><span>forall a. a </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>Maybe </span><span>a
</span><span>
</span><span style=color:#75715e>-- say we want to wrap a pair of values; we'll declare a function like this
</span><span style=color:#75715e>-- (adding an explicit forall as ghc would for clarity):
</span><span style=color:#a6e22e>wrapPair </span><span style=color:#f92672>:: </span><span>forall a t x y. (a </span><span style=color:#f92672>-> </span><span>t a) </span><span style=color:#f92672>-></span><span> (x,y) </span><span style=color:#f92672>-></span><span> (t x, t y)
</span><span>wrapPair wrappingFn (x,y) </span><span style=color:#f92672>=</span><span> (wrappingFn x, wrappingFn y)
</span><span>
</span><span style=color:#75715e>-- this isn't good enough though, because wrappingFn now expects an 'a'
</span><span style=color:#75715e>-- but is given a 'b' and a 'c', both potentially different! To fix, declare
</span><span style=color:#75715e>-- a new variable inside the scope of wrappingFn and say that it can be anything:
</span><span style=color:#a6e22e>wrapPair </span><span style=color:#f92672>:: </span><span>forall t x y. (forall a. a </span><span style=color:#f92672>-> </span><span>t a) </span><span style=color:#f92672>-></span><span> (x,y) </span><span style=color:#f92672>-></span><span> (t x, t y)
</span><span>
</span><span style=color:#75715e>-- since ghc declares top level variables for us, this can be abbreviated to:
</span><span style=color:#a6e22e>wrapPair </span><span style=color:#f92672>::</span><span> (forall a. a </span><span style=color:#f92672>-> </span><span>t a) </span><span style=color:#f92672>-></span><span> (x,y) </span><span style=color:#f92672>-></span><span> (t x, t y)
</span></code></pre><p>By declaring new variables in nested functions, we essentially scope the variables to those nested functions, allowing that, just like if the function was declared at the top level, the variable can take on any type its allowed to throughout the life of its scope. <code>wrapPair</code>, above, now expects to be given a function which can work on any value <code>a</code>, and thus itself can pass any type to the function during the course of its execution.<h2 id=anyway-back-on-topic>Anyway, back on topic..</h2><p>So, we have our general lens type alias:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>type </span><span style=color:#ae81ff>Lens</span><span> thing prop </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Functor</span><span> f </span><span style=color:#f92672>=></span><span> (prop </span><span style=color:#f92672>-></span><span> f prop) </span><span style=color:#f92672>-></span><span> thing </span><span style=color:#f92672>-></span><span> f thing
</span></code></pre><p>This is basically the exact function signature as we used for the <code>update</code> function, except that we have declared that the first function passed in to it <code>(prop -> f prop)</code> returns the <code>prop</code> type wrapped in some <code>Functor</code> type (but we don't know which!), and that we want the output <code>thing</code> to be wrapped in that same <code>Functor</code> f.<p>You might be wondering why we've bothered wrapping anything in a <code>Functor</code>. Surely it just makes everything more complicated! I believe the main reason is to allow a function that matches this lens signature to be used to view the property we focus on as well as just update it. Without functor wrapping, the signature is just <code>(prop -> prop) -> thing -> thing</code>; a function which takes in a function which updates or sets the <code>prop</code> to some value, and a <code>thing</code> to do the setting on, and then which returns a <code>thing</code>. To view the prop though, we really need it to return <code>prop</code>!<p>Functors allow us to get around this, as we can create a <code>Functor</code> instance that hides the <code>prop</code> inside of itself but looks otherwise like an <code>f thing</code>. We'll see how with the <code>view</code> function.<p>Since <code>f</code> could be <em>any</em> Functor instance, the only thing we can use to work with it is a function that is common to all <code>Functor</code> instances; <code>fmap</code>. The other thing you might notice is that when the lens applies the first function <code>(prop -> f prop)</code> to some <code>prop</code>, it obtains this elusive Functor <code>f</code> with a prop inside. Since it doesn't know how to make an instance of this functor itself (which Functor would it make?), it can instead be cunning and use <code>fmap</code> to change the contents of the <code>f prop</code> it gets back to turn it into an <code>f thing</code>. In fact, this is the only way to make an <code>f thing</code>, so any lens function we create will inevitably end up using <code>fmap</code>.<h1 id=defining-a-view-function>Defining a <code>view</code> function</h1><p>Let's define a <code>view</code> function that can use a lens and some item to focus in on to give us back the thing we focus in on:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- our view function takes in a lens which has the above type, and a thing to use the lens on,
</span><span style=color:#75715e>-- and needs to return the prop.
</span><span style=color:#a6e22e>view </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Lens </span><span>thing prop </span><span style=color:#f92672>-> </span><span>thing </span><span style=color:#f92672>-> </span><span>prop
</span><span>
</span><span style=color:#75715e>-- which, expanded out, looks like:
</span><span style=color:#a6e22e>view </span><span style=color:#f92672>::</span><span> ((prop </span><span style=color:#f92672>-> </span><span>f prop) </span><span style=color:#f92672>-> </span><span>thing </span><span style=color:#f92672>-> </span><span>f thing) </span><span style=color:#f92672>-> </span><span>thing </span><span style=color:#f92672>-> </span><span>prop
</span><span>
</span><span style=color:#75715e>-- well, the lens function expects a (prop -> f prop) function, and a thing, to be passed to it,
</span><span style=color:#75715e>-- so lets start there:
</span><span>view ln thing </span><span style=color:#f92672>=</span><span> ln (</span><span style=color:#f92672>\</span><span>p </span><span style=color:#f92672>-> ???</span><span>) thing
</span><span>
</span><span style=color:#75715e>-- first off, what goes in place of ???. We need to wrap prop in some Functor (remember, the lens
</span><span style=color:#75715e>-- function doesn't care which as it'll happily work with any) to match the lens signature.
</span><span style=color:#75715e>-- We'll get the result back wrapped in the same functor (f thing), so whatever Functor we use,
</span><span style=color:#75715e>-- we'll need to get our thing back out to return it. It'll have to look something like:
</span><span>view ln thing </span><span style=color:#f92672>=</span><span> getFromFunctor </span><span style=color:#f92672>$</span><span> ln (</span><span style=color:#f92672>\</span><span>p </span><span style=color:#f92672>-> </span><span style=color:#ae81ff>SomeFunctor</span><span> p) thing
</span></code></pre><p>What we need here is something that can act as a <code>Functor</code> and hide away some value while pretending to be something else. Something that looks like this would do the trick:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>--a data type parametrised by two variables,
</span><span style=color:#75715e>--but which only really cares about one:
</span><span style=color:#f92672>data </span><span style=color:#ae81ff>Const</span><span> a b </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Const</span><span> { getConst </span><span style=color:#f92672>::</span><span> a }
</span><span>
</span><span style=color:#75715e>--a functor normally holds one type inside it, like a monad.
</span><span style=color:#75715e>--so we partially apply the Const type to meet that criteria:
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>Functor</span><span> (</span><span style=font-style:italic;color:#66d9ef>Const </span><span>a) </span><span style=color:#f92672>where
</span><span>	fmap _ (</span><span style=color:#ae81ff>Const</span><span> a) </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Const</span><span> a
</span><span>
</span><span style=color:#75715e>--this means that (Const a) can be our Functor, where in fact 'a'
</span><span style=color:#75715e>--is the type we'll eventually want back, and b is just whatever
</span><span style=color:#75715e>--type we need to make the Functor match 'f thing' when used above.
</span></code></pre><p>What this means is that our <code>Functor</code> is actually <code>(Const prop)</code>, so when we return <code>f thing</code>, we're actually going to be returning <code>(Const prop) thing</code>, which we can then unwrap to get our <code>prop</code> back out!<p><code>Const</code> is already defined in <code>Control.Applicative</code>, but it's useful to see how simple it is to define. Using Const to hide away and then extract our prop, our final definition of view is:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>view </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Lens </span><span>thing prop </span><span style=color:#f92672>-> </span><span>thing </span><span style=color:#f92672>-> </span><span>prop
</span><span>view ln thing </span><span style=color:#f92672>=</span><span> getConst </span><span style=color:#f92672>$</span><span> ln (</span><span style=color:#f92672>\</span><span>p </span><span style=color:#f92672>-> </span><span style=color:#ae81ff>Const</span><span> p) thing
</span><span>
</span><span style=color:#75715e>-- indeed, we can simplify it, noting that the `Const` constructor is a
</span><span style=color:#75715e>-- valid function in itself to pass to a lens:
</span><span>view ln thing </span><span style=color:#f92672>=</span><span> getConst </span><span style=color:#f92672>$</span><span> ln </span><span style=color:#ae81ff>Const</span><span> thing
</span></code></pre><p>Awesome! So now we've defined a <code>view</code> function which has the same net result as our simpler <code>view'</code> one, but instead makes use of our single general purpose lens function to do so.<h1 id=defining-our-update-and-set-functions>Defining our <code>update</code> and <code>set</code> functions</h1><p>We can also define an <code>update</code> function (actually called <code>over</code> in the real lens library) which modifies a property:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- our original update was very similar to the lens type signature. We just
</span><span style=color:#75715e>-- need to mangle some Functor thing in to match the lens funcs type signature:
</span><span style=color:#a6e22e>update </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Lens </span><span>thing prop </span><span style=color:#f92672>-></span><span> (prop </span><span style=color:#f92672>-> </span><span>prop) </span><span style=color:#f92672>-> </span><span>thing </span><span style=color:#f92672>-> </span><span>thing
</span><span>update ln fn thing </span><span style=color:#f92672>= ??? $</span><span> ln (</span><span style=color:#f92672>\</span><span>p </span><span style=color:#f92672>-> ???</span><span> (fn p)) thing
</span><span>
</span><span style=color:#75715e>-- we give the lens a function which applies our function to the property, but
</span><span style=color:#75715e>-- then has to wrap it into a functor as well. As with view, we get back a thing
</span><span style=color:#75715e>-- inside that same functor, so we need to unwrap it. It'll look a bit like:
</span><span>update ln fn thing </span><span style=color:#f92672>=</span><span> getFromFunctor </span><span style=color:#f92672>$</span><span> ln (</span><span style=color:#f92672>\</span><span>p </span><span style=color:#f92672>-> </span><span style=color:#ae81ff>SomeFunctor</span><span> (fn p)) thing
</span></code></pre><p>Once again we need a Functor to wrap our value in, but this time we don't need it to do anything at all. A simple definition of a Functor that just holds a value for us is (defined in <code>Control.Monad.Identity</code>):<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>data </span><span style=color:#ae81ff>Identity</span><span> a </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Identity</span><span> { runIdentity </span><span style=color:#f92672>::</span><span> a }
</span><span>
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>Functor Identity </span><span style=color:#f92672>where
</span><span>	fmap fn (</span><span style=color:#ae81ff>Identity</span><span> a) </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Identity</span><span> (fn a)
</span></code></pre><p>With this, we can define update as:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>update </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Lens </span><span>thing prop </span><span style=color:#f92672>-></span><span> (prop </span><span style=color:#f92672>-> </span><span>prop) </span><span style=color:#f92672>-> </span><span>thing </span><span style=color:#f92672>-> </span><span>thing
</span><span>update ln fn thing </span><span style=color:#f92672>=</span><span> runIdentity </span><span style=color:#f92672>$</span><span> ln (</span><span style=color:#f92672>\</span><span>p </span><span style=color:#f92672>-> </span><span style=color:#ae81ff>Identity</span><span> (fn p)) thing
</span><span>
</span><span style=color:#75715e>-- defining 'set', to just set the property to a value rather than
</span><span style=color:#75715e>-- apply some function to it, becomes very easy now too in terms of
</span><span style=color:#75715e>-- update:
</span><span style=color:#a6e22e>set </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Lens </span><span>thing prop </span><span style=color:#f92672>-> </span><span>prop </span><span style=color:#f92672>-> </span><span>thing </span><span style=color:#f92672>-> </span><span>thing
</span><span>set ln newValue thing </span><span style=color:#f92672>=</span><span> update ln (</span><span style=color:#f92672>\</span><span>_ </span><span style=color:#f92672>-></span><span> newValue) thing
</span><span>
</span><span style=color:#75715e>-- indeed, we can simplify update and set a little if that floats your
</span><span style=color:#75715e>-- boat. A little point free notation for update:
</span><span>update ln fn thing </span><span style=color:#f92672>=</span><span> runIdentity </span><span style=color:#f92672>$</span><span> ln (</span><span style=color:#ae81ff>Identity </span><span style=color:#f92672>.</span><span> fn) thing
</span><span>
</span><span style=color:#75715e>-- and the const function for set (not to be confused with Const),
</span><span style=color:#75715e>-- along with a little point free style to remove thing:
</span><span>set ln newValue </span><span style=color:#f92672>=</span><span> update ln (const newValue)
</span></code></pre><p>Now we have functions that, given some lens, can view, set and update the value that the lens points to. The next step is to actually define lenses for things.<h1 id=defining-lenses>Defining lenses</h1><p>so, to recap, defining a lens means defining a function of the type <code>Functor f => (prop -> f prop) -> thing -> f thing</code>, where <code>prop</code> is the value we want to focus in on and <code>thing</code> is the thing that we're starting from. Remember out <code>Person</code> and <code>Address</code> data? let's make a couple of lenses for those:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- to recap, our simple data types:
</span><span style=color:#f92672>data </span><span style=color:#ae81ff>Person </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Person</span><span> {
</span><span>	</span><span style=color:#a6e22e>name </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>String</span><span>,
</span><span>	</span><span style=color:#a6e22e>age </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Int</span><span>,
</span><span>	</span><span style=color:#a6e22e>address </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Address
</span><span>}
</span><span>
</span><span style=color:#f92672>data </span><span style=color:#ae81ff>Address </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Address</span><span> {
</span><span>	</span><span style=color:#a6e22e>house </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Int</span><span>,
</span><span>	</span><span style=color:#a6e22e>street </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>String</span><span>,
</span><span>	</span><span style=color:#a6e22e>city </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>String
</span><span>}
</span><span>
</span><span style=color:#75715e>-- we made simple lenses to get to the city before. let's use our
</span><span style=color:#75715e>-- better, more general lens formula now to do the same!
</span><span>
</span><span style=color:#75715e>-- our alias type signature neatly tells us what we're starting
</span><span style=color:#75715e>-- with and what we're focusing on:
</span><span style=color:#a6e22e>betterAddressLens </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Lens Person Address
</span><span>
</span><span style=color:#75715e>-- so, our lens function takes in some function fn, which acts to update
</span><span style=color:#75715e>-- the thing we're focusing on, but also wraps it in a functor. We'll
</span><span style=color:#75715e>-- do that bit first then, by applying it to the persons address:
</span><span>betterAddressLens fn person </span><span style=color:#f92672>= ??</span><span> (fn </span><span style=color:#f92672>$</span><span> address person)
</span><span>
</span><span style=color:#75715e>-- that function returns a new Address wrapped in some functor (we dont know which, remember).
</span><span style=color:#75715e>-- We need to turn our functor wrapped Address into a functor wrapped Person then, remembering
</span><span style=color:#75715e>-- to update the Person's Address to the new address in the process:
</span><span>betterAddressLens fn person </span><span style=color:#f92672>=</span><span> fmap (</span><span style=color:#f92672>\</span><span>newAddy </span><span style=color:#f92672>-></span><span> person { address </span><span style=color:#f92672>=</span><span> newAddy }) (fn </span><span style=color:#f92672>$</span><span> address person)
</span><span>
</span><span style=color:#75715e>-- now we know the format, do the same sorta thing to go from an Address to a city:
</span><span style=color:#a6e22e>betterCityLens </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Lens Address String
</span><span>betterCityLens fn addy </span><span style=color:#f92672>=</span><span> fmap (</span><span style=color:#f92672>\</span><span>newAddy </span><span style=color:#f92672>-></span><span> addy { city </span><span style=color:#f92672>=</span><span> newAddy }) (fn </span><span style=color:#f92672>$</span><span> city addy)
</span><span>
</span><span style=color:#75715e>-- and again to go from a Person to a name:
</span><span style=color:#a6e22e>betterNameLens </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Lens Person String
</span><span>betterNameLens fn person </span><span style=color:#f92672>=</span><span> fmap (</span><span style=color:#f92672>\</span><span>newName </span><span style=color:#f92672>-></span><span> person { name </span><span style=color:#f92672>=</span><span> newName }) (fn </span><span style=color:#f92672>$</span><span> name person)
</span><span>
</span><span style=color:#75715e>-- in fact, this can be done so mechanically that the lens package provides a template
</span><span style=color:#75715e>-- makeLens'' function to do it for you.
</span></code></pre><p>Now we have some lenses, and our <code>view</code>, <code>update</code> and <code>set</code> functions to work with them, let's have a play in ghci:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>></span><span> james
</span><span style=color:#ae81ff>Person</span><span> {name </span><span style=color:#f92672>= </span><span style=color:#e6db74>"James"</span><span>, age </span><span style=color:#f92672>= </span><span style=color:#ae81ff>28</span><span>, address </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Address</span><span> {house </span><span style=color:#f92672>= </span><span style=color:#ae81ff>42</span><span>, street </span><span style=color:#f92672>= </span><span style=color:#e6db74>"Some Road"</span><span>, city </span><span style=color:#f92672>= </span><span style=color:#e6db74>"London"</span><span>}}
</span><span style=color:#f92672>></span><span> view betterAddressLens james
</span><span style=color:#ae81ff>Address</span><span> {house </span><span style=color:#f92672>= </span><span style=color:#ae81ff>42</span><span>, street </span><span style=color:#f92672>= </span><span style=color:#e6db74>"Some Road"</span><span>, city </span><span style=color:#f92672>= </span><span style=color:#e6db74>"London"</span><span>}
</span><span style=color:#f92672>></span><span> view betterNameLens james
</span><span style=color:#e6db74>"james"
</span><span style=color:#f92672>></span><span> set betterNameLens </span><span style=color:#e6db74>"Bob"</span><span> james
</span><span style=color:#ae81ff>Person</span><span> {name </span><span style=color:#f92672>= </span><span style=color:#e6db74>"Bob"</span><span>, age </span><span style=color:#f92672>= </span><span style=color:#ae81ff>28</span><span>, address </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Address</span><span> {house </span><span style=color:#f92672>= </span><span style=color:#ae81ff>42</span><span>, street </span><span style=color:#f92672>= </span><span style=color:#e6db74>"Some Road"</span><span>, city </span><span style=color:#f92672>= </span><span style=color:#e6db74>"London"</span><span>}}
</span></code></pre><p>Digging into nested properties is also amazingly simple, as lenses compose in a way reminiscent of property access in an imperative language (in other words, backwards compared to most things):<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>></span><span> view (betterAddressLens</span><span style=color:#f92672>.</span><span>betterCityLens) james
</span><span style=color:#e6db74>"London"
</span><span style=color:#f92672>></span><span> set (betterAddressLens</span><span style=color:#f92672>.</span><span>betterCityLens) </span><span style=color:#e6db74>"Paris"</span><span> james
</span><span style=color:#ae81ff>Person</span><span> {name </span><span style=color:#f92672>= </span><span style=color:#e6db74>"James"</span><span>, age </span><span style=color:#f92672>= </span><span style=color:#ae81ff>28</span><span>, address </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Address</span><span> {house </span><span style=color:#f92672>= </span><span style=color:#ae81ff>42</span><span>, street </span><span style=color:#f92672>= </span><span style=color:#e6db74>"Some Road"</span><span>, city </span><span style=color:#f92672>= </span><span style=color:#e6db74>"Paris"</span><span>}}
</span><span style=color:#f92672>></span><span> update (betterAddressLens</span><span style=color:#f92672>.</span><span>betterCityLens) (</span><span style=color:#f92672>++</span><span style=color:#e6db74>"!!!!!"</span><span>) james
</span><span style=color:#ae81ff>Person</span><span> {name </span><span style=color:#f92672>= </span><span style=color:#e6db74>"James"</span><span>, age </span><span style=color:#f92672>= </span><span style=color:#ae81ff>28</span><span>, address </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Address</span><span> {house </span><span style=color:#f92672>= </span><span style=color:#ae81ff>42</span><span>, street </span><span style=color:#f92672>= </span><span style=color:#e6db74>"Some Road"</span><span>, city </span><span style=color:#f92672>= </span><span style=color:#e6db74>"London!!!!!"</span><span>}}
</span></code></pre><p>We seem to have achieved our lens related aims then! our lens functions compose easily, and are separate from the actions that we wish to take (eg <code>view</code>, <code>set</code> or <code>update</code>) given the focus that the lenses give us. Let's take a quick detour and see how they compose the way they do.<h1 id=how-do-lenses-compose>How do lenses compose?</h1><p>Let's look at a concrete example to work this out, using our <code>betterAddressLens</code> and <code>betterCityLens</code>. let's look at some type signatures:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- the general lens type signature:
</span><span style=color:#f92672>type </span><span style=color:#ae81ff>Lens</span><span> thing prop </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>Functor</span><span> f </span><span style=color:#f92672>=></span><span> (prop </span><span style=color:#f92672>-></span><span> f prop) </span><span style=color:#f92672>-></span><span> thing </span><span style=color:#f92672>-></span><span> f thing
</span><span>
</span><span style=color:#75715e>-- betterAddress:
</span><span style=color:#a6e22e>betterAddressLens </span><span style=color:#f92672>::</span><span> (</span><span style=font-style:italic;color:#66d9ef>Address </span><span style=color:#f92672>-> </span><span>f </span><span style=font-style:italic;color:#66d9ef>Address</span><span>) </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>Person </span><span style=color:#f92672>-> </span><span>f </span><span style=font-style:italic;color:#66d9ef>Person
</span><span>
</span><span style=color:#75715e>-- betterCity:
</span><span style=color:#a6e22e>betterCityLens </span><span style=color:#f92672>::</span><span> (</span><span style=font-style:italic;color:#66d9ef>City </span><span style=color:#f92672>-> </span><span>f </span><span style=font-style:italic;color:#66d9ef>City</span><span>) </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>Address </span><span style=color:#f92672>-> </span><span>f </span><span style=font-style:italic;color:#66d9ef>Address
</span><span>
</span><span style=color:#75715e>-- and the dot operator (.):
</span><span style=color:#a6e22e>(.) </span><span style=color:#f92672>::</span><span> (b </span><span style=color:#f92672>-> </span><span>c) </span><span style=color:#f92672>-></span><span> (a </span><span style=color:#f92672>-> </span><span>b) </span><span style=color:#f92672>-> </span><span>a </span><span style=color:#f92672>-> </span><span>c
</span></code></pre><p>Plugging our lenses into the type signature for the <code>(.)</code> operator leads to the following:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- using the dot operator and lining up its type signature with our lenses,
</span><span style=color:#75715e>-- we can see that the result is something of the same signature (ie still a lens)
</span><span style=color:#75715e>-- but that goes from a Person to a City (String):
</span><span>((         b             </span><span style=color:#f92672>-></span><span>         c           ) </span><span style=color:#f92672>.</span><span> (      a          </span><span style=color:#f92672>-></span><span>          b            )) </span><span style=color:#f92672>-></span><span> (      a          </span><span style=color:#f92672>-></span><span>         c           )
</span><span>(((</span><span style=color:#ae81ff>Address </span><span style=color:#f92672>-></span><span> f </span><span style=color:#ae81ff>Address</span><span>) </span><span style=color:#f92672>-></span><span> (</span><span style=color:#ae81ff>Person </span><span style=color:#f92672>-></span><span> f </span><span style=color:#ae81ff>Person</span><span>)) </span><span style=color:#f92672>.</span><span> ((</span><span style=color:#ae81ff>City </span><span style=color:#f92672>-></span><span> f </span><span style=color:#ae81ff>City</span><span>) </span><span style=color:#f92672>-></span><span> (</span><span style=color:#ae81ff>Address </span><span style=color:#f92672>-></span><span> f </span><span style=color:#ae81ff>Address</span><span>))) </span><span style=color:#f92672>-></span><span> ((</span><span style=color:#ae81ff>City </span><span style=color:#f92672>-></span><span> f </span><span style=color:#ae81ff>City</span><span>) </span><span style=color:#f92672>-></span><span> (</span><span style=color:#ae81ff>Person </span><span style=color:#f92672>-></span><span> f </span><span style=color:#ae81ff>Person</span><span>))
</span></code></pre><p>So we can see here that lenses compose forwards as a result of the functions type signature. This is just like how our simple lens update function happened to compose forwards like this in our first lens composition examples, except now our lenses are independent of the actions used on them.<h1 id=where-do-i-go-from-here>Where do I go from here?</h1><p>Well, one thing that I have not mentioned is that the <em>real</em> Lens type alias has four parameters, not two! The reason is very simple though, so lets have a quick look at that:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- the lens signature we've been working on:
</span><span style=color:#f92672>type </span><span style=color:#ae81ff>Lens</span><span> thing prop </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>Functor</span><span> f </span><span style=color:#f92672>=></span><span> (prop </span><span style=color:#f92672>-></span><span> f prop) </span><span style=color:#f92672>-></span><span> thing </span><span style=color:#f92672>-></span><span> f thing
</span><span>
</span><span style=color:#75715e>-- the full lens signature looks more like:
</span><span style=color:#f92672>type </span><span style=color:#ae81ff>Lens</span><span> thing newthing prop newprop </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>Functor</span><span> f </span><span style=color:#f92672>=></span><span> (prop </span><span style=color:#f92672>-></span><span> f newprop) </span><span style=color:#f92672>-></span><span> thing </span><span style=color:#f92672>-></span><span> f newthing
</span></code></pre><p>This is basically so that, if needed (and possible), the property can be changed into a different type when it's updated. This of course means the whole thing's type will also change, so we add an extra parameter for each. This has no use in records as the types can't change, but if we take something like a tuple, there is no reason why an update cant result in a tuple with different types inside, for example going from <code>(12, "hello")</code> to <code>([1,2,3], "hello")</code> in the course of an update. The function signatures of both types of lens are otherwise identical, and so they can be used interchangeably (although using a simple lens in the mix somewhere will prevent any types from changing).<p>Now you (hopefully) have an understanding of what lenses are (just functions that match a certain signature), you would be wise to explore more of the <code>lens</code> package. There are loads of infix operators to sugar coat things, and additional functions defined that build on this simple foundation to offer a whole range of possibilities. There are also convenience functions like <code>makeLens''</code> which uses template Haskell to magically generate you lenses for record types to save you the legwork, among others.<h1 id=summary>Summary</h1><p>Some tidbits I hope you take away from this:<ol><li>This <code>lens</code> thing is <strong>just a function</strong> type alias.<li>Because anything matching the right function signature is a lens, we can make lenses (as above) without depending on any package!<li>The fundamental concept being the <code>lens</code> idea, as I hope I've shown, is actually a pretty simple one.</ol><p>Finally, all of the code used above is available <a href=https://jsdw.me/posts/haskell-another-lens-tutorial/code.hs>here</a> ready to be loaded into <code>ghci</code> and played with. Thanks for reading!</div></div></section><footer></footer></div><script src=https://jsdw.me/page.js></script>