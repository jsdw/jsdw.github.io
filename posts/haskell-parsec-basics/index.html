<!doctype html><html><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><title>
    jsdw - An introduction to parsing text in Haskell with Parsec
</title><link href="https://fonts.googleapis.com/css?family=IBM+Plex+Serif|Open+Sans" rel=stylesheet><link href=https://jsdw.me/app.css rel=stylesheet><link href=https://jsdw.me/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><link href=https://jsdw.me/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=https://jsdw.me/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=https://jsdw.me/site.webmanifest rel=manifest><link color=#5bbad5 href=https://jsdw.me/safari-pinned-tab.svg rel=mask-icon><meta content=#f9409c name=msapplication-TileColor><meta content=#ffffff name=theme-color><body><div class="body post"><header><div class=title-inner><div class=jsdw><a href=https://jsdw.me>JSDW</a></div><nav><a href=https://jsdw.me/posts/>posts</a><a href=https://jsdw.me/projects/>projects</a></nav></div></header><section><div class=top><div class=top-scene><svg class="polygon two" viewbox="0 0 100 100" height=100% style=fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421 version=1.1 width=100% xml:space=preserve xmlns=http://www.w3.org/2000/svg xmlns:serif=http://www.serif.com/ xmlns:xlink=http://www.w3.org/1999/xlink><polygon points="0 100, 15 40, 60 0, 100 30"/></svg><svg class="polygon one" viewbox="0 0 100 100" height=100% style=fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421 version=1.1 width=100% xml:space=preserve xmlns=http://www.w3.org/2000/svg xmlns:serif=http://www.serif.com/ xmlns:xlink=http://www.w3.org/1999/xlink><polygon points="0 40, 30 0, 80 33, 100 100"/></svg></div><div class=top-inner><h1 class=title>An introduction to parsing text in Haskell with Parsec <span class=date>2015-05-29</span></h1></div></div><div class=content-inner><div class=post><p>First off, why would you use Parsec as opposed to things like regular expressions for parsing content? Coming from other languages, splitting content into arrays and processing ever smaller chunks using regular expressions and the like can be quite common practise. In Haskell we can go down that route too, but now I've seen the light with Parsec I want to introduce you to a better approach.<p>Most tutorials get stuck in with a complete example straight off the bat, but I'm going to present the different functions one by one so that they can be used as a reference of reminder (to me as much as anyone!) of how things work. I'll try to keep examples relatively self contained, so it shouldn't be hard to skip to bits, but keep in mind the basic setup I do first. I have also put all of the example code into a file <a href=https://jsdw.me/posts/haskell-parsec-basics/examples.hs>right here</a> that is ready to be <code>:load</code>ed straight into <code>ghci</code> and played with.<h1 id=the-basics>The Basics</h1><p>Parsec works its way along some stream of text from beginning to end, attempting to match the stream of inputs to some rule or a set of rules. Parsec is also monadic, so we can piece together our different rules in sequence using the convenient do notation. As a general overview, rules work by consuming a character at a time from the input and determining whether they match or not, so when you piece a number of rules in sequence, each rule will consume part of the input until you have no input left, run out of rules, or one of your rules fails to match (resulting in an error).<p>Let's start with a very basic setup. I import <code>Parsec</code> qualified so it's plainly obvious when I'm using <code>Parsec</code> functions, and also import <code>Control.Applicative</code> so we can play with parsing things in the applicative style later on, and make a short alias for <code>parseTest</code> for use in the examples:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- I import qualified so that it's clear which
</span><span style=color:#75715e>-- functions are from the parsec library:
</span><span style=color:#f92672>import qualified </span><span>Text.Parsec </span><span style=color:#f92672>as </span><span>Parsec
</span><span>
</span><span style=color:#75715e>-- I am the error message infix operator, used later:
</span><span style=color:#f92672>import </span><span>Text.Parsec ((&LT?>))
</span><span>
</span><span style=color:#75715e>-- Imported so we can play with applicative things later.
</span><span style=color:#75715e>-- not qualified as mostly infix operators we'll be using.
</span><span style=color:#f92672>import </span><span>Control.Applicative
</span><span>
</span><span style=color:#75715e>-- Get the Identity monad from here:
</span><span style=color:#f92672>import </span><span>Control.Monad.Identity (</span><span style=font-style:italic;color:#66d9ef>Identity</span><span>)
</span><span>
</span><span style=color:#75715e>-- alias Parsec.parse for more concise usage in my examples:
</span><span>parse rule text </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>parse rule </span><span style=color:#e6db74>"(source)"</span><span> text
</span><span>
</span></code></pre><p>This will be our base setup, with a simple utility function parse defined which just ignored the second argument of Parsec.parse (which in the real world would be the name of the file whose contents you are parsing, and is just used in error messages by Parsec to give you that piece of extra information).<p>Parsec comes with a host of building blocks, each of which can be a rule in its own right, or can be combined with others to build more complex rules up. Let's look at some of these basic building blocks and see how they work with the above setup.<h2 id=parsec-char><code>Parsec.char</code></h2><p>This function returns a rule that matches the current character in the text that we are parsing to whatever character you provide it. Lets have a go in the interactive ghci console:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>ghci</span><span style=color:#f92672>></span><span> someText </span><span style=color:#f92672>= </span><span style=color:#e6db74>"Hello Hello Hello World World World"
</span><span>ghci</span><span style=color:#f92672>></span><span> parse (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>char </span><span style=color:#e6db74>'H'</span><span>) someText
</span><span style=color:#ae81ff>Right </span><span style=color:#e6db74>'H'
</span><span>ghci</span><span style=color:#f92672>></span><span> parse (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>char </span><span style=color:#e6db74>'e'</span><span>) someText
</span><span style=color:#ae81ff>Left </span><span style=color:#e6db74>"(source)"</span><span> (line </span><span style=color:#ae81ff>1</span><span>, column </span><span style=color:#ae81ff>1</span><span>)</span><span style=color:#f92672>:
</span><span>unexpected </span><span style=color:#e6db74>"H"
</span><span>expecting </span><span style=color:#e6db74>"e"
</span></code></pre><p>Here, running <code>Parsec.char 'H'</code> returns a rule that will match a single character so long as it's 'H'. If we thus use it in parsing our string, which begins with an H, it is perfectly happy. If we try looking for any letter that isn't 'H', we fail. The result is always of type <code>Either ParseError res</code>; we get back a <code>Right result</code> if the rule was successful, and <code>Left error</code> if the rule fails. Thus, we can pattern match to see which the case is simply enough:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>main </span><span style=color:#f92672>= do
</span><span>	</span><span style=color:#f92672>let</span><span> result </span><span style=color:#f92672>=</span><span> parse (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>char </span><span style=color:#e6db74>'H'</span><span>) </span><span style=color:#e6db74>"Hello"
</span><span>	</span><span style=color:#f92672>case</span><span> result </span><span style=color:#f92672>of
</span><span>		</span><span style=color:#ae81ff>Right</span><span> v </span><span style=color:#f92672>-></span><span> putStrLn </span><span style=color:#e6db74>"success!"
</span><span>		</span><span style=color:#ae81ff>Left</span><span> err </span><span style=color:#f92672>-></span><span> putStrLn (</span><span style=color:#e6db74>"whoops, error: "</span><span style=color:#f92672>++</span><span>show err)
</span></code></pre><h2 id=parsec-string><code>Parsec.string</code></h2><p>This function returns a rule that attempts to match the provided string of characters:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>ghci</span><span style=color:#f92672>></span><span> parse (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>string </span><span style=color:#e6db74>"hello"</span><span>) </span><span style=color:#e6db74>"hello world!"
</span><span style=color:#ae81ff>Right </span><span style=color:#e6db74>"hello"
</span><span>ghci</span><span style=color:#f92672>></span><span> parse (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>string </span><span style=color:#e6db74>"hello"</span><span>) </span><span style=color:#e6db74>"howdy"
</span><span style=color:#ae81ff>Left </span><span style=color:#e6db74>"(source)"</span><span> (line </span><span style=color:#ae81ff>1</span><span>, column </span><span style=color:#ae81ff>1</span><span>)</span><span style=color:#f92672>:
</span><span>unexpected </span><span style=color:#e6db74>"o"
</span><span>expecting </span><span style=color:#e6db74>"hello"
</span></code></pre><p>The parser will consume characters from the input one by one until all characters match or one of them is not as expected. Since both of the above attempts begin with 'h', the error complains about an unexpected 'o'. This consuming of characters will become significant when multiple rules are chained together.<h2 id=parsec-oneof><code>Parsec.oneOf</code></h2><p>Sometimes we want to match a range of characters; that's where Parsec.oneOf comes in handy. Similar to <code>Parsec.char</code>, except you provide this function a list of characters you're OK with matching:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>ghci</span><span style=color:#f92672>></span><span> parse (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>oneOf </span><span style=color:#e6db74>"abcde"</span><span>) </span><span style=color:#e6db74>"allo"
</span><span style=color:#ae81ff>Right </span><span style=color:#e6db74>'a'
</span><span>ghci</span><span style=color:#f92672>></span><span> parse (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>oneOf </span><span style=color:#e6db74>"abcde"</span><span>) </span><span style=color:#e6db74>"chewy"
</span><span style=color:#ae81ff>Right </span><span style=color:#e6db74>'c'
</span><span>ghci</span><span style=color:#f92672>></span><span> parse (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>oneOf </span><span style=color:#e6db74>"abcde"</span><span>) </span><span style=color:#e6db74>"gnaw"
</span><span style=color:#ae81ff>Left </span><span style=color:#e6db74>"(source)"</span><span> (line </span><span style=color:#ae81ff>1</span><span>, column </span><span style=color:#ae81ff>1</span><span>)</span><span style=color:#f92672>:
</span><span>unexpected </span><span style=color:#e6db74>"g"
</span></code></pre><p>Here, we can see that the parser will <em>consume</em> any single character from 'a' to 'e'. We can use ranges here to simplify things, so to match any lowercase letter we'd just use <code>Parsec.oneOf ['a'..'z']</code> for instance.<p>Parsec comes with pre-prepared rules which do just that, for example <code>Parsec.anyChar</code>, which will consume one of anything:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>ghci</span><span style=color:#f92672>></span><span> parse </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>anyChar </span><span style=color:#e6db74>"blahblah"
</span><span style=color:#ae81ff>Right </span><span style=color:#e6db74>'b'
</span><span>ghci</span><span style=color:#f92672>></span><span> parse </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>anyChar </span><span style=color:#e6db74>"=-symbols..."
</span><span style=color:#ae81ff>Right </span><span style=color:#e6db74>"="
</span></code></pre><p>The rule <code>Parsec.letter</code> will happily consume any lower or uppercase letter, <code>Parsec.lower</code> will consume any lowercase letter, <code>Parsec.digit</code> will consume any number, and <code>Parsec.alphaNum</code> any letter or number. All of these can be constructed manually using <code>Parsec.oneOf</code> as above, though they come with nicer error messages (which you can add to your own rules; we'll look at that later).<h2 id=parsec-noneof><code>Parsec.noneOf</code></h2><p>The opposite of the above, you provide this function a list of characters that aren't allowed and it'll match anything else. Again, ranges are your friend:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>ghci</span><span style=color:#f92672>></span><span> parse (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>noneOf [</span><span style=color:#e6db74>'0'</span><span style=color:#f92672>..</span><span style=color:#e6db74>'9'</span><span>]) </span><span style=color:#e6db74>"hello"
</span><span style=color:#ae81ff>Right </span><span style=color:#e6db74>'h'
</span><span>ghci</span><span style=color:#f92672>></span><span> parse (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>noneOf [</span><span style=color:#e6db74>'0'</span><span style=color:#f92672>..</span><span style=color:#e6db74>'9'</span><span>]) </span><span style=color:#e6db74>"100"
</span><span style=color:#ae81ff>Left </span><span style=color:#e6db74>"(source)"</span><span> (line </span><span style=color:#ae81ff>1</span><span>, column </span><span style=color:#ae81ff>1</span><span>)</span><span style=color:#f92672>:
</span><span>unexpected </span><span style=color:#e6db74>"1"
</span></code></pre><h2 id=parsec-many-and-parsec-many1><code>Parsec.many</code> and <code>Parsec.many1</code></h2><p>Let's face it, there are times when you want to parse more than just one letter. <code>Parsec.many</code> tries to run whatever rule it is given as an argument over and over until it fails. Even if the rule matches no times, many will return without error, but just give back an empty result. Let's see how it's used:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>ghci</span><span style=color:#f92672>></span><span> parse (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>many (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>char </span><span style=color:#e6db74>'h'</span><span>)) </span><span style=color:#e6db74>"hhhheeelllooo!"
</span><span style=color:#ae81ff>Right</span><span> 'hhhh'
</span><span>ghci</span><span style=color:#f92672>></span><span> parse (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>many (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>char </span><span style=color:#e6db74>'e'</span><span>)) </span><span style=color:#e6db74>"hhhheeelllooo!"
</span><span style=color:#ae81ff>Right</span><span> ''
</span><span>ghci</span><span style=color:#f92672>></span><span> parse (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>many </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>letter) </span><span style=color:#e6db74>"hhhheeelllooo!"
</span><span style=color:#ae81ff>Right</span><span> 'hhhheeelllooo'
</span></code></pre><p>As we can see, <code>Parsec.many</code> can't go wrong, as it'll happily match the rule it's given zero times and just return nothing. It'll go as far as it can and give you back everything that matched. <code>Parsec.many1</code> is similar except that the rule it's provided must match at least once for it to return successfully:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>ghci</span><span style=color:#f92672>></span><span> parse (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>many1 </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>letter) </span><span style=color:#e6db74>"hello!!"
</span><span style=color:#ae81ff>Right</span><span> 'hello'
</span><span>ghci</span><span style=color:#f92672>></span><span> parse (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>many1 </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>letter) </span><span style=color:#e6db74>"75 hello's!"
</span><span style=color:#ae81ff>Left </span><span style=color:#e6db74>"(source)"</span><span> (line </span><span style=color:#ae81ff>1</span><span>, column </span><span style=color:#ae81ff>1</span><span>)</span><span style=color:#f92672>:
</span><span>unexpected </span><span style=color:#e6db74>"7"
</span><span>expecting letter
</span></code></pre><p>Useful when you need to match some set of letters or numbers for instance, but must see at least one.<h2 id=parsec-count><code>Parsec.count</code></h2><p>If you need to match a specific number of something, <code>Parsec.count</code> comes in handy. It takes a number and a parser, and expects to match that parser that number of times (or will fail), returning the result. Here's an example:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>ghci</span><span style=color:#f92672>></span><span> parse (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>count </span><span style=color:#ae81ff>4 Parsec</span><span style=color:#f92672>.</span><span>letter) </span><span style=color:#e6db74>"ahoythere"
</span><span style=color:#ae81ff>Right </span><span style=color:#e6db74>"ahoy"
</span><span>ghci</span><span style=color:#f92672>></span><span> parse (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>count </span><span style=color:#ae81ff>4 Parsec</span><span style=color:#f92672>.</span><span>letter) </span><span style=color:#e6db74>"aho"
</span><span style=color:#ae81ff>Left </span><span style=color:#e6db74>"(source)"</span><span> (line </span><span style=color:#ae81ff>1</span><span>, column </span><span style=color:#ae81ff>4</span><span>)</span><span style=color:#f92672>:
</span><span>unexpected end </span><span style=color:#f92672>of</span><span> input
</span><span>expecting letter
</span></code></pre><h2 id=parsec-manytill><code>Parsec.manyTill</code></h2><p>This parser takes in two arguments; the rule it will try matching and the rule it expects to be able to match right after it. As with many, it expects zero or more of the first rule, but it will error on anything that matches neither rule. The below tries matching letters and then expects numbers immediately following them:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>ghci</span><span style=color:#f92672>></span><span> parse (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>manyTill </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>letter </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>digit) </span><span style=color:#e6db74>"hello12345"
</span><span style=color:#ae81ff>Right </span><span style=color:#e6db74>"hello"
</span><span>ghci</span><span style=color:#f92672>></span><span> parse (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>manyTill </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>letter </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>digit) </span><span style=color:#e6db74>"12345"
</span><span style=color:#ae81ff>Right </span><span style=color:#e6db74>""
</span><span>ghci</span><span style=color:#f92672>></span><span> parse (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>manyTill </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>letter </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>digit) </span><span style=color:#e6db74>"hello 12345"
</span><span style=color:#ae81ff>Left </span><span style=color:#e6db74>"(source)"</span><span> (line </span><span style=color:#ae81ff>1</span><span>, column </span><span style=color:#ae81ff>6</span><span>)</span><span style=color:#f92672>:
</span><span>unexpected </span><span style=color:#e6db74>" "
</span><span>expecting digit or letter
</span></code></pre><p>It's important to keep in mind the fact that this will consume (and output) all of the first rule, and then consume whatever the second rule matches (but ignore it in the output). When we start stringing together rules in sequence, it becomes increasingly important what we consume and what we leave ready for the next rule to have a go at.<p>One thing I think is great about Parsec is that it provides useful error information straight off the bat; in this case the string we passed in back at the beginning (<em>"(source)"</em>) along with the line and column number of the error and some useful message as to what went wrong. We're only dealing with single lines at the moment, but to have this from the word go is really cool.<h1 id=combining-rules>Combining Rules</h1><p>Now you have some of the basic rules under your belt, lets talk about how to combine them! Parsec, being monadic, allows you to write parsers using Haskell's <em>do</em> notation sugar. Here's an example that puts some simple parsers above in sequence, getting the results of a couple and returning them:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- This looks for letters, then spaces, then digits.
</span><span style=color:#75715e>-- we then return letters and digits in a tuple.
</span><span style=color:#a6e22e>myParser </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Parsec</span><span>.</span><span style=font-style:italic;color:#66d9ef>Parsec String </span><span style=color:#66d9ef>()</span><span> (</span><span style=font-style:italic;color:#66d9ef>String</span><span>,</span><span style=font-style:italic;color:#66d9ef>String</span><span>)
</span><span>myParser </span><span style=color:#f92672>= do
</span><span>	letters </span><span style=color:#f92672>&LT- </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>many1 </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>letter
</span><span>	</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>spaces
</span><span>	digits </span><span style=color:#f92672>&LT- </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>many1 </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>digit
</span><span>	return (letters,digits)
</span></code></pre><p>Note that I have given this parser an explicit type of <code>Parsec.Parsec String () (String,String)</code>. The arguments to this type in order are simply input type, some state you'd like threaded through your parsers (we'll use the unit type for now, and so have no meaningful state, and have a quick look at state later), then output type. In this case, we're taking in a String and returning a tuple of two strings. If you use <code>:type</code> to inspect the type of rules in ghci, you'll see that they are made from the <code>ParsecT</code> type, not <code>Parsec</code>. <code>ParsecT</code> is just a monad transformer which has the same type parameters as <code>Parsec.Parsec</code>, along with a new parameter <code>m</code> representing the monad that this wraps. Needless to say, these two types are equivalent:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- I have to import the identity monad to use in the ParsecT definition:
</span><span style=color:#f92672>import </span><span>Control.Monad.Identity (</span><span style=font-style:italic;color:#66d9ef>Identity</span><span>)
</span><span>
</span><span style=color:#a6e22e>myParser1 </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Parsec</span><span>.</span><span style=font-style:italic;color:#66d9ef>ParsecT String </span><span style=color:#66d9ef>() </span><span style=font-style:italic;color:#66d9ef>Identity</span><span> (</span><span style=font-style:italic;color:#66d9ef>String</span><span>,</span><span style=font-style:italic;color:#66d9ef>String</span><span>)
</span><span>myParser1 </span><span style=color:#f92672>=</span><span> myParser
</span><span>
</span><span style=color:#a6e22e>myParser2 </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Parsec</span><span>.</span><span style=font-style:italic;color:#66d9ef>Parsec String </span><span style=color:#66d9ef>()</span><span> (</span><span style=font-style:italic;color:#66d9ef>String</span><span>,</span><span style=font-style:italic;color:#66d9ef>String</span><span>)
</span><span>myParser2 </span><span style=color:#f92672>=</span><span> myParser
</span></code></pre><p>When you inspect the types of functions in the <code>Parsec</code> package, bare this in mind to help understand what you are dealing with! Every rule is of a similar type, though the return value varies from rule to rule. <code>Parsec.many</code>, for instance, returns an array of matches. Have a look yourself in ghci!<p>Anyway, now we have defined <code>myParser</code>, We can use it with our <code>parse</code> function as so:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>ghci</span><span style=color:#f92672>></span><span> parse myParser </span><span style=color:#e6db74>"hello 1000"
</span><span style=color:#ae81ff>Right</span><span> (</span><span style=color:#e6db74>"hello"</span><span>,</span><span style=color:#e6db74>"1000"</span><span>)
</span><span>ghci</span><span style=color:#f92672>></span><span> parse myParser </span><span style=color:#e6db74>"woohoooo0!!"
</span><span style=color:#ae81ff>Right</span><span> (</span><span style=color:#e6db74>"woohoooo"</span><span>,</span><span style=color:#e6db74>"0"</span><span>)
</span><span>ghci</span><span style=color:#f92672>></span><span> parse myParser </span><span style=color:#e6db74>"1000"
</span><span style=color:#ae81ff>Left </span><span style=color:#e6db74>"(source)"</span><span> (line </span><span style=color:#ae81ff>1</span><span>, column </span><span style=color:#ae81ff>1</span><span>)</span><span style=color:#f92672>:
</span><span>unexpected </span><span style=color:#e6db74>"1"
</span><span>expecting letter
</span></code></pre><p>Because we have used <code>Parsec.many1</code>, we require there to be at least one letter followed by zero or more spaces and finally at least one number. Our rule then wraps these into a tuple for us (but could instead return them packaged in a custom type or any other arrangement).<p>Say we have a number of these letter/digit pairs, separated by some separator, for example a comma. In this case, we might want to parse them all into a list of tuples of the type seen above. Let's define another rule to parse our separator:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>mySeparator </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Parsec</span><span>.</span><span style=font-style:italic;color:#66d9ef>Parsec String </span><span style=color:#66d9ef>() ()
</span><span>mySeparator </span><span style=color:#f92672>= do
</span><span>	</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>spaces
</span><span>	</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>char </span><span style=color:#e6db74>','
</span><span>	</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>spaces
</span></code></pre><p>I have once again added an explicit type signature. I do this because, when written independent of any usage in my test file, Haskell cannot determine which types things will be. Note that the only thing returned is the last line, which has a type matching our signature; values from any other parsing done prior to this return are ignored. We could also add an explicit <code>return ()</code> at the end, but <code>Parsec.spaces</code> returns this anyway.<p>This rule matches zero or more spaces, followed by a comma, followed by zero or more spaces. Given that we don't care about grabbing and returning any of the values parsed by these rules, we can <em>desugar</em> the above into a one liner:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>mySeparator </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>spaces </span><span style=color:#f92672>>> </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>char </span><span style=color:#e6db74>',' </span><span style=color:#f92672>>> </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>spaces
</span></code></pre><p>Now we have <code>myParser</code>, and <code>mySeparator</code>, each made from smaller parsing rules. In the same way that we have created them, we can now combine our new rules to create ever larger rules. I'll start with a more verbose rule, built from things we have learned above:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>--I want to return a list of pairs, this time.
</span><span style=color:#a6e22e>myPairs </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Parsec</span><span>.</span><span style=font-style:italic;color:#66d9ef>Parsec String </span><span style=color:#66d9ef>()</span><span> [(</span><span style=font-style:italic;color:#66d9ef>String</span><span>,</span><span style=font-style:italic;color:#66d9ef>String</span><span>)]
</span><span>myPairs </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>many </span><span style=color:#f92672>$ do
</span><span>	pair </span><span style=color:#f92672>&LT-</span><span> myParser
</span><span>	mySeparator
</span><span>	return pair
</span></code></pre><p>This basically uses <code>Parsec.many</code> to parse 0 or more instances of <code>myParser</code> followed by <code>mySeparator</code>, saving the result of myParser and returning it. Notice that I use do sugar to build up a rule which is then passed as an argument to <code>Parsec.many</code>. This desugars to the following, which makes it more clear that everything inside the <code>do</code> block is simply one argument to <code>Parsec.many</code>:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>myPairs </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>many (myParser </span><span style=color:#f92672>>>= \</span><span>pair </span><span style=color:#f92672>-></span><span> mySeparator </span><span style=color:#f92672>>></span><span> return pair)
</span></code></pre><p>Given that <code>Parsec.many</code> returns a list of whatever is passed in (see the last bit of its type signature), the result is thus a list of <code>(String,String)</code> pairs. Let's give it a go:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>ghci</span><span style=color:#f92672>></span><span> parse myPairs </span><span style=color:#e6db74>"hello 1, byebye 2,"
</span><span style=color:#ae81ff>Right</span><span> [(</span><span style=color:#e6db74>"hello"</span><span>,</span><span style=color:#e6db74>"1"</span><span>),(</span><span style=color:#e6db74>"byebye"</span><span>,</span><span style=color:#e6db74>"2"</span><span>)]
</span><span>ghci</span><span style=color:#f92672>></span><span> parse myPairs </span><span style=color:#e6db74>""
</span><span style=color:#ae81ff>Right []
</span><span>ghci</span><span style=color:#f92672>></span><span> parse myPairs </span><span style=color:#e6db74>"hello 1, byebye 2"
</span><span style=color:#ae81ff>Left </span><span style=color:#e6db74>"(source)"</span><span> (line </span><span style=color:#ae81ff>1</span><span>, column </span><span style=color:#ae81ff>18</span><span>)</span><span style=color:#f92672>:
</span><span>unexpected end </span><span style=color:#f92672>of</span><span> input
</span><span>expecting digit, white space or </span><span style=color:#e6db74>","
</span></code></pre><p>As we can see, as a result of using <code>Parsec.many</code>, the parser will happily find no instances, but if the parser successfully begins matching input, failure (for example a missing separator at the end) leads to an error being thrown. As it happens, there are built in functions for parsing the common pattern of items split by some separator.<h2 id=parsec-endby><code>Parsec.endBy</code></h2><p>Takes two arguments, a rule to parse items, and a rule to parse separators. <code>Parsec.endBy</code> essentially does exactly as above, and expects a string consisting of rule then separator, returning an array of whatever the rule returns:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- I want to return a list of pairs as above but using a built in helper:
</span><span style=color:#a6e22e>myPairs2a </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Parsec</span><span>.</span><span style=font-style:italic;color:#66d9ef>Parsec String </span><span style=color:#66d9ef>()</span><span> [(</span><span style=font-style:italic;color:#66d9ef>String</span><span>,</span><span style=font-style:italic;color:#66d9ef>String</span><span>)]
</span><span>myPairs2a </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>endBy myParser mySeparator
</span></code></pre><h2 id=parsec-sepby><code>Parsec.sepBy</code></h2><p>Takes two arguments as <code>endBy</code> does, but this time does not expect the separator to come after the final instance of the rule we're parsing.<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- I want to return a list of pairs without a final separator:
</span><span style=color:#a6e22e>myPairs2b </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Parsec</span><span>.</span><span style=font-style:italic;color:#66d9ef>Parsec String </span><span style=color:#66d9ef>()</span><span> [(</span><span style=font-style:italic;color:#66d9ef>String</span><span>,</span><span style=font-style:italic;color:#66d9ef>String</span><span>)]
</span><span>myPairs2b </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>sepBy myParser mySeparator
</span></code></pre><p>As such, it does not require a final separator (in fact the presence of one would be an error):<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>ghci</span><span style=color:#f92672>></span><span> parse myPairs2b </span><span style=color:#e6db74>"hello 1, bye 2"
</span><span style=color:#ae81ff>Right</span><span> [(</span><span style=color:#e6db74>"hello"</span><span>,</span><span style=color:#e6db74>"1"</span><span>),(</span><span style=color:#e6db74>"bye"</span><span>,</span><span style=color:#e6db74>"2"</span><span>)]
</span></code></pre><h2 id=parsec-choice-and-for-matching-one-of-multiple-rules><code>Parsec.choice</code> and <code><|></code> for matching one of multiple rules</h2><p>Using <code>Parsec.choice</code> or the shorthand infix operator <code>Parsec.<|></code> (also in <code>Control.Applicative</code>) we can present more than one rule to parse, and the first rule that <strong>successfully consumes input</strong> is used (even if it later fails; a caveat we'll get to). Let's see how this works in practice by removing the need for a separator at the end of our pairs:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>--I want to return a list of pairs with an optional end separator.
</span><span style=color:#a6e22e>myPairs2 </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Parsec</span><span>.</span><span style=font-style:italic;color:#66d9ef>Parsec String </span><span style=color:#66d9ef>()</span><span> [(</span><span style=font-style:italic;color:#66d9ef>String</span><span>,</span><span style=font-style:italic;color:#66d9ef>String</span><span>)]
</span><span>myPairs2 </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>many </span><span style=color:#f92672>$ do
</span><span>	pair </span><span style=color:#f92672>&LT-</span><span> myParser
</span><span>	</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>choice [</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>eof, mySeparator]
</span><span>	return pair
</span></code></pre><p>Now, our rule will consume many letter-digit pairs, each followed by either the end of file (a rule parsec provides) or our defined separator. This can also be written using the infix operator as:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>import </span><span>Text.Parsec (<|>)
</span><span>
</span><span style=color:#a6e22e>myPairs3 </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Parsec</span><span>.</span><span style=font-style:italic;color:#66d9ef>Parsec String </span><span style=color:#66d9ef>()</span><span> [(</span><span style=font-style:italic;color:#66d9ef>String</span><span>,</span><span style=font-style:italic;color:#66d9ef>String</span><span>)]
</span><span>myPairs3 </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>many </span><span style=color:#f92672>$ do
</span><span>	pair </span><span style=color:#f92672>&LT-</span><span> myParser
</span><span>	</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>eof </span><span style=color:#f92672><|></span><span> mySeparator
</span><span>	return pair
</span></code></pre><p>Where I make note to import the <code><|></code> operator so I don't have to prefix it and make it look ugly in use. Both the infix operator and <code>Parsec.choice</code> support as many alternatives as you like, for example <code>Parsec.choice [rule1, rule2, rule3]</code> or <code>rule1 <|> rule2 <|> rule3</code>. In either case, the first rule in the sequence to consume some input is the rule that is then used. By accepting either end of file or our custom separator, we no longer require the separator at the end:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>ghci</span><span style=color:#f92672>></span><span> parse myPairs2 </span><span style=color:#e6db74>"hello 1, byebye 2,"
</span><span style=color:#ae81ff>Right</span><span> [(</span><span style=color:#e6db74>"hello"</span><span>,</span><span style=color:#e6db74>"1"</span><span>),(</span><span style=color:#e6db74>"byebye"</span><span>,</span><span style=color:#e6db74>"2"</span><span>)]
</span><span>ghci</span><span style=color:#f92672>></span><span> parse myParis2 </span><span style=color:#e6db74>"hello 1, byebye 2"
</span><span style=color:#ae81ff>Right</span><span> [(</span><span style=color:#e6db74>"hello"</span><span>,</span><span style=color:#e6db74>"1"</span><span>),(</span><span style=color:#e6db74>"byebye"</span><span>,</span><span style=color:#e6db74>"2"</span><span>)]
</span></code></pre><p>The important thing to remember here is that the first rule that consumes input is the one that is used. This can lead to unexpected failure. Take the following example:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>parse (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>string </span><span style=color:#e6db74>"hello" </span><span style=color:#f92672><|> </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>string </span><span style=color:#e6db74>"howdy"</span><span>) </span><span style=color:#e6db74>"howdy"
</span></code></pre><p>Offhand one might expect the parser to attempt to match "hello", and on failure to match that, succeed instead at matching "howdy". In actuality the parsing fails entirely:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>ghci</span><span style=color:#f92672>></span><span> parse (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>string </span><span style=color:#e6db74>"hello" </span><span style=color:#f92672><|> </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>string </span><span style=color:#e6db74>"howdy"</span><span>) </span><span style=color:#e6db74>"howdy"
</span><span style=color:#ae81ff>Left </span><span style=color:#e6db74>"(source)"</span><span> (line </span><span style=color:#ae81ff>1</span><span>, column </span><span style=color:#ae81ff>1</span><span>)</span><span style=color:#f92672>:
</span><span>unexpected </span><span style=color:#e6db74>"o"
</span><span>expecting </span><span style=color:#e6db74>"hello"
</span></code></pre><p>This is because on attempting to match the string "hello", the rule created from <code>Parsec.string "hello"</code> consumes the 'h' successfully, and is thus rule selected for use, before subsequently failing on the next character. Taking another example, this becomes clearer:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>ghci</span><span style=color:#f92672>></span><span> parse (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>string </span><span style=color:#e6db74>"hello" </span><span style=color:#f92672><|> </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>string </span><span style=color:#e6db74>"bye"</span><span>) </span><span style=color:#e6db74>"bye"
</span><span style=color:#ae81ff>Right </span><span style=color:#e6db74>"bye"
</span></code></pre><p>Here, the first rule fails before it can successfully consume any input, and so the second rule is selected without issue. By default, Parsec will not "look ahead" to see whether a rule matches or not, for performance reasons. The first solution to this (and probably most performant) is to parse any input that is common to either match separately, and then try the rest, avoiding the need to perform any lookahead, for example:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>ghci</span><span style=color:#f92672>></span><span> parse (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>char </span><span style=color:#e6db74>'h' </span><span style=color:#f92672>>></span><span> (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>string </span><span style=color:#e6db74>"ello" </span><span style=color:#f92672><|> </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>string </span><span style=color:#e6db74>"owdy"</span><span>)) </span><span style=color:#e6db74>"howdy"
</span><span style=color:#ae81ff>Right </span><span style=color:#e6db74>"owdy"
</span></code></pre><p>Noting that since we are ignoring the result of the first parser (which consumes the 'h'), we no longer return the full string. This is simple enough to rectify if necessary; we'll turn our inline notation into a more explicit rule to do so:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>helloOrHowdy </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Parsec</span><span>.</span><span style=font-style:italic;color:#66d9ef>Parsec String </span><span style=color:#66d9ef>() </span><span style=font-style:italic;color:#66d9ef>String
</span><span>helloOrHowdy </span><span style=color:#f92672>= do
</span><span>	first </span><span style=color:#f92672>&LT- </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>char </span><span style=color:#e6db74>'h'
</span><span>	rest </span><span style=color:#f92672>&LT- </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>string </span><span style=color:#e6db74>"ello" </span><span style=color:#f92672><|> </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>string </span><span style=color:#e6db74>"owdy"
</span><span>	return (first</span><span style=color:#f92672>:</span><span>rest)
</span></code></pre><p>By manually deciding what to return from our rule, we can choose to return the correct string by appending our initial char to the rest of the string. Errors are now based on the parts of the string that each rule tries to consume rather than the whole thing, increasing their precision but perhaps at the cost of clarity:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>ghci</span><span style=color:#f92672>></span><span> parse helloOrHowdy </span><span style=color:#e6db74>"hello"
</span><span style=color:#ae81ff>Right </span><span style=color:#e6db74>"hello"
</span><span>ghci</span><span style=color:#f92672>></span><span> parse helloOrHowdy </span><span style=color:#e6db74>"allo"
</span><span style=color:#ae81ff>Left </span><span style=color:#e6db74>"(source)"</span><span> (line </span><span style=color:#ae81ff>1</span><span>, column </span><span style=color:#ae81ff>1</span><span>)</span><span style=color:#f92672>:
</span><span>unexpected </span><span style=color:#e6db74>"a"
</span><span>expecting </span><span style=color:#e6db74>"h"
</span><span>ghci</span><span style=color:#f92672>></span><span> parse helloOrHowdy </span><span style=color:#e6db74>"hoops"
</span><span style=color:#ae81ff>Left </span><span style=color:#e6db74>"(source)"</span><span> (line </span><span style=color:#ae81ff>1</span><span>, column </span><span style=color:#ae81ff>2</span><span>)</span><span style=color:#f92672>:
</span><span>unexpected </span><span style=color:#e6db74>"o"
</span><span>expecting </span><span style=color:#e6db74>"owdy"
</span></code></pre><p>The first error comes from <code>Parsec.char</code>, the second from the failing <code>Parsec.string</code>. We'll show you how to provide your own custom errors instead if you'd prefer, but first lets look at lookahead as a neater way to parse these strings.<h2 id=parsec-try><code>Parsec.try</code></h2><p>Avoiding lookahead can quickly become unwieldy when rules become more complex. In these cases, we can instruct Parsec to try a rule, and rewind us to the previous state if the rule fails at any point. <code>Parsec.try</code> does just this; it catches any failure and rewinds us. Due to the performance implications, it's best to keep the lookahead bounded to as small a region as possible; the less potential parsing is wrapped in a try function, the better. <code>Parsec.try</code> also suppresses any error messages you would otherwise have been given in the wrapped rule, and so can lead to odd and unhelpful error messages if used inappropriately. That said, when used properly it can be taken advantage of to give better errors. Let's give it a go:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>helloOrHowdy2 </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Parsec</span><span>.</span><span style=font-style:italic;color:#66d9ef>Parsec String </span><span style=color:#66d9ef>() </span><span style=font-style:italic;color:#66d9ef>String
</span><span>helloOrHowdy2 </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>try (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>string </span><span style=color:#e6db74>"hello"</span><span>) </span><span style=color:#f92672><|> </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>string </span><span style=color:#e6db74>"howdy"
</span></code></pre><p>This results in the correct parsing, and generally clear errors, but since any errors from failure to parse hello are suppressed, errors will only describe a failure to match the choice operator or a failure to match "howdy", ignoring the failure to match "hello":<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>ghci</span><span style=color:#f92672>></span><span> parse helloOrHowdy2 </span><span style=color:#e6db74>"hello"
</span><span style=color:#ae81ff>Right </span><span style=color:#e6db74>"hello"
</span><span>ghci</span><span style=color:#f92672>></span><span> parse helloOrHowdy2 </span><span style=color:#e6db74>"howdy"
</span><span style=color:#ae81ff>Right </span><span style=color:#e6db74>"howdy"
</span><span>ghci</span><span style=color:#f92672>></span><span> parse helloOrHowdy2 </span><span style=color:#e6db74>"boo!"
</span><span style=color:#ae81ff>Left </span><span style=color:#e6db74>"(source)"</span><span> (line </span><span style=color:#ae81ff>1</span><span>, column </span><span style=color:#ae81ff>1</span><span>)</span><span style=color:#f92672>:
</span><span>unexpected </span><span style=color:#e6db74>"b"
</span><span>expecting </span><span style=color:#e6db74>"hello"</span><span> or </span><span style=color:#e6db74>"howdy"
</span><span>ghci</span><span style=color:#f92672>></span><span> parse helloOrHowdy2 </span><span style=color:#e6db74>"hellay"
</span><span style=color:#ae81ff>Left </span><span style=color:#e6db74>"(source)"</span><span> (line </span><span style=color:#ae81ff>1</span><span>, column </span><span style=color:#ae81ff>1</span><span>)</span><span style=color:#f92672>:
</span><span>unexpected </span><span style=color:#e6db74>"e"
</span><span>expecting </span><span style=color:#e6db74>"howdy"
</span></code></pre><h2 id=creating-your-own-error-messages-with>Creating your own error messages with <code>&LT?></code></h2><p>Sometimes, often when building up your own rules, you want to use your own custom error messages in case of parsing failure. <code>&LT?></code> allows you to attach a custom error to any rule quite simply. Let's see it in action:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>ghci</span><span style=color:#f92672>></span><span> parse (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>string </span><span style=color:#e6db74>"hello"</span><span>) </span><span style=color:#e6db74>"wrongstring"
</span><span style=color:#ae81ff>Left </span><span style=color:#e6db74>"(source)"</span><span> (line </span><span style=color:#ae81ff>1</span><span>, column </span><span style=color:#ae81ff>1</span><span>)</span><span style=color:#f92672>:
</span><span>unexpected </span><span style=color:#e6db74>"w"
</span><span>expecting </span><span style=color:#e6db74>"hello"
</span><span>ghci</span><span style=color:#f92672>></span><span> parse (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>string </span><span style=color:#e6db74>"hello" </span><span style=color:#f92672>&LT?> </span><span style=color:#e6db74>"a common greeting"</span><span>) </span><span style=color:#e6db74>"wrongstring"
</span><span style=color:#ae81ff>Left </span><span style=color:#e6db74>"(source)"</span><span> (line </span><span style=color:#ae81ff>1</span><span>, column </span><span style=color:#ae81ff>1</span><span>)</span><span style=color:#f92672>:
</span><span>unexpected </span><span style=color:#e6db74>"w"
</span><span>expecting a common greeting
</span></code></pre><p>Here, we simply attach a new error message to the rule we create from <code>Parsec.string</code>. <code>&LT?></code> has the lowest precedence possible, which means that anything else will evaluate first. Attaching a new error message to the end of a chain of rules created with <code><|></code> for instance will result in that error being used if all of the rules fail <em>without consuming any input</em>, as then the rule generated from the <code><|></code> chain has failed. As soon as a rule consumes input, it becomes up to the error reporting of that rule to describe future failure (unless of course a try block surrounds the rule, which suppresses error messages from it). This basic example illustrates the fact:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>ghci</span><span style=color:#f92672>> </span><span style=color:#75715e>-- this fails without consuming any input:
</span><span>ghci</span><span style=color:#f92672>></span><span> parse (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>string </span><span style=color:#e6db74>"apple" </span><span style=color:#f92672><|> </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>string </span><span style=color:#e6db74>"bat" </span><span style=color:#f92672>&LT?> </span><span style=color:#e6db74>"boom!"</span><span>) </span><span style=color:#e6db74>"cat"
</span><span style=color:#ae81ff>Left </span><span style=color:#e6db74>"(source)"</span><span> (line </span><span style=color:#ae81ff>1</span><span>, column </span><span style=color:#ae81ff>1</span><span>)</span><span style=color:#f92672>:
</span><span>unexpected </span><span style=color:#e6db74>"c"
</span><span>expecting boom</span><span style=color:#f92672>!
</span><span>ghci</span><span style=color:#f92672>> </span><span style=color:#75715e>-- this consumes input before failing:
</span><span>ghci</span><span style=color:#f92672>></span><span> parse (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>string </span><span style=color:#e6db74>"apple" </span><span style=color:#f92672><|> </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>string </span><span style=color:#e6db74>"bat" </span><span style=color:#f92672>&LT?> </span><span style=color:#e6db74>"boom!"</span><span>) </span><span style=color:#e6db74>"aunty"
</span><span style=color:#ae81ff>Left </span><span style=color:#e6db74>"(source)"</span><span> (line </span><span style=color:#ae81ff>1</span><span>, column </span><span style=color:#ae81ff>1</span><span>)</span><span style=color:#f92672>:
</span><span>unexpected </span><span style=color:#e6db74>"u"
</span><span>expecting </span><span style=color:#e6db74>"apple"
</span></code></pre><p>If you'd like to provide a single custom error message for a rule you've created, you can incase the rule in a <code>try</code> to catch any errors that would otherwise originate from it, and instead provide your own in the event that the rule fails. Here's a simple example doing just that:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- here we parse a basic greeting with no custom errors:
</span><span style=color:#a6e22e>greeting </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Parsec</span><span>.</span><span style=font-style:italic;color:#66d9ef>Parsec String </span><span style=color:#66d9ef>() </span><span style=font-style:italic;color:#66d9ef>String
</span><span>greeting </span><span style=color:#f92672>= do
</span><span>	</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>char </span><span style=color:#e6db74>'h'
</span><span>	</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>string </span><span style=color:#e6db74>"olla" </span><span style=color:#f92672><|> </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>string </span><span style=color:#e6db74>"ello"
</span><span>	return </span><span style=color:#e6db74>"greeting"
</span><span>
</span><span style=color:#75715e>--parse the same greeting, but wrap in try and add custom error:
</span><span style=color:#a6e22e>greeting2 </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Parsec</span><span>.</span><span style=font-style:italic;color:#66d9ef>Parsec String </span><span style=color:#66d9ef>() </span><span style=font-style:italic;color:#66d9ef>String
</span><span>greeting2 </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>try greeting </span><span style=color:#f92672>&LT?> </span><span style=color:#e6db74>"a greeting!"
</span></code></pre><p>This is not recommended for more significant rules as it would replace precise error messages from sub rules with some general and less helpful error. However, when building small rules it can be more descriptive to provide your own error over those <code>Parsec</code> provides.<h1 id=applicative-functions-for-more-concise-parsing>Applicative functions for more concise parsing</h1><p>The module <code>Control.Applicative</code> imports several functions, mostly infix operators, that can help make your rules more concise and readable in the right situations. It turns out that we've already been using one such operator, <code><|></code>, already! Applicative functions often make code shorter, since they are all about being point-free, that is, not making explicit references to the variables being passed around.<p>Let's convert our original pair parser to applicative style and then run over what each operator does:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- lets start again with our first parser to parse a letter/digit pair:
</span><span style=color:#a6e22e>myParser </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Parsec</span><span>.</span><span style=font-style:italic;color:#66d9ef>Parsec String </span><span style=color:#66d9ef>()</span><span> (</span><span style=font-style:italic;color:#66d9ef>String</span><span>,</span><span style=font-style:italic;color:#66d9ef>String</span><span>)
</span><span>myParser </span><span style=color:#f92672>= do
</span><span>	letters </span><span style=color:#f92672>&LT- </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>many1 </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>letter
</span><span>	</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>spaces
</span><span>	digits </span><span style=color:#f92672>&LT- </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>many1 </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>digit
</span><span>	return (letters,digits)
</span><span>
</span><span style=color:#75715e>-- in applicative style:
</span><span style=color:#a6e22e>myParserApp </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Parsec</span><span>.</span><span style=font-style:italic;color:#66d9ef>Parsec String </span><span style=color:#66d9ef>()</span><span> (</span><span style=font-style:italic;color:#66d9ef>String</span><span>,</span><span style=font-style:italic;color:#66d9ef>String</span><span>)
</span><span>myParserApp </span><span style=color:#f92672>= </span><span style=color:#a6e22e>(,) </span><span style=color:#f92672><$> </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>many1 </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>letter </span><span style=color:#f92672><</span><span>*</span><span style=color:#f92672>></span><span> (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>spaces *</span><span style=color:#f92672>> </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>many1 </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>digit)
</span><span>
</span><span style=color:#75715e>-- could also be written as:
</span><span style=color:#a6e22e>myParserApp2 </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Parsec</span><span>.</span><span style=font-style:italic;color:#66d9ef>Parsec String </span><span style=color:#66d9ef>()</span><span> (</span><span style=font-style:italic;color:#66d9ef>String</span><span>,</span><span style=font-style:italic;color:#66d9ef>String</span><span>)
</span><span>myParserApp2 </span><span style=color:#f92672>=</span><span> liftA2 </span><span style=color:#a6e22e>(,)</span><span> (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>many1 </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>letter) (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>spaces *</span><span style=color:#f92672>> </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>many1 </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>digit)
</span><span>
</span><span style=color:#75715e>-- or even (swapping *> for the more familiar >>):
</span><span style=color:#a6e22e>myParserApp </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Parsec</span><span>.</span><span style=font-style:italic;color:#66d9ef>Parsec String </span><span style=color:#66d9ef>()</span><span> (</span><span style=font-style:italic;color:#66d9ef>String</span><span>,</span><span style=font-style:italic;color:#66d9ef>String</span><span>)
</span><span>myParserApp2 </span><span style=color:#f92672>=</span><span> liftA2 </span><span style=color:#a6e22e>(,)</span><span> (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>many1 </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>letter) (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>spaces </span><span style=color:#f92672>>> </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>many1 </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>digit)
</span><span>
</span></code></pre><p>Let's run through the main applicative operators one by one and see what they each actually do:<h2 id=and><code><$></code> and <code><*></code></h2><p>This operator is essentially <code>fmap</code>. it takes a function on the left and a rule on the right, and applies the function to the result of the rule (provided the rule succeeds, otherwise we get a parse error instead) before returning. If we want to apply the function to more than one argument, we separate the arguments wih <*>. lets run through a couple of examples in ghci:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>ghci</span><span style=color:#f92672>> </span><span style=color:#75715e>-- apply the result to a tuple constructor:
</span><span>ghci</span><span style=color:#f92672>></span><span> parse (</span><span style=color:#a6e22e>(,) </span><span style=color:#f92672><$> </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>char </span><span style=color:#e6db74>'a' </span><span style=color:#f92672><</span><span>*</span><span style=color:#f92672>> </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>char </span><span style=color:#e6db74>'b'</span><span>) </span><span style=color:#e6db74>"ab"
</span><span style=color:#ae81ff>Right</span><span> (</span><span style=color:#e6db74>'a'</span><span>,</span><span style=color:#e6db74>'b'</span><span>)
</span><span>ghci</span><span style=color:#f92672>> </span><span style=color:#75715e>-- put the result into an array:
</span><span>ghci</span><span style=color:#f92672>></span><span> parse ((</span><span style=color:#f92672>\</span><span>a b </span><span style=color:#f92672>-></span><span> [a,b]) </span><span style=color:#f92672><$> </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>char </span><span style=color:#e6db74>'a' </span><span style=color:#f92672><</span><span>*</span><span style=color:#f92672>> </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>char </span><span style=color:#e6db74>'b'</span><span>) </span><span style=color:#e6db74>"ab"
</span><span style=color:#ae81ff>Right </span><span style=color:#e6db74>"ab"
</span></code></pre><p>The neat thing about this is that you can chain as many arguments as you need to the function by adding <code><*></code>'s to the end.<h2 id=liftax><code>liftAx</code></h2><p>A prefix version of the above, <code>liftAx</code> takes <em>x</em> number of subsequent arguments and applies them to the first. Not as flexible as the infix versions but there may be times when it is more readable. Here are the same examples as above with lift:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>ghci</span><span style=color:#f92672>> </span><span style=color:#75715e>-- apply the result to a tuple constructor:
</span><span>ghci</span><span style=color:#f92672>></span><span> parse (liftA2 </span><span style=color:#a6e22e>(,)</span><span> (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>char </span><span style=color:#e6db74>'a'</span><span>) (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>char </span><span style=color:#e6db74>'b'</span><span>)) </span><span style=color:#e6db74>"ab"
</span><span style=color:#ae81ff>Right</span><span> (</span><span style=color:#e6db74>'a'</span><span>,</span><span style=color:#e6db74>'b'</span><span>)
</span><span>ghci</span><span style=color:#f92672>> </span><span style=color:#75715e>-- put the result into an array:
</span><span>ghci</span><span style=color:#f92672>></span><span> parse (liftA2 (</span><span style=color:#f92672>\</span><span>a b </span><span style=color:#f92672>-></span><span> [a,b]) (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>char </span><span style=color:#e6db74>'a'</span><span>) (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>char </span><span style=color:#e6db74>'b'</span><span>)) </span><span style=color:#e6db74>"ab"
</span><span style=color:#ae81ff>Right </span><span style=color:#e6db74>"ab"
</span></code></pre><h2 id=and-1><code><*</code> and <code>*></code></h2><p>Sometimes you want to run some rules, discarding the results of all but one. These operators each take two rules and return the result of the one that the angle bracket points to. Examples:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>ghci</span><span style=color:#f92672>></span><span> parse (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>char </span><span style=color:#e6db74>'a' </span><span style=color:#f92672><</span><span>* </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>char </span><span style=color:#e6db74>'b'</span><span>) </span><span style=color:#e6db74>"ab"
</span><span style=color:#ae81ff>Right </span><span style=color:#e6db74>'a'
</span><span>ghci</span><span style=color:#f92672>></span><span> parse (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>char </span><span style=color:#e6db74>'a'</span><span> *</span><span style=color:#f92672>> </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>char </span><span style=color:#e6db74>'b'</span><span>) </span><span style=color:#e6db74>"ab"
</span><span style=color:#ae81ff>Right </span><span style=color:#e6db74>'b'
</span></code></pre><p>They can also be chained in such a way that you can ignore several rules:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>ghci</span><span style=color:#f92672>></span><span> parse (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>char </span><span style=color:#e6db74>'a' </span><span style=color:#f92672><</span><span>* </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>char </span><span style=color:#e6db74>'b' </span><span style=color:#f92672><</span><span>* </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>char </span><span style=color:#e6db74>'c'</span><span>) </span><span style=color:#e6db74>"abc"
</span><span style=color:#ae81ff>Right </span><span style=color:#e6db74>'a'
</span><span>ghci</span><span style=color:#f92672>></span><span> parse (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>char </span><span style=color:#e6db74>'a'</span><span> *</span><span style=color:#f92672>> </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>char </span><span style=color:#e6db74>'b' </span><span style=color:#f92672><</span><span>* </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>char </span><span style=color:#e6db74>'c'</span><span>) </span><span style=color:#e6db74>"abc"
</span><span style=color:#ae81ff>Right </span><span style=color:#e6db74>'b'
</span><span>ghci</span><span style=color:#f92672>></span><span> parse (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>char </span><span style=color:#e6db74>'a'</span><span> *</span><span style=color:#f92672>> </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>char </span><span style=color:#e6db74>'b'</span><span> *</span><span style=color:#f92672>> </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>char </span><span style=color:#e6db74>'c'</span><span>) </span><span style=color:#e6db74>"abc"
</span><span style=color:#ae81ff>Right </span><span style=color:#e6db74>'c'
</span></code></pre><p>And often some in handy when you want to do things like trim whitespace or other bits and pieces from around some piece of information.<h2><code><$</code></h2><p>Runs the rule on the right, and then returns whatever is on the left if the rule succeeds. Let's see it in action along with some equivalent ways to do the same thing:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>ghci</span><span style=color:#f92672>></span><span> parse (</span><span style=color:#e6db74>"greeting!" </span><span style=color:#f92672><$ </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>string </span><span style=color:#e6db74>"hello"</span><span>) </span><span style=color:#e6db74>"hello"
</span><span style=color:#ae81ff>Right </span><span style=color:#e6db74>"greeting!"
</span><span>ghci</span><span style=color:#f92672>></span><span> parse (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>string </span><span style=color:#e6db74>"hello" </span><span style=color:#f92672>>></span><span> return </span><span style=color:#e6db74>"greeting!"</span><span>) </span><span style=color:#e6db74>"hello"
</span><span style=color:#ae81ff>Right </span><span style=color:#e6db74>"greeting!"
</span><span>ghci</span><span style=color:#f92672>></span><span> parse (return </span><span style=color:#e6db74>"greeting!" </span><span style=color:#f92672><</span><span>* </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>string </span><span style=color:#e6db74>"hello"</span><span>) </span><span style=color:#e6db74>"hello"
</span></code></pre><p>As you can see, there are no shortage of different ways to do things! I can see myself using the more obvious second example most often despite it being a few extra characters from the first, but whatever floats you boat!<h1 id=handling-state>Handling state</h1><p>More recently I learned that you can thread state through your parsers as well (thanks Chobbsy!). This is useful for keeping track of things like amount of indentation. Here is a very basic example using state to count a letter:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- matches char 'h', incrementing int state by 1
</span><span style=color:#75715e>-- each time one is seen.
</span><span style=color:#a6e22e>hCountParser </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Parsec</span><span>.</span><span style=font-style:italic;color:#66d9ef>Parsec String Int </span><span style=color:#66d9ef>()
</span><span>hCountParser </span><span style=color:#f92672>= do
</span><span>	</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>char </span><span style=color:#e6db74>'h'
</span><span>	c </span><span style=color:#f92672>&LT- </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>getState
</span><span>	</span><span style=color:#f92672>let</span><span> c' </span><span style=color:#f92672>=</span><span> c</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1
</span><span>	</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>putState c'
</span><span>	return </span><span style=color:#ae81ff>()
</span><span>
</span><span style=color:#75715e>-- parse as many h's as we can, then return the state
</span><span style=color:#75715e>-- to see how many there were
</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>runParser (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>many hCountParser </span><span style=color:#f92672>>> </span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>getState) </span><span style=color:#ae81ff>0 </span><span style=color:#e6db74>"" "hhhhhhhhhhhhellooo"
</span></code></pre><p>As well as getting and setting, we can use <code>Parsec.modifyState</code> to modify state in place. Thus, a simpler version of <code>hCountParser</code> would be:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>hCountParser' </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Parsec</span><span>.</span><span style=font-style:italic;color:#66d9ef>Parsec String Int </span><span style=color:#66d9ef>()
</span><span>hCountParser' </span><span style=color:#f92672>= do
</span><span>	</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>char </span><span style=color:#e6db74>'h'
</span><span>	</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>modifyState (</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span><span>)
</span><span>	return </span><span style=color:#ae81ff>()
</span></code></pre><p>It's worth noting however that being a monad transformer, we also have the option of combining a parser with something like the <code>State</code> monad for instance in order to thread state through it in an approach that is more consistent with the monad transformer way of doing things. Using the <code>State</code> Monad instead, we would have something like:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>import </span><span>Control.Monad       (</span><span style=color:#a6e22e>lift</span><span>)
</span><span style=color:#f92672>import </span><span>Control.Monad.State </span><span style=color:#f92672>as </span><span>S
</span><span>
</span><span style=color:#a6e22e>hCountParser'' </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Parsec</span><span>.</span><span style=font-style:italic;color:#66d9ef>ParsecT String </span><span style=color:#66d9ef>()</span><span> (</span><span style=font-style:italic;color:#66d9ef>S</span><span>.</span><span style=font-style:italic;color:#66d9ef>State Int</span><span>) </span><span style=color:#66d9ef>()
</span><span>hCountParser'' </span><span style=color:#f92672>= do
</span><span>	char </span><span style=color:#e6db74>'h'
</span><span>	lift </span><span style=color:#f92672>$</span><span> modify (</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span><span>)
</span><span>
</span><span style=color:#75715e>-- after running our parser transformer, we get back our unevaluated inner state, which
</span><span style=color:#75715e>-- contains our parser result and state ('h' count). We only want the state so
</span><span style=color:#75715e>-- we use execState rather than runState or evalState to execute and unwrap the state monad,
</span><span style=color:#75715e>-- providing an initial state to start the ball rolling.
</span><span style=color:#ae81ff>S</span><span style=color:#f92672>.</span><span>execState (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>runParserT (</span><span style=color:#ae81ff>Parsec</span><span style=color:#f92672>.</span><span>many hCountParser2) </span><span style=color:#ae81ff>() </span><span style=color:#e6db74>"" "hhhhhhhhhhhhellooo"</span><span>) </span><span style=color:#ae81ff>0
</span><span>
</span></code></pre><h1 id=wrapping-things-up>Wrapping Things up</h1><p>We have wandered through some of the built in functions and rules provided. We've then looked at combining rules to build larger ones, branching by way of allowing a choice of rules, lookahead by way of <code>try</code>, and finally adding custom error messages to your rules and had a quick play with maintaining state. Armed with the above, you should be off to a good start!<p>I encourage you to peruse <code>Parsec</code> functions in <code>ghci</code> by importing the <code>Parsec</code> module under some alias (or qualified as I have done) and using tab complete to get a list of everything that <code>Parsec</code> provides. using <code>:type</code> on these can provide further insight, and forms the basis for how I explored my way through many of the available functions. The chapter <a href=http://book.realworldhaskell.org/read/using-parsec.html>here</a> at <em>Real World Haskell</em> is also excellent and runs through far more substantial examples, though note that some small pieces are a little out of date.<p>I hope that this has been helpful! If I've left anything out, please leave a comment and let me know!</div></div></section><footer></footer></div><script src=https://jsdw.me/page.js></script>