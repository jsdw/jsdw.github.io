<!doctype html><html><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><title>
    jsdw - Rick Astley Inspired Self-decompressing Text Compressor
</title><link href="https://fonts.googleapis.com/css?family=IBM+Plex+Serif|Open+Sans" rel=stylesheet><link href=https://jsdw.me/app.css rel=stylesheet><link href=https://jsdw.me/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><link href=https://jsdw.me/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=https://jsdw.me/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=https://jsdw.me/site.webmanifest rel=manifest><link color=#5bbad5 href=https://jsdw.me/safari-pinned-tab.svg rel=mask-icon><meta content=#f9409c name=msapplication-TileColor><meta content=#ffffff name=theme-color><body><div class="body post"><header><div class=title-inner><div class=jsdw><a href=https://jsdw.me>JSDW</a></div><nav><a href=https://jsdw.me/posts/>posts</a><a href=https://jsdw.me/projects/>projects</a></nav></div></header><section><div class=top><div class=top-scene><svg class="polygon two" viewbox="0 0 100 100" height=100% style=fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421 version=1.1 width=100% xml:space=preserve xmlns=http://www.w3.org/2000/svg xmlns:serif=http://www.serif.com/ xmlns:xlink=http://www.w3.org/1999/xlink><polygon points="0 100, 15 40, 60 0, 100 30"/></svg><svg class="polygon one" viewbox="0 0 100 100" height=100% style=fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421 version=1.1 width=100% xml:space=preserve xmlns=http://www.w3.org/2000/svg xmlns:serif=http://www.serif.com/ xmlns:xlink=http://www.w3.org/1999/xlink><polygon points="0 40, 30 0, 80 33, 100 100"/></svg></div><div class=top-inner><h1 class=title>Rick Astley Inspired Self-decompressing Text Compressor <span class=date>2013-05-15</span></h1></div></div><div class=content-inner><div class=post><p>After a friend directed me to <a href=http://codegolf.stackexchange.com/questions/6043/were-no-strangers-to-code-golf-you-know-the-rules-and-so-do-i>this</a> code golf on Stack Exchange, I thought I'd have a quick go myself at implementing a Javascript version. Here it is:<pre class=language-txt data-lang=txt style=background:#272822;color:#f8f8f2><code class=language-txt data-lang=txt><span>s="We'r7n6strangers@6loV3 L@h7rules>s6d6I2AJull commitment's;K@hink= of3 wTldn't?et@hisJromBny9?uy.+P4n-2AU if5Bsk m71Don'tF me58bliU t6see++PESS0QE0QP4-P.+++*PMRup/letRdown/runBrTU>desert5/makeRcry/say?oodbye/tellB lie>hurt5*,* each9Jor s6long3r heart:nBch= but38shy@6say it2Insid7w7both L;:n?o= on2W7L@he?ame>we're< play it*2I just wannaFR1Gotta makeRuUerstaU*2NH *)M, nHC2(GiV*howKJeel=2*\n*2YT*2We'V L* yT*o *e *'re@o6* other*'s bee* what*?onna*ing*BU * g* t*A* a*?iV*D*2(Ooh*@ell*G*eVr<*I* f* I'm*know*2NHC*N*O*2 *Rup)*5 *,CQE*ou*nd*ve";for(c=0;c&LT45;)d=s.split('*'),s=s.split(String.fromCharCode(c+43)).join(d[++c]);d[0]
</span></code></pre><p>Try running it in the developers console in your web browser to see what it does.<h1 id=what-s-going-on>What's going on?</h1><p>So, the above code is 625 bytes in length. It's not the shortest possible length by a fair way, but the code to generate it is relatively fast (for a relatively small amount of text anyway), so it's a reasonable compromise. You can have a play and compress your own text to evaluatable Javascript <a href=/projects/rickastley/>here</a>.<p>With better spacing and use of Javascript, the above code looks like this:<pre class=language-javascript data-lang=javascript style=background:#272822;color:#f8f8f2><code class=language-javascript data-lang=javascript><span>s</span><span style=color:#f92672>=</span><span style=color:#e6db74>"We'r7n6strangers@6loV3 L@h7rules>s6d6I2AJull commitment's;K@hink= of3 wTldn't?et@hisJromBny9?uy.+P4n-2AU if5Bsk m71Don'tF me58bliU t6see++PESS0QE0QP4-P.+++*PMRup/letRdown/runBrTU>desert5/makeRcry/say?oodbye/tellB lie>hurt5*,* each9Jor s6long3r heart:nBch= but38shy@6say it2Insid7w7both L;:n?o= on2W7L@he?ame>we're< play it*2I just wannaFR1Gotta makeRuUerstaU*2NH *)M, nHC2(GiV*howKJeel=2*</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>*2YT*2We'V L* yT*o *e *'re@o6* other*'s bee* what*?onna*ing*BU * g* t*A* a*?iV*D*2(Ooh*@ell*G*eVr<*I* f* I'm*know*2NHC*N*O*2 *Rup)*5 *,CQE*ou*nd*ve"</span><span>;
</span><span>
</span><span style=color:#f92672>for</span><span>(c</span><span style=color:#f92672>=</span><span style=color:#ae81ff>0</span><span>;c</span><span style=color:#f92672><</span><span style=color:#ae81ff>47</span><span>;c</span><span style=color:#f92672>++</span><span>) {
</span><span>	d</span><span style=color:#f92672>=</span><span>s.</span><span style=color:#66d9ef>split</span><span>(</span><span style=color:#e6db74>'*'</span><span>);
</span><span>	s</span><span style=color:#f92672>=</span><span>s.</span><span style=color:#66d9ef>split</span><span>(</span><span style=font-style:italic;color:#66d9ef>String</span><span>.</span><span style=color:#66d9ef>fromCharCode</span><span>(c</span><span style=color:#f92672>+</span><span style=color:#ae81ff>43</span><span>)).</span><span style=color:#66d9ef>join</span><span>(d[c</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span><span>]);
</span><span>}
</span><span>
</span><span>d[</span><span style=color:#ae81ff>0</span><span>];
</span></code></pre><p>And works by doing the following:<pre class=language-txt data-lang=txt style=background:#272822;color:#f8f8f2><code class=language-txt data-lang=txt><span>while C is less than 47
</span><span>	split the string S into array D using "*" as the delimiter.
</span><span>	split the string S into array TMP using the charcode C+43 as the delimiter.
</span><span>	join array TMP back into string S, inserting D[C+1] between each element.
</span><span>	increment C
</span><span>evaluate D[0]
</span></code></pre><p>which can be more simply written as:<pre class=language-txt data-lang=txt style=background:#272822;color:#f8f8f2><code class=language-txt data-lang=txt><span>while C is less than 47
</span><span>	split the string S into array D using "*" as the delimiter.
</span><span>	replace all instances of character with code C+43 in S with string d[C+1]
</span><span>	increment C
</span><span>evaluate D[0]
</span></code></pre><p>By spliting a string into an array using a certain delimiter, and then joining it back into a string using a given string, we are just replacing all instances of a character with a desired string, so the two pseudocodes are equivalent.<h2 id=what-does-this-achieve>What Does This Achieve?</h2><p>Essentially, the string <code>s</code> is created by recursively looking over some input (in this case, lyrics to the Rick Astley song "Never Gonna Give You Up"), extracting substrings that repeat, and creating rules which map some new symbol onto the substring. Rules take the form <code>[rule_symbol] -> [substring]</code>. The symbols used to represent a rule is then used in place of any occurrence of the substring that it maps to. As such, when we replace all of the rule symbols with the substrings that they map onto (baring in mind that these substrings can themselves be composed of other rule symbols), we end up back with our original string. This is the basic idea behind grammar compression schemes; we find sequences of characters which repeat, and replace them with some new symbol, so that we only need to represent those characters once in a rule, rather than multiple times in the original string.<p>The symbols used to represent rules are themselves just regular ascii characters, starting from a predefined character code (in the above case 43). If a character code that we want to use as a rule symbol is already used in the original text as a regular character, we create a <em>dummy</em> rule <code>[character] -> [character]</code>, which maps the character to itself. As such, when we substitute our rule symbols for whatever they map too, we don't mess up any of the original characters.<h2 id=creating-rules-the-repair-algorithm>Creating Rules: the RePair Algorithm</h2><p>To create the rules, I implemented a quick and dirty version of the RePair algorithm, which finds repetition by looking at pairs of characters that repeat, and at each stage turning the most frequently occurring pair of characters into a rule, until there is no more repetition. This algorithm is very similar to Sequitur, which I have <a href=https://jsdw.me/posts/rickastley-compressor/./posts/sequitur/index.md>described previously</a>, except it looks at blocks of characters rather than working sequentially over a stream of characters.<p>Some basic pseudocode for RePair might look like this:<pre class=language-txt data-lang=txt style=background:#272822;color:#f8f8f2><code class=language-txt data-lang=txt><span>let s be our original string
</span><span>let r be our rules
</span><span>
</span><span>while there is repetition
</span><span>	find the pair of characters that repeats the most in s
</span><span>	create a rule representing this pair
</span><span>	replace all instances of this pair with the rule symbol
</span><span>
</span><span>remove all rules that are only used once
</span></code></pre><p>After creating rules, I order them in terms of the amount that they save, and remove any rules that do not save me anything (taking into account the extra cost of any dummy rules we need to make to preserve the original characters). I then join them onto my string (which itself has been replaced in many parts with rule symbols). The symbols used to represent rules are then selected such that the symbol for each rule relates to its location in the string. As such, when we split the string by our delimiter (in the above case "*"), we know where to look for each rule.<p>Finally, given that we have a means to convert a compressed string back into the original, I just needed to find the shortest amount of Javascript code that would do this for me, eventually arriving at the code I have displayed here.<h1 id=final-remarks>Final Remarks</h1><p>The RePair implementation does find the rules which lead to the greatest compression of the original string unfortunately, as other variants of this algorithm have compressed the string to a greater extent than I managed with RePair. Using an alternative algorithm for generating the rules would lead to greater compression.<p>That said, my implementation, while horribly inefficient, was still relatively fast for this short task, unlike some of the alternatives used to find the optimal rules. You can have a play with my implementation <a href=/projects/rickastley/>here</a>, to generate your own compressed strings.</div></div></section><footer></footer></div><script src=https://jsdw.me/page.js></script>