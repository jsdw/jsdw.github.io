<!doctype html><html><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><title>
    jsdw - Haskell: Some Awesome Language Extensions Explained
</title><link href="https://fonts.googleapis.com/css?family=IBM+Plex+Serif|Open+Sans" rel=stylesheet><link href=https://jsdw.me/app.css rel=stylesheet><link href=https://jsdw.me/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><link href=https://jsdw.me/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=https://jsdw.me/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=https://jsdw.me/site.webmanifest rel=manifest><link color=#5bbad5 href=https://jsdw.me/safari-pinned-tab.svg rel=mask-icon><meta content=#f9409c name=msapplication-TileColor><meta content=#ffffff name=theme-color><body><div class="body post"><header><div class=title-inner><div class=jsdw><a href=https://jsdw.me>JSDW</a></div><nav><a href=https://jsdw.me/posts/>posts</a><a href=https://jsdw.me/projects/>projects</a></nav></div></header><section><div class=top><div class=top-scene><svg class="polygon two" viewbox="0 0 100 100" height=100% style=fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421 version=1.1 width=100% xml:space=preserve xmlns=http://www.w3.org/2000/svg xmlns:serif=http://www.serif.com/ xmlns:xlink=http://www.w3.org/1999/xlink><polygon points="0 100, 15 40, 60 0, 100 30"/></svg><svg class="polygon one" viewbox="0 0 100 100" height=100% style=fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421 version=1.1 width=100% xml:space=preserve xmlns=http://www.w3.org/2000/svg xmlns:serif=http://www.serif.com/ xmlns:xlink=http://www.w3.org/1999/xlink><polygon points="0 40, 30 0, 80 33, 100 100"/></svg></div><div class=top-inner><h1 class=title>Haskell: Some Awesome Language Extensions Explained <span class=date>2015-08-22</span></h1></div></div><div class=content-inner><div class=post><div class=table-of-contents><ul><li><a href=https://jsdw.me/posts/haskell-language-extensions/#viewpatterns>ViewPatterns</a><li><a href=https://jsdw.me/posts/haskell-language-extensions/#patternsynonyms>PatternSynonyms</a><li><a href=https://jsdw.me/posts/haskell-language-extensions/#flexibleinstances>FlexibleInstances</a><li><a href=https://jsdw.me/posts/haskell-language-extensions/#multiparamtypeclasses>MultiParamTypeClasses</a><li><a href=https://jsdw.me/posts/haskell-language-extensions/#functionaldependencies>FunctionalDependencies</a><li><a href=https://jsdw.me/posts/haskell-language-extensions/#overlappinginstances>OverlappingInstances</a><li><a href=https://jsdw.me/posts/haskell-language-extensions/#existentialquantification>ExistentialQuantification</a><li><a href=https://jsdw.me/posts/haskell-language-extensions/#gadts>GADTs</a><li><a href=https://jsdw.me/posts/haskell-language-extensions/#implicitparams>ImplicitParams</a><li><a href=https://jsdw.me/posts/haskell-language-extensions/#typefamilies>TypeFamilies</a><li><a href=https://jsdw.me/posts/haskell-language-extensions/#kindsignatures>KindSignatures</a><li><a href=https://jsdw.me/posts/haskell-language-extensions/#datakinds>DataKinds</a><li><a href=https://jsdw.me/posts/haskell-language-extensions/#typeoperators>TypeOperators</a><li><a href=https://jsdw.me/posts/haskell-language-extensions/#polykinds>PolyKinds</a><li><a href=https://jsdw.me/posts/haskell-language-extensions/#constraintkinds>ConstraintKinds</a><li><a href=https://jsdw.me/posts/haskell-language-extensions/#the-end-for-now>The End (for now)</a></ul></div><p>Haskell language extensions each add something new to the language. Unlike most languages where such extensions would typically be discouraged for reasons of support, stability or unstable API, many haskell extensions have been around for a while, are used often, and will probably make it into some future revision of the Haskell language spec.<p>Let's take a look at some of the haskell extensions out there and see what they are good for. This is going to be code heavy, as it is mostly a translation of example code and comments to structured blog post, and I expect I'll update it as I come across more extensions I find interesting!<blockquote><p>Go <a href=https://jsdw.me/posts/haskell-language-extensions/examples.hs>here</a> to get all of the code used below, ready for you to load straight into GHCI and have a play with. Tested using GHC 7.10.1</blockquote><h1 id=viewpatterns>ViewPatterns</h1><p>View patterns let you run arbitrary computations anywhere you can use a pattern match, performing the actual pattern match on the result of this computation. Lets see what this looks like:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>someList </span><span style=color:#f92672>=</span><span> [(</span><span style=color:#e6db74>"london"</span><span>,</span><span style=color:#ae81ff>10</span><span>), (</span><span style=color:#e6db74>"paris"</span><span>,</span><span style=color:#ae81ff>12</span><span>), (</span><span style=color:#e6db74>"sydney"</span><span>,</span><span style=color:#ae81ff>4</span><span>)]
</span><span>findIn </span><span style=color:#f92672>=</span><span> flip lookup
</span><span>
</span><span style=color:#75715e>-- no view patterns: extract a value from the map, using default if it's not there.
</span><span>getOrDefault name </span><span style=color:#f92672>= case</span><span> mRes </span><span style=color:#f92672>of
</span><span>    </span><span style=color:#ae81ff>Just</span><span> val </span><span style=color:#f92672>-></span><span> val
</span><span>    </span><span style=color:#ae81ff>Nothing </span><span style=color:#f92672>-> </span><span style=color:#ae81ff>5
</span><span>  </span><span style=color:#f92672>where</span><span> mRes </span><span style=color:#f92672>=</span><span> findIn someList name
</span><span>
</span><span style=color:#75715e>-- view patterns: applies input argument to "findIn someList" and looks to see
</span><span style=color:#75715e>-- whether the result matches the pattern Just val. falls to next case if not.
</span><span>getOrDefault' (findIn someList </span><span style=color:#f92672>-> </span><span style=color:#ae81ff>Just</span><span> val) </span><span style=color:#f92672>=</span><span> val
</span><span>getOrDefault' _ </span><span style=color:#f92672>= </span><span style=color:#ae81ff>5
</span></code></pre><p>View patterns can also make use of variables declared before them in the list of arguments to a function. In this case, the <code>list</code> variable:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- no view patterns: take in list as well.
</span><span>getOrDefaultList list name </span><span style=color:#f92672>= case</span><span> mRes </span><span style=color:#f92672>of
</span><span>    </span><span style=color:#ae81ff>Just</span><span> val </span><span style=color:#f92672>-></span><span> val
</span><span>    </span><span style=color:#ae81ff>Nothing </span><span style=color:#f92672>-> </span><span style=color:#ae81ff>5
</span><span>  </span><span style=color:#f92672>where</span><span> mRes </span><span style=color:#f92672>=</span><span> findIn list name
</span><span>
</span><span style=color:#75715e>-- view patterns: partial application can use prior arguments as well:
</span><span>getOrDefaultList' list (findIn list </span><span style=color:#f92672>-> </span><span style=color:#ae81ff>Just</span><span> val) </span><span style=color:#f92672>=</span><span> val
</span><span>getOrDefaultList' _ _ </span><span style=color:#f92672>= </span><span style=color:#ae81ff>5
</span></code></pre><p>They can be arbitrarily nested and exist anywhere a pattern match can:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- no view patterns: use list above to convert values to integers and
</span><span style=color:#75715e>-- sum them up. 0 if not found in list.
</span><span style=color:#75715e>-- eg. sumList ["london","paris"] == 22
</span><span>sumList (a </span><span style=color:#f92672>:</span><span> as) </span><span style=color:#f92672>= case</span><span> mRes </span><span style=color:#f92672>of
</span><span>    </span><span style=color:#ae81ff>Just</span><span> val </span><span style=color:#f92672>-></span><span> val </span><span style=color:#f92672>+</span><span> sumList as
</span><span>    </span><span style=color:#ae81ff>Nothing </span><span style=color:#f92672>-></span><span> sumList as
</span><span>  </span><span style=color:#f92672>where</span><span> mRes </span><span style=color:#f92672>=</span><span> findIn someList a
</span><span>sumList </span><span style=color:#ae81ff>[] </span><span style=color:#f92672>= </span><span style=color:#ae81ff>0
</span><span>
</span><span style=color:#75715e>-- view patterns simplify it a little:
</span><span>sumList' ((findIn someList </span><span style=color:#f92672>-> </span><span style=color:#ae81ff>Just</span><span> val) </span><span style=color:#f92672>:</span><span> as) </span><span style=color:#f92672>=</span><span> val </span><span style=color:#f92672>+</span><span> sumList as
</span><span>sumList' (_ </span><span style=color:#f92672>:</span><span> as) </span><span style=color:#f92672>=</span><span> sumList as
</span><span>sumList' _ </span><span style=color:#f92672>= </span><span style=color:#ae81ff>0
</span></code></pre><h1 id=patternsynonyms>PatternSynonyms</h1><p>Pattern synonyms allow you define aliases for pattern matches. They allow you to abstract away details of your data structure without introducing the extra overhead of converting to other types, and play nice with view patterns too! First we'll declare a few basic types and functions to play with:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>data </span><span style=color:#ae81ff>Day </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Sunday
</span><span>         </span><span style=color:#f92672>| </span><span style=color:#ae81ff>Monday
</span><span>         </span><span style=color:#f92672>| </span><span style=color:#ae81ff>Tuesday
</span><span>         </span><span style=color:#f92672>| </span><span style=color:#ae81ff>Wednesday
</span><span>         </span><span style=color:#f92672>| </span><span style=color:#ae81ff>Thursday
</span><span>         </span><span style=color:#f92672>| </span><span style=color:#ae81ff>Friday
</span><span>         </span><span style=color:#f92672>| </span><span style=color:#ae81ff>Saturday
</span><span>      </span><span style=color:#f92672>deriving</span><span> (</span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>Eq</span><span>,</span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>Show</span><span>)
</span><span>
</span><span style=color:#f92672>data </span><span style=color:#ae81ff>Time </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Time</span><span> {
</span><span>        </span><span style=color:#a6e22e>hour </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Int</span><span>,
</span><span>        </span><span style=color:#a6e22e>minute </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Int
</span><span>    } </span><span style=color:#f92672>deriving</span><span> (</span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>Eq</span><span>,</span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>Show</span><span>)
</span><span>
</span><span style=color:#f92672>data </span><span style=color:#ae81ff>DayTime </span><span style=color:#f92672>= </span><span style=color:#ae81ff>DayTime</span><span> {
</span><span>        </span><span style=color:#a6e22e>day </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Day</span><span>,
</span><span>        </span><span style=color:#a6e22e>time </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Time
</span><span>    } </span><span style=color:#f92672>deriving</span><span> (</span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>Eq</span><span>,</span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>Show</span><span>)
</span><span>
</span><span style=color:#75715e>-- print the time, padding it.
</span><span style=color:#a6e22e>printTime </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Time </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>String
</span><span>printTime (</span><span style=color:#ae81ff>Time</span><span> h m) </span><span style=color:#f92672>=</span><span> pad (show h)</span><span style=color:#f92672>++</span><span style=color:#e6db74>":"</span><span style=color:#f92672>++</span><span>pad (show m)
</span><span>  </span><span style=color:#f92672>where</span><span> pad l@(_</span><span style=color:#f92672>:</span><span>_</span><span style=color:#f92672>:</span><span>_) </span><span style=color:#f92672>=</span><span> l
</span><span>        pad l@(_</span><span style=color:#f92672>:</span><span>_) </span><span style=color:#f92672>= </span><span style=color:#e6db74>"0"</span><span style=color:#f92672>++</span><span>l
</span><span>
</span><span style=color:#75715e>-- a function to print the day and time given a DayTime:
</span><span style=color:#a6e22e>printDayTime </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>DayTime </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>String
</span><span>printDayTime (</span><span style=color:#ae81ff>DayTime</span><span> d t) </span><span style=color:#f92672>= </span><span style=color:#e6db74>"It's "</span><span style=color:#f92672>++</span><span>show d</span><span style=color:#f92672>++</span><span style=color:#e6db74>", "</span><span style=color:#f92672>++</span><span>printTime t
</span></code></pre><p>Now, lets create some basic pattern aliases:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- some simple patterns to act as aliases for certain DayTimes:
</span><span>pattern </span><span style=color:#ae81ff>SundayNoon     </span><span style=color:#f92672>= </span><span style=color:#ae81ff>DayTime Sunday</span><span> (</span><span style=color:#ae81ff>Time 12 00</span><span>)
</span><span>pattern </span><span style=color:#ae81ff>MidnightFriday </span><span style=color:#f92672>= </span><span style=color:#ae81ff>DayTime Friday</span><span> (</span><span style=color:#ae81ff>Time 00 00</span><span>)
</span></code></pre><p>Making use of these in our console:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#ae81ff>Main</span><span style=color:#f92672>></span><span> printDayTime </span><span style=color:#ae81ff>SundayNoon
</span><span style=color:#e6db74>"It's Sunday, 12:00"
</span><span style=color:#ae81ff>Main</span><span style=color:#f92672>></span><span> printDayTime </span><span style=color:#ae81ff>MidnightFriday
</span><span style=color:#e6db74>"It's Friday, 00:00"
</span></code></pre><p>We can use variables in patterns as well:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>pattern </span><span style=color:#ae81ff>Sun</span><span> h m </span><span style=color:#f92672>= </span><span style=color:#ae81ff>DayTime Sunday</span><span>    (</span><span style=color:#ae81ff>Time</span><span> h m)
</span><span>pattern </span><span style=color:#ae81ff>Mon</span><span> h m </span><span style=color:#f92672>= </span><span style=color:#ae81ff>DayTime Monday</span><span>    (</span><span style=color:#ae81ff>Time</span><span> h m)
</span></code></pre><p>These can be used as follows:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#ae81ff>Main</span><span style=color:#f92672>></span><span> printDayTime (</span><span style=color:#ae81ff>Sun 15 30</span><span>)
</span><span style=color:#e6db74>"It's Sunday, 15:30"
</span></code></pre><p>So far, there has been a one to one mapping between pattern and data. Thus, we can treat patterns as if they were data. <code>Sun 12 00 == SundayNoon == DayTime Sunday (Time 12 00)</code>. However, some patterns are one way; one pattern could match many values. One way patterns use <code>&LT-</code> instead of <code>=</code> to denote this.<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- match any DayTime that is sunday or monday using these:
</span><span>pattern </span><span style=color:#ae81ff>AnytimeSun </span><span style=color:#f92672>&LT- </span><span style=color:#ae81ff>DayTime Sunday</span><span> _
</span><span>pattern </span><span style=color:#ae81ff>AnytimeMon </span><span style=color:#f92672>&LT- </span><span style=color:#ae81ff>DayTime Monday</span><span> _
</span><span>
</span><span style=color:#75715e>-- a function that prints the day when given some DayTime value:
</span><span>whichDay </span><span style=color:#ae81ff>AnytimeSun </span><span style=color:#f92672>= </span><span style=color:#e6db74>"Sunday!"
</span><span>whichDay </span><span style=color:#ae81ff>AnytimeMon </span><span style=color:#f92672>= </span><span style=color:#e6db74>"Monday!"
</span><span>whichDay _          </span><span style=color:#f92672>= </span><span style=color:#e6db74>"Some other day!"
</span></code></pre><p>These patterns no longer represent a value but a range of values - anything that matches them - so we can use them in place of function parameters to destructure them, but we cant use them in place of values.<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>main</span><span style=color:#f92672>></span><span> printDayTime </span><span style=color:#ae81ff>AnytimeSun
</span><span style=color:#ae81ff>BZZZT</span><span style=color:#f92672>!</span><span> error</span><span style=color:#f92672>!</span><span> what time should </span><span style=color:#ae81ff>I</span><span> print</span><span style=color:#f92672>??
</span></code></pre><p>We can match the whole daytime as in other pattern matches:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>whichDay' d@</span><span style=color:#ae81ff>AnytimeSun </span><span style=color:#f92672>= </span><span style=color:#e6db74>"Sunday "</span><span style=color:#f92672>++</span><span>printTime (time d)
</span><span>whichDay' d@</span><span style=color:#ae81ff>AnytimeMon </span><span style=color:#f92672>= </span><span style=color:#e6db74>"Monday "</span><span style=color:#f92672>++</span><span>printTime (time d)
</span><span>whichDay' _            </span><span style=color:#f92672>= </span><span style=color:#e6db74>"Other."
</span></code></pre><p>One way patterns can also hand back data in variables which might look a little nicer, especially with complex matches. Here we give <code>t</code> back so that we can make use of it when we destructure someting:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>pattern </span><span style=color:#ae81ff>SunT</span><span> t </span><span style=color:#f92672>&LT- </span><span style=color:#ae81ff>DayTime Sunday</span><span>    t
</span><span>pattern </span><span style=color:#ae81ff>MonT</span><span> t </span><span style=color:#f92672>&LT- </span><span style=color:#ae81ff>DayTime Monday</span><span>    t
</span><span>
</span><span>whichDay'' (</span><span style=color:#ae81ff>SunT</span><span> t) </span><span style=color:#f92672>= </span><span style=color:#e6db74>"Sunday, "</span><span style=color:#f92672>++</span><span>printTime t
</span><span>whichDay'' (</span><span style=color:#ae81ff>MonT</span><span> t) </span><span style=color:#f92672>= </span><span style=color:#e6db74>"Monday, "</span><span style=color:#f92672>++</span><span>printTime t
</span><span>
</span><span style=color:#75715e>--we can of course mix and match pattern synonyms and normal
</span><span style=color:#75715e>--destructuring too. first success wins as normal:
</span><span>whichDay'' (</span><span style=color:#ae81ff>DayTime</span><span> _ t) </span><span style=color:#f92672>= </span><span style=color:#e6db74>"Other day, "</span><span style=color:#f92672>++</span><span>printTime t
</span></code></pre><p>One of the really cool things about <code>PatternSynonyms</code> is that they can be used in conjunction with <code>ViewPatterns</code> to run arbitrarily complex functions at match time. Here we run <code>isMorningHour</code> and see whether the answer matches <code>True</code>:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>isMorningHour t </span><span style=color:#f92672>=</span><span> t </span><span style=color:#f92672>< </span><span style=color:#ae81ff>12
</span><span>
</span><span>pattern </span><span style=color:#ae81ff>Morning </span><span style=color:#f92672>&LT- </span><span style=color:#ae81ff>DayTime</span><span> _ (</span><span style=color:#ae81ff>Time</span><span> (isMorningHour   </span><span style=color:#f92672>-> </span><span style=color:#ae81ff>True</span><span>) _)
</span><span>
</span><span>timeOfDay </span><span style=color:#ae81ff>Morning </span><span style=color:#f92672>= </span><span style=color:#e6db74>"It's morning"
</span><span>timeOfDay _       </span><span style=color:#f92672>= </span><span style=color:#e6db74>"It's not morning"
</span></code></pre><p>View patterns can also give back arbitrary variables. here we expect a tuple of <code>(True,h)</code> back, where we allow <code>h</code> to be made use of at match time.<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>isMorningHour' h </span><span style=color:#f92672>=</span><span> (h </span><span style=color:#f92672>< </span><span style=color:#ae81ff>12</span><span>, h)
</span><span>
</span><span>pattern </span><span style=color:#ae81ff>MorningT</span><span> h m </span><span style=color:#f92672>&LT- </span><span style=color:#ae81ff>DayTime</span><span> _ (</span><span style=color:#ae81ff>Time</span><span> (isMorningHour' </span><span style=color:#f92672>-></span><span> (</span><span style=color:#ae81ff>True</span><span>,h)) m)
</span><span>
</span><span>timeOfDay' (</span><span style=color:#ae81ff>MorningT</span><span> h m) </span><span style=color:#f92672>= </span><span style=color:#e6db74>"It's morning, "</span><span style=color:#f92672>++</span><span>show h</span><span style=color:#f92672>++</span><span style=color:#e6db74>":"</span><span style=color:#f92672>++</span><span>show m
</span><span>timeOfDay' _              </span><span style=color:#f92672>= </span><span style=color:#e6db74>"It's not morning"
</span></code></pre><h1 id=flexibleinstances>FlexibleInstances</h1><p>Allows you to define typeclass instances in a more flexible way. Let's look at the problem they solve by setting up a simple class with a few instances.<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- a simple class for seeing whether something is "truthy"
</span><span style=color:#f92672>class </span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>Truthy </span><span>a </span><span style=color:#f92672>where
</span><span>    </span><span style=color:#a6e22e>truthy </span><span style=color:#f92672>:: </span><span>a </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>Bool
</span><span>
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>Truthy Bool </span><span style=color:#f92672>where
</span><span>    truthy </span><span style=color:#f92672>=</span><span> id
</span><span>
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>Truthy Char </span><span style=color:#f92672>where
</span><span>    truthy c </span><span style=color:#f92672>=</span><span> not </span><span style=color:#f92672>$</span><span> elem c [</span><span style=color:#e6db74>' '</span><span>,</span><span style=color:#e6db74>'</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>'</span><span>,</span><span style=color:#e6db74>'</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>'</span><span>]
</span><span>
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>Truthy Int </span><span style=color:#f92672>where
</span><span>    truthy i </span><span style=color:#f92672>=</span><span> i </span><span style=color:#f92672>/= </span><span style=color:#ae81ff>0
</span></code></pre><p>Without flexible instances, we could not do:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>Truthy String </span><span style=color:#f92672>where
</span><span>    truthy s </span><span style=color:#f92672>=</span><span> length s </span><span style=color:#f92672>/= </span><span style=color:#ae81ff>0
</span></code></pre><p>We'd get told that instance declarations need to take the form <code>T a1..an</code> where <code>a1..an</code> are type <em>variables</em>, but <code>String == [Char] == [] Char</code>, and <code>Char</code> is not a type variable but a fixed type. So basically, <code>[] a</code> would be fine, but <code>[] Char</code> would not. <code>FlexibleInstances</code> removes this restriction, and more generally adds flexibility to the format that your instances can take.<h2 id=avoiding-flexibleinstances-in-some-cases>Avoiding <code>FlexibleInstances</code> (in some cases).</h2><p>An alternate way around the above issue is to enforce that <code>a</code> has to be <code>Char</code> via some constraint, for example:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>class </span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>CharType </span><span>a
</span><span>instance </span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>CharType Char
</span><span>
</span><span>instance </span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>CharType </span><span>a => </span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>Truthy</span><span> [a] </span><span style=color:#f92672>where
</span><span>    truthy s </span><span style=color:#f92672>=</span><span> length s </span><span style=color:#f92672>/= </span><span style=color:#ae81ff>0
</span></code></pre><p>If you wanted to define several instances for lists of different things without <code>FlexibleInstances</code>, you'd end up delegating the behaviour with regard to the items in the array to another (or the same) typeclass's instances for those individual items, for example:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>class </span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>Count </span><span>a </span><span style=color:#f92672>where
</span><span>  </span><span style=color:#a6e22e>countLen </span><span style=color:#f92672>:: </span><span>a </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>Int
</span><span>
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>Count Char </span><span style=color:#f92672>where
</span><span>  countLen a </span><span style=color:#f92672>= </span><span style=color:#ae81ff>1
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>Count Int </span><span style=color:#f92672>where
</span><span>  countLen i </span><span style=color:#f92672>=</span><span> i
</span><span>
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>Count </span><span>a </span><span style=color:#f92672>=> </span><span style=font-style:italic;color:#66d9ef>Count</span><span> [a] </span><span style=color:#f92672>where
</span><span>  countLen as </span><span style=color:#f92672>=</span><span> foldl' (</span><span style=color:#f92672>\</span><span>sum a </span><span style=color:#f92672>-></span><span> sum </span><span style=color:#f92672>+</span><span> countLen a) </span><span style=color:#ae81ff>0</span><span> as
</span></code></pre><p>Here, we treat the items in the array polymorphically by requiriing that they also be instances of <code>Count</code>, and fold over them to sum up the results in either case. Usage:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>main</span><span style=color:#f92672>></span><span> countLen [</span><span style=color:#ae81ff>1</span><span style=color:#f92672>::</span><span style=color:#ae81ff>Int</span><span>,</span><span style=color:#ae81ff>2</span><span>,</span><span style=color:#ae81ff>3</span><span>,</span><span style=color:#ae81ff>4</span><span>]
</span><span style=color:#ae81ff>10
</span><span>main</span><span style=color:#f92672>></span><span> countLen </span><span style=color:#e6db74>"hello"
</span><span style=color:#ae81ff>5
</span></code></pre><p>List types are still bound by the general <code>Count [a]</code> instance here. However if needbe one can delegate all of the behaviour to a separate typeclass for handling, in this example different <code>[]</code> types:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>class </span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>Count </span><span>a </span><span style=color:#f92672>where
</span><span>    </span><span style=color:#a6e22e>countLen </span><span style=color:#f92672>:: </span><span>a </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>Int
</span><span>
</span><span style=color:#75715e>-- catches all array types and delegates
</span><span style=color:#75715e>-- to CountArr based on contained type:
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>CountArr </span><span>a </span><span style=color:#f92672>=> </span><span style=font-style:italic;color:#66d9ef>Count</span><span> [a] </span><span style=color:#f92672>where
</span><span>    countLen as </span><span style=color:#f92672>=</span><span> countLenArr as
</span><span>
</span><span style=color:#75715e>-- handle different underlying types:
</span><span style=color:#f92672>class </span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>CountArr </span><span>a </span><span style=color:#f92672>where
</span><span>    </span><span style=color:#a6e22e>countLenArr </span><span style=color:#f92672>::</span><span> [a] </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>Int
</span><span>
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>CountArr Char </span><span style=color:#f92672>where
</span><span>    countLenArr as </span><span style=color:#f92672>=</span><span> length as
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>CountArr Int </span><span style=color:#f92672>where
</span><span>    countLenArr as </span><span style=color:#f92672>=</span><span> sum as
</span></code></pre><p>Here, running <code>countLen ([1,2,3] :: [Int])</code> for example results in a call being made to the <code>countLenArr</code> instance for <code>Int</code>, and running <code>countLen "hello"</code> the <code>countLenArr</code> instance for <code>Char</code>, each which could have completely independant handling.<h1 id=multiparamtypeclasses>MultiParamTypeClasses</h1><p>Simply, type classes with more than one param allowed (or none!).<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- typeclass with 2 params, a and b.
</span><span style=color:#f92672>class </span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>LooseEq </span><span>a b </span><span style=color:#f92672>where
</span><span>  </span><span style=color:#a6e22e>looseEq </span><span style=color:#f92672>:: </span><span>a </span><span style=color:#f92672>-> </span><span>b </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>Bool
</span><span>
</span><span style=color:#75715e>-- now we can define instances for both
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>LooseEq Int Float </span><span style=color:#f92672>where
</span><span>   looseEq a b </span><span style=color:#f92672>=</span><span> a </span><span style=color:#f92672>==</span><span> round b
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>LooseEq Float Int </span><span style=color:#f92672>where
</span><span>    looseEq a b </span><span style=color:#f92672>=</span><span> round a </span><span style=color:#f92672>==</span><span> b
</span></code></pre><p>Usage:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>main</span><span style=color:#f92672>></span><span> looseEq (</span><span style=color:#ae81ff>10.2 </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>Float</span><span>) (</span><span style=color:#ae81ff>10 </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>Int</span><span>)
</span><span style=color:#ae81ff>True
</span><span>main</span><span style=color:#f92672>></span><span> looseEq (</span><span style=color:#ae81ff>10 </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>Int</span><span>) (</span><span style=color:#ae81ff>10.2 </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>Float</span><span>)
</span><span style=color:#ae81ff>True
</span></code></pre><p>Notice that we have to provide types otherwise the compiler won't know which instance to make use of. Even if there is only one instance, the assumption is that more could be created, and so probably to avoid that changing existing behaviour, the compiler is pretty cautious.<p>Often with <code>MultiParamTypeClasses</code> you'll also end up wanting to use <code>FunctionalDependencies</code>, which can ease the burden on adding type annotation.<h1 id=functionaldependencies>FunctionalDependencies</h1><p>For use in multi param type classes; functional dependencies provide a way to state that one type is dependant on others, so that the compiler can infer it without you having to explicitly tell it. Let's see why we need this:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>class </span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>Adder' </span><span>a b c </span><span style=color:#f92672>where
</span><span>  </span><span style=color:#a6e22e>add' </span><span style=color:#f92672>:: </span><span>a </span><span style=color:#f92672>-> </span><span>b </span><span style=color:#f92672>-> </span><span>c
</span><span>
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>Adder</span><span>' </span><span style=font-style:italic;color:#66d9ef>Int Int Int </span><span style=color:#f92672>where
</span><span>  add' a b </span><span style=color:#f92672>=</span><span> a </span><span style=color:#f92672>+</span><span> b
</span></code></pre><p>This will fail to type check:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>add' (</span><span style=color:#ae81ff>1</span><span style=color:#f92672>::</span><span style=color:#ae81ff>Int</span><span>) (</span><span style=color:#ae81ff>2</span><span style=color:#f92672>::</span><span style=color:#ae81ff>Int</span><span>)
</span></code></pre><p>The problem is that at any point, someone could define an instance of <code>Adder'</code> with, say, <code>Int Int Double</code> as its 3 params. To play it safe, the type checker requires then that you explicitly provide the final type to prevent future instances from breaking things. Thus, this is fine but pretty ugly:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>add' (</span><span style=color:#ae81ff>1</span><span style=color:#f92672>::</span><span style=color:#ae81ff>Int</span><span>) (</span><span style=color:#ae81ff>2</span><span style=color:#f92672>::</span><span style=color:#ae81ff>Int</span><span>) </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>Int
</span></code></pre><p>Functional dependencies add a little syntax in the class definition to allow us to avoid this issue:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>class </span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>Adder </span><span>a b c | a b -> c </span><span style=color:#f92672>where
</span><span>  </span><span style=color:#a6e22e>add </span><span style=color:#f92672>:: </span><span>a </span><span style=color:#f92672>-> </span><span>b </span><span style=color:#f92672>-> </span><span>c
</span><span>
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>Adder Int Int Int </span><span style=color:#f92672>where
</span><span>  add a b </span><span style=color:#f92672>=</span><span> a </span><span style=color:#f92672>+</span><span> b
</span></code></pre><p>This says that the type <code>c</code> is uniquely determined from the types <code>a</code> and <code>b</code>. This means that there cannot exist an instance with the same types <code>a</code> and <code>b</code> but different type <code>c</code> (for instance, <code>Adder Int Int Double</code>). As such, the compiler is safe to infer what <code>c</code> will be based on what it knows <code>a</code> and <code>b</code> to be, and so<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>add (</span><span style=color:#ae81ff>1</span><span style=color:#f92672>::</span><span style=color:#ae81ff>Int</span><span>) (</span><span style=color:#ae81ff>2</span><span style=color:#f92672>::</span><span style=color:#ae81ff>Int</span><span>)
</span></code></pre><p>now works.<h1 id=overlappinginstances>OverlappingInstances</h1><p>In actuality, <code>OverlappingInstances</code> has been depracated in GHC 7.10. Instead, we gain a few pragmas that allow us to achieve the same but allow us to enable overlap on a per instance basis rather than globally. Let's look back at our <code>LooseEq</code> class from earlier to see why we might need this. Given that we've defined specific instances for <code>LooseEq</code> already, we could try to define a more general one that works on multiple numbers types. First, a supporting class and instances:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- a quick class to convert numbers to integers.
</span><span style=color:#f92672>class </span><span style=font-style:italic;color:#66d9ef>Num </span><span>a => </span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>ToInteger </span><span>a </span><span style=color:#f92672>where
</span><span>  </span><span style=color:#a6e22e>numToInteger </span><span style=color:#f92672>:: </span><span>a </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>Integer
</span><span>
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>ToInteger Int </span><span style=color:#f92672>where
</span><span>    numToInteger i </span><span style=color:#f92672>=</span><span> toInteger i
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>ToInteger Double </span><span style=color:#f92672>where
</span><span>    numToInteger d </span><span style=color:#f92672>=</span><span> round d
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>ToInteger Float </span><span style=color:#f92672>where
</span><span>    numToInteger f </span><span style=color:#f92672>=</span><span> round f
</span></code></pre><p>Making use of this, we declare a more general instance of <code>LooseEq</code> as follows:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>instance </span><span>{-# </span><span style=color:#f92672>OVERLAPPABLE</span><span> #-} (</span><span style=font-style:italic;color:#66d9ef>ToInteger </span><span>a, </span><span style=font-style:italic;color:#66d9ef>ToInteger </span><span>b) </span><span style=color:#f92672>=> </span><span style=font-style:italic;color:#66d9ef>LooseEq </span><span>a b </span><span style=color:#f92672>where
</span><span>    looseEq a b </span><span style=color:#f92672>=</span><span> numToInteger a </span><span style=color:#f92672>==</span><span> numToInteger b
</span><span>
</span><span style=color:#75715e>-- These overlap the more general case so don't need notation unless they too
</span><span style=color:#75715e>-- will be overlapped eg by "LooseEq Int Bool":
</span><span style=color:#f92672>instance</span><span> (</span><span style=font-style:italic;color:#66d9ef>ToInteger </span><span>a) </span><span style=color:#f92672>=> </span><span style=font-style:italic;color:#66d9ef>LooseEq </span><span>a </span><span style=font-style:italic;color:#66d9ef>Bool </span><span style=color:#f92672>where
</span><span>    looseEq a b </span><span style=color:#f92672>=</span><span> (numToInteger a </span><span style=color:#f92672>/= </span><span style=color:#ae81ff>0</span><span>) </span><span style=color:#f92672>==</span><span> b
</span><span>
</span><span style=color:#f92672>instance</span><span> (</span><span style=font-style:italic;color:#66d9ef>ToInteger </span><span>a) </span><span style=color:#f92672>=> </span><span style=font-style:italic;color:#66d9ef>LooseEq Bool </span><span>a </span><span style=color:#f92672>where
</span><span>    looseEq b a </span><span style=color:#f92672>=</span><span> (numToInteger a </span><span style=color:#f92672>/= </span><span style=color:#ae81ff>0</span><span>) </span><span style=color:#f92672>==</span><span> b
</span><span>
</span><span style=color:#75715e>-- this requires FlexibleInstances but doesnt overlap with anything else:
</span><span style=color:#f92672>instance</span><span> (</span><span style=font-style:italic;color:#66d9ef>LooseEq </span><span>a b, </span><span style=font-style:italic;color:#66d9ef>Foldable </span><span>f) </span><span style=color:#f92672>=> </span><span style=font-style:italic;color:#66d9ef>LooseEq</span><span> (f a) (f b) </span><span style=color:#f92672>where
</span><span>    looseEq fa fb </span><span style=color:#f92672>=</span><span> foldl' cmp </span><span style=color:#ae81ff>True</span><span> (zip (toList fa) (toList fb))
</span><span>      </span><span style=color:#f92672>where</span><span> toList </span><span style=color:#f92672>=</span><span> foldr </span><span style=color:#a6e22e>(:) </span><span style=color:#ae81ff>[]
</span><span>            cmp </span><span style=color:#ae81ff>False</span><span> _ </span><span style=color:#f92672>= </span><span style=color:#ae81ff>False
</span><span>            cmp _ (a,b) </span><span style=color:#f92672>=</span><span> a </span><span style=color:#f92672>`looseEq`</span><span> b
</span><span>
</span><span style=color:#75715e>-- this is more specific than above and so I use OVERLAPPING to say it's OK:
</span><span style=color:#f92672>instance </span><span>{-# </span><span style=color:#f92672>OVERLAPPING</span><span> #-} (</span><span style=font-style:italic;color:#66d9ef>LooseEq </span><span>a b) </span><span style=color:#f92672>=> </span><span style=font-style:italic;color:#66d9ef>LooseEq</span><span> [a] [b] </span><span style=color:#f92672>where
</span><span>    looseEq as bs </span><span style=color:#f92672>=</span><span> length as </span><span style=color:#f92672>==</span><span> length bs
</span></code></pre><p>Notice the language pragmas <code>OVERLAPPING</code> and <code>OVERLAPPABLE</code>. Without these, we'd get an overlap error when we tried to make use of these instances, as they overlap with others. In other words, for some use of <code>looseEq</code> there might be more than one instance that matches (ranging from a more general one to a more specific one).<p>The three pragmas of interest are:<ul><li><code>OVERLAPPABLE</code>, which when applied to a more general instance means that more specific instances (so, those declared earlier) will be fine.<li><code>OVERLAPPING</code>, which when applied to a more specific instance means that it is allowed to be overlapping a more general one.<li><code>OVERLAPS</code>, which is equal to adding both of the above.</ul><p>Use of these pragmas is <strong>potentially dangerous</strong> because you could be relying on some instance in your code, and then later overlap it with a more specific instance that still matches your usage of it but potentially behaves completely differently. It would seem to be less risky to use the <code>OVERLAPPING</code> pragma than the <code>OVERLAPPABLE</code> one, since the former prevents others from creating an overlapping instance without acknowledging it as such, but the latter would not kick up a fuss about it and so potentially alter behaviour silently.<h1 id=existentialquantification>ExistentialQuantification</h1><p>Allows you to remove types variables on the left of a <code>data</code> declaration. This is made useful by the fact that you can then constrain types variables on the right hand side to belonging to certain classes (otherwise, you couldnt interact with them at all). Here's the canonical example (where the <code>Typeable</code> constraint is used only for casting later and is not necessary here):<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- we want to store anything "showable" in some type (Typeable not required yet):
</span><span style=color:#75715e>-- notice the lack of 'a' on the left, and instead a 'forall a' on the right to bring
</span><span style=color:#75715e>-- 'a' into scope, and then a class constraint on it so that we always know we can
</span><span style=color:#75715e>-- use 'show':
</span><span style=color:#f92672>data </span><span style=color:#ae81ff>Showable </span><span style=color:#f92672>=</span><span> forall a</span><span style=color:#f92672>.</span><span> (</span><span style=color:#ae81ff>Show</span><span> a, </span><span style=color:#ae81ff>Typeable</span><span> a) </span><span style=color:#f92672>=> </span><span style=color:#ae81ff>Showable</span><span> a
</span><span>
</span><span style=color:#75715e>-- define show instance to just apply show to the contained type,
</span><span style=color:#75715e>-- since we know that's always allowed:
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>Show Showable </span><span style=color:#f92672>where
</span><span>    show (</span><span style=color:#ae81ff>Showable</span><span> a) </span><span style=color:#f92672>=</span><span> show a
</span><span>
</span><span style=color:#75715e>-- now, we can put any arbitrary type into an array and show them all:
</span><span>showables </span><span style=color:#f92672>=</span><span> [</span><span style=color:#ae81ff>Showable</span><span> (</span><span style=color:#ae81ff>2 </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>Int</span><span>), </span><span style=color:#ae81ff>Showable</span><span> (</span><span style=color:#ae81ff>3 </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>Float</span><span>), </span><span style=color:#ae81ff>Showable </span><span style=color:#e6db74>"hello"</span><span>, </span><span style=color:#ae81ff>Showable </span><span style=color:#e6db74>'c'</span><span>]
</span><span style=color:#75715e>-- show showables == [2,3.0,"hello",'c']
</span></code></pre><p>A neat trick here is that, if we have constrained the contained type to be <code>Typeable</code> (as we did above), we can extract the original type back out of the <code>Showable</code> container using <code>Data.Typeable</code>'s <code>cast</code> method:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>castShowable (</span><span style=color:#ae81ff>Showable</span><span> a) </span><span style=color:#f92672>=</span><span> cast a
</span></code></pre><p>Usage:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>main</span><span style=color:#f92672>></span><span> castShowable (</span><span style=color:#ae81ff>Showable </span><span style=color:#e6db74>"hi"</span><span>) </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>Maybe String
</span><span style=color:#ae81ff>Just </span><span style=color:#e6db74>"hi"
</span><span>main</span><span style=color:#f92672>></span><span> castShowable (</span><span style=color:#ae81ff>Showable </span><span style=color:#e6db74>"hi"</span><span>) </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>Maybe Int
</span><span style=color:#ae81ff>Nothing
</span></code></pre><p>We also need <code>ExistentialQuantification</code> if we want to add class constraints to a data type, even if we don't want to hide the variable from the left hand side, for example:<pre style=background:#272822;color:#f8f8f2><code><span>data ShowableT a = Show a => ShowableT a
</span></code></pre><h1 id=gadts>GADTs</h1><p>Short for <em>Generalized Algebraic Data Types</em>, these allows you to declare new <code>data</code> types using a function signature style. The advantage of this is that it allows you to decide exactly what the final type will be in each case, which is not possible with the current syntax.<p>A simple illustration of the difference:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- take a simple type constructor:
</span><span style=color:#f92672>data </span><span style=color:#ae81ff>MyData</span><span> a </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Something</span><span> a </span><span style=color:#f92672>| </span><span style=color:#ae81ff>Otherthing
</span></code></pre><p>Here, <code>Otherthing</code> is of type <code>MyData a</code>; There is no way to change that <code>a</code> to something more specific. However, with <code>GADT</code> syntax, we can. This is exactly equivalent to the above, but now we can specify what <code>a</code> is if we like:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>data </span><span style=color:#ae81ff>MyData</span><span>' a </span><span style=color:#f92672>where
</span><span>    </span><span style=color:#ae81ff>Something</span><span>' </span><span style=color:#f92672>::</span><span> a </span><span style=color:#f92672>-> </span><span style=color:#ae81ff>MyData</span><span>' a
</span><span>    </span><span style=color:#ae81ff>Otherthing</span><span>' </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>MyData</span><span>' a
</span></code></pre><p>Why would we want to do this? One case is for when we want to use those parameters to encode extra information for us. Let's look at a larger example:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>data </span><span style=color:#ae81ff>Expr</span><span>'' </span><span style=color:#f92672>= </span><span style=color:#ae81ff>S</span><span>'' </span><span style=color:#ae81ff>String
</span><span>            </span><span style=color:#f92672>| </span><span style=color:#ae81ff>I</span><span>'' </span><span style=color:#ae81ff>Int
</span><span>            </span><span style=color:#f92672>| </span><span style=color:#ae81ff>Add</span><span>'' </span><span style=color:#ae81ff>Expr</span><span>'' </span><span style=color:#ae81ff>Expr</span><span>''
</span><span>            </span><span style=color:#f92672>| </span><span style=color:#ae81ff>Append</span><span>'' </span><span style=color:#ae81ff>Expr</span><span>'' </span><span style=color:#ae81ff>Expr</span><span>''
</span></code></pre><p>A basic AST representation, but notice that <code>Add</code> can take any <code>Expr</code> even though the <code>Expr</code> produced from <code>I Int</code> is the only one that makes sense. We can use a type on <code>Expr</code> to encode this, so that <code>Add</code> only takes <code>Expr Int</code>s, and <code>Append</code> only takes <code>Exp String</code>s:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>data </span><span style=color:#ae81ff>Expr</span><span>' a </span><span style=color:#f92672>= </span><span style=color:#ae81ff>S</span><span>' </span><span style=color:#ae81ff>String
</span><span>             </span><span style=color:#f92672>| </span><span style=color:#ae81ff>I</span><span>' </span><span style=color:#ae81ff>Int
</span><span>             </span><span style=color:#f92672>| </span><span style=color:#ae81ff>Add</span><span>' (</span><span style=color:#ae81ff>Expr</span><span>' </span><span style=color:#ae81ff>Int</span><span>) (</span><span style=color:#ae81ff>Expr</span><span>' </span><span style=color:#ae81ff>Int</span><span>)
</span><span>             </span><span style=color:#f92672>| </span><span style=color:#ae81ff>Append</span><span>' (</span><span style=color:#ae81ff>Expr</span><span>' </span><span style=color:#ae81ff>String</span><span>) (</span><span style=color:#ae81ff>Expr</span><span>' </span><span style=color:#ae81ff>String</span><span>)
</span></code></pre><p>But without <code>GADTs</code> we have no way to enforce that the type of, say, <code>I Int</code> will actually be <code>Expr Int</code>. With GADT's we express constructors as functions, and so we provide that final type:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>data </span><span style=color:#ae81ff>Expr</span><span> a </span><span style=color:#f92672>where
</span><span>    </span><span style=color:#ae81ff>I      </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>Int         </span><span style=color:#f92672>->                </span><span style=color:#ae81ff>Expr Int
</span><span>    </span><span style=color:#ae81ff>Add    </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>Expr Int    </span><span style=color:#f92672>-> </span><span style=color:#ae81ff>Expr Int    </span><span style=color:#f92672>-> </span><span style=color:#ae81ff>Expr Int
</span><span>    </span><span style=color:#ae81ff>S      </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>String      </span><span style=color:#f92672>->                </span><span style=color:#ae81ff>Expr String
</span><span>    </span><span style=color:#ae81ff>Append </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>Expr String </span><span style=color:#f92672>-> </span><span style=color:#ae81ff>Expr String </span><span style=color:#f92672>-> </span><span style=color:#ae81ff>Expr String
</span></code></pre><p>Now, we can whip up a quick evaluator for our tree:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>eval </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Expr </span><span>a </span><span style=color:#f92672>-> </span><span>a
</span><span>eval (</span><span style=color:#ae81ff>S</span><span> s) </span><span style=color:#f92672>=</span><span> s
</span><span>eval (</span><span style=color:#ae81ff>I</span><span> i) </span><span style=color:#f92672>=</span><span> i
</span><span>eval (</span><span style=color:#ae81ff>Add</span><span> a b) </span><span style=color:#f92672>=</span><span> eval a </span><span style=color:#f92672>+</span><span> eval b
</span><span>eval (</span><span style=color:#ae81ff>Append</span><span> a b) </span><span style=color:#f92672>=</span><span> eval a </span><span style=color:#f92672>++</span><span> eval b
</span></code></pre><p>And notice that silly expressions are sanely rejected by the type system for us:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>main</span><span style=color:#f92672>></span><span> eval </span><span style=color:#f92672>$</span><span> (</span><span style=color:#ae81ff>I 1 </span><span style=color:#f92672>`Add` </span><span style=color:#ae81ff>I 2</span><span>) </span><span style=color:#f92672>`Add`</span><span> (</span><span style=color:#ae81ff>I 3</span><span>)
</span><span style=color:#ae81ff>6
</span><span>main</span><span style=color:#f92672>></span><span> eval </span><span style=color:#f92672>$</span><span> (</span><span style=color:#ae81ff>S </span><span style=color:#e6db74>"Hello" </span><span style=color:#f92672>`Append` </span><span style=color:#ae81ff>S </span><span style=color:#e6db74>" "</span><span>) </span><span style=color:#f92672>`Append`</span><span> (</span><span style=color:#ae81ff>S </span><span style=color:#e6db74>"World"</span><span>)
</span><span style=color:#e6db74>"Hello World"
</span><span>main</span><span style=color:#f92672>></span><span> eval </span><span style=color:#f92672>$</span><span> (</span><span style=color:#ae81ff>S </span><span style=color:#e6db74>"Hello" </span><span style=color:#f92672>`Append` </span><span style=color:#ae81ff>S </span><span style=color:#e6db74>" "</span><span>) </span><span style=color:#f92672>`Add`</span><span> (</span><span style=color:#ae81ff>S </span><span style=color:#e6db74>"World"</span><span>)
</span><span style=color:#ae81ff>BZZZZT</span><span style=color:#f92672>! </span><span style=color:#ae81ff>Type Error</span><span style=color:#f92672>. </span><span style=color:#ae81ff>Add</span><span> expects </span><span style=color:#ae81ff>Expr Int</span><span>, got </span><span style=color:#ae81ff>Expr String</span><span>'s</span><span style=color:#f92672>!
</span></code></pre><h1 id=implicitparams>ImplicitParams</h1><p>Allow functions to require that some value exists in the scope it's used in, without one having to actually explicitly pass in said value. Allows one to define global things in <code>main</code> for instance and not have to think about threading them through everywhere explicitly, just adding an implicit requirement in functions where they are actually used. A simple example:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- define implicit param as variable with question mark in front of:
</span><span>fn1 a </span><span style=color:#f92672>=</span><span> fn2 a </span><span style=color:#f92672>where ?</span><span>world </span><span style=color:#f92672>= </span><span style=color:#e6db74>" world"
</span><span>fn2 a </span><span style=color:#f92672>=</span><span> fn3 a
</span><span>fn3 a </span><span style=color:#f92672>=</span><span> fn4 a
</span><span>
</span><span style=color:#75715e>-- add constraint that implicit param called ?world exists in the scope this
</span><span style=color:#75715e>-- it used. Now, calling fn1 will work, but calling fn2, fn3 and fn4 directly
</span><span style=color:#75715e>-- will fail as the implicit param would not be defined if not for fn1.
</span><span style=color:#a6e22e>fn4 </span><span style=color:#f92672>::</span><span> (?world :: </span><span style=font-style:italic;color:#66d9ef>String</span><span>) </span><span style=color:#f92672>=> </span><span>a </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>String
</span><span>fn4 a </span><span style=color:#f92672>=</span><span> a </span><span style=color:#f92672>++ ?</span><span>world
</span></code></pre><p>Now, to test:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>main</span><span style=color:#f92672>></span><span> fn1 </span><span style=color:#e6db74>"hello"
</span><span style=color:#e6db74>"hello world"
</span><span>main</span><span style=color:#f92672>></span><span> fn2 </span><span style=color:#ae81ff>2
</span><span style=color:#ae81ff>BZZZT</span><span style=color:#f92672>! </span><span style=color:#ae81ff>ERROR</span><span style=color:#f92672>!</span><span> implicit param </span><span style=color:#f92672>?</span><span>showIt not bound</span><span style=color:#f92672>!
</span></code></pre><p>The downside? If you want to annotate your types, you have to explicitly thread your implicit parameters through in the type signatures, so why not just pass them normally? Calling something like <code>tyfn1 "hello"</code> in this example would not work for instance:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>tyfn1 </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>String </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>String
</span><span>tyfn1 a </span><span style=color:#f92672>=</span><span> tyfn2 a </span><span style=color:#f92672>where ?</span><span>showIt </span><span style=color:#f92672>= </span><span style=color:#e6db74>"world"
</span><span>
</span><span style=color:#75715e>--this needs to mention implicit param type
</span><span style=color:#75715e>--in order to work, so why not just pass it?
</span><span style=color:#a6e22e>tyfn2 </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>String </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>String
</span><span>tyfn2 a </span><span style=color:#f92672>=</span><span> tyfn3 a
</span><span>
</span><span style=color:#a6e22e>tyfn3 </span><span style=color:#f92672>::</span><span> (?showIt :: </span><span style=font-style:italic;color:#66d9ef>String</span><span>) </span><span style=color:#f92672>=> </span><span style=font-style:italic;color:#66d9ef>String </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>String
</span><span>tyfn3 a </span><span style=color:#f92672>=</span><span> a </span><span style=color:#f92672>++ ?</span><span>showIt
</span></code></pre><p>All in all, I think I'll steer clear of this one.<h1 id=typefamilies>TypeFamilies</h1><p>One of the most exciting language extensions I'm aware of so far, this one lets you teach Haskell's type system new tricks by defining relationships between types. This language extension actually introduces type families as well as data families, each with syntax do that you can use them inside classes. Let's start with type families themselves:<h2 id=type-families>Type Families</h2><p>This is a simple beginning example of an <em>open</em> type family. Think of type families as type aliases on steroids. This one maps the alias <code>AddResult a b</code> to some corresponding type. It's called an <em>open</em> type family because we can add new instances to it later on if we want to extend it.<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>type</span><span> family </span><span style=color:#ae81ff>AddResult</span><span> a b
</span><span style=color:#f92672>type instance </span><span style=font-style:italic;color:#66d9ef>AddResult Double Double</span><span> = </span><span style=font-style:italic;color:#66d9ef>Double
</span><span style=color:#f92672>type instance </span><span style=font-style:italic;color:#66d9ef>AddResult Int Double</span><span> = </span><span style=font-style:italic;color:#66d9ef>Double
</span><span style=color:#f92672>type instance </span><span style=font-style:italic;color:#66d9ef>AddResult Double Int</span><span> = </span><span style=font-style:italic;color:#66d9ef>Double
</span><span style=color:#f92672>type instance </span><span style=font-style:italic;color:#66d9ef>AddResult Int Int</span><span> = </span><span style=font-style:italic;color:#66d9ef>Int
</span></code></pre><p>If we were to use this, we'd probably end up wanting to define a type class, so let's do that:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>class </span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>MyAdder </span><span>a b </span><span style=color:#f92672>where
</span><span>    </span><span style=color:#a6e22e>adder </span><span style=color:#f92672>:: </span><span>a </span><span style=color:#f92672>-> </span><span>b </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>AddResult </span><span>a b
</span><span>
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>MyAdder Double Double </span><span style=color:#f92672>where
</span><span>    adder a b </span><span style=color:#f92672>=</span><span> a </span><span style=color:#f92672>+</span><span> b
</span><span>
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>MyAdder Int Double </span><span style=color:#f92672>where
</span><span>    adder a b </span><span style=color:#f92672>=</span><span> realToFrac a </span><span style=color:#f92672>+</span><span> b
</span><span>
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>MyAdder Double Int </span><span style=color:#f92672>where
</span><span>    adder a b </span><span style=color:#f92672>=</span><span> a </span><span style=color:#f92672>+</span><span> realToFrac b
</span><span>
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>MyAdder Int Int </span><span style=color:#f92672>where
</span><span>    adder a b </span><span style=color:#f92672>=</span><span> a </span><span style=color:#f92672>+</span><span> b
</span></code></pre><p>Here, we set the return type of this multi-parameter type class to be <code>AddResult a b</code>, so that depending on what <code>a</code> and <code>b</code> are in the specific instances we can output completely different things. In this case we stick to <code>Int</code>s and <code>Double</code>s.<p>Naturally, we might feel that this type is associated to the type class, and want to actually state that part of the <code>MyAdder a b</code> type class is the type <code>AddResult a b</code>. Well, we can do exactly that:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>class </span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>MyAdder' </span><span>a b </span><span style=color:#f92672>where
</span><span>    </span><span style=color:#f92672>type </span><span style=color:#ae81ff>AddResult</span><span>' a b
</span><span>    </span><span style=color:#a6e22e>adder' </span><span style=color:#f92672>:: </span><span>a </span><span style=color:#f92672>-> </span><span>b </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>AddResult</span><span>' a b
</span><span>
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>MyAdder</span><span>' </span><span style=font-style:italic;color:#66d9ef>Double Double </span><span style=color:#f92672>where
</span><span>    </span><span style=color:#f92672>type </span><span style=color:#ae81ff>AddResult</span><span>' </span><span style=color:#ae81ff>Double Double </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Double
</span><span>    adder' a b </span><span style=color:#f92672>=</span><span> a </span><span style=color:#f92672>+</span><span> b
</span><span>
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>MyAdder</span><span>' </span><span style=font-style:italic;color:#66d9ef>Int Double </span><span style=color:#f92672>where
</span><span>    </span><span style=color:#f92672>type </span><span style=color:#ae81ff>AddResult</span><span>' </span><span style=color:#ae81ff>Int Double </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Double
</span><span>    adder' a b </span><span style=color:#f92672>=</span><span> realToFrac a </span><span style=color:#f92672>+</span><span> b
</span><span>
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>MyAdder</span><span>' </span><span style=font-style:italic;color:#66d9ef>Double Int </span><span style=color:#f92672>where
</span><span>    </span><span style=color:#f92672>type </span><span style=color:#ae81ff>AddResult</span><span>' </span><span style=color:#ae81ff>Double Int </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Double
</span><span>    adder' a b </span><span style=color:#f92672>=</span><span> a </span><span style=color:#f92672>+</span><span> realToFrac b
</span><span>
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>MyAdder</span><span>' </span><span style=font-style:italic;color:#66d9ef>Int Int </span><span style=color:#f92672>where
</span><span>    </span><span style=color:#f92672>type </span><span style=color:#ae81ff>AddResult</span><span>' </span><span style=color:#ae81ff>Int Int </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Int
</span><span>    adder' a b </span><span style=color:#f92672>=</span><span> a </span><span style=color:#f92672>+</span><span> b
</span></code></pre><p>Now, <code>AddResult a b</code> is an associated type within the <code>MyAdder</code> type class, and so each instance will require a definition of it just as for any required functions. Functionally though it is the same as the original <code>MyAdder</code> example.<p>Sometimes we might not want others to be able to arbitrarily extend a type family. Fortunately, GHC 7.8 introduced closed type families. Defining <code>AddResult</code> again as a closed type family would look like:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>type</span><span> family </span><span style=color:#ae81ff>AddResult</span><span>'' a b </span><span style=color:#f92672>where
</span><span>    </span><span style=color:#ae81ff>AddResult</span><span>'' </span><span style=color:#ae81ff>Double Double </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Double
</span><span>    </span><span style=color:#ae81ff>AddResult</span><span>'' </span><span style=color:#ae81ff>Int Double </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Double
</span><span>    </span><span style=color:#ae81ff>AddResult</span><span>'' </span><span style=color:#ae81ff>Double Int </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Double
</span><span>    </span><span style=color:#ae81ff>AddResult</span><span>'' </span><span style=color:#ae81ff>Int Int </span><span style=color:#f92672>= </span><span style=color:#ae81ff>Int
</span></code></pre><p>One advantage of closed type families is that the evaluation order is now obvious; it works from top to bottom until your type is matched. This means that more general type aliases can come below more specific ones, which isn't possible in an open type family.<p>Type families can be recursive, too. This one takes some arbitrary function signature, and gives back its return type by recursing through it:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>type</span><span> family </span><span style=color:#ae81ff>ReturnVal</span><span> ty </span><span style=color:#f92672>where
</span><span>    </span><span style=color:#ae81ff>ReturnVal</span><span> (a </span><span style=color:#f92672>-></span><span> b) </span><span style=color:#f92672>= </span><span style=color:#ae81ff>ReturnVal</span><span> b
</span><span>    </span><span style=color:#ae81ff>ReturnVal</span><span> b </span><span style=color:#f92672>=</span><span> b
</span></code></pre><p>Now, this would type check ('a' is a <code>Char</code>):<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#e6db74>'a' </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>ReturnVal</span><span> (</span><span style=color:#ae81ff>Int </span><span style=color:#f92672>-> </span><span style=color:#ae81ff>String </span><span style=color:#f92672>-> </span><span style=color:#ae81ff>Char</span><span>)
</span></code></pre><p>But this would not ('a' is not an <code>Int</code>):<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#e6db74>'a' </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>ReturnVal</span><span> (</span><span style=color:#ae81ff>Char </span><span style=color:#f92672>-> </span><span style=color:#ae81ff>String </span><span style=color:#f92672>-> </span><span style=color:#ae81ff>Int</span><span>)
</span></code></pre><p>In my next example I turn a nested 2-tuple into a function signature using another recursive type family. You may find you need to enable the extension <code>UndecidableInstances</code> with certain recursive definitions when the type checker can't be sure that the recursion will ever end; the compiler will tell you if it is necessary and give this reason.<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>type</span><span> family </span><span style=color:#ae81ff>TupleFn</span><span> ty out </span><span style=color:#f92672>where
</span><span>    </span><span style=color:#ae81ff>TupleFn ()</span><span> output </span><span style=color:#f92672>=</span><span> output
</span><span>    </span><span style=color:#ae81ff>TupleFn</span><span> (a,b) output </span><span style=color:#f92672>=</span><span> a </span><span style=color:#f92672>-></span><span> (</span><span style=color:#ae81ff>TupleFn</span><span> b output)
</span></code></pre><p>We could use this definition to actually construct a function that takes a tuple, and a function generated from the tuple's type using the above (of whatever parity is required!), and applies the function to each value in the tuple, returning the result. We'll need another type class for this as we'll do something different depending on the shape (and thus type) of the tuple:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>class </span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>ApplyFnToTuple </span><span>a </span><span style=color:#f92672>where
</span><span>    </span><span style=color:#a6e22e>applyFnToTuple </span><span style=color:#f92672>:: </span><span>a </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>TupleFn </span><span>a out </span><span style=color:#f92672>-> </span><span>out
</span><span>
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>ApplyFnToTuple </span><span>b </span><span style=color:#f92672>=> </span><span style=font-style:italic;color:#66d9ef>ApplyFnToTuple</span><span> (a,b) </span><span style=color:#f92672>where
</span><span>    applyFnToTuple (a,b) fn </span><span style=color:#f92672>=</span><span> applyFnToTuple b (fn a)
</span><span>
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>ApplyFnToTuple </span><span style=color:#66d9ef>() </span><span style=color:#f92672>where
</span><span>    applyFnToTuple _ fn </span><span style=color:#f92672>=</span><span> fn
</span></code></pre><p>The function signature asks for a tuple of type <code>a</code>, and then some function of type <code>TupleFn a out</code>, which is a type dictated by the shape of <code>a</code>, and returns some <code>out</code>, which is whatever the tuple function gives back. These would now both be true:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>applyFnToTuple (</span><span style=color:#e6db74>'a'</span><span>,(</span><span style=color:#e6db74>'b'</span><span>,</span><span style=color:#ae81ff>()</span><span>)) </span><span style=color:#f92672>$ \</span><span>a b </span><span style=color:#f92672>-></span><span> [a,b] </span><span style=color:#f92672>== </span><span style=color:#e6db74>"ab"
</span><span>applyFnToTuple (</span><span style=color:#e6db74>"hello"</span><span>,(</span><span style=color:#ae81ff>12</span><span>,(</span><span style=color:#e6db74>'r'</span><span>,</span><span style=color:#ae81ff>()</span><span>))) </span><span style=color:#f92672>$ \</span><span>h n r </span><span style=color:#f92672>-></span><span> h </span><span style=color:#f92672>++</span><span> show n </span><span style=color:#f92672>++</span><span> [r] </span><span style=color:#f92672>== </span><span style=color:#e6db74>"hello12r"
</span></code></pre><p>We don't always need type classes to take advantage of type families in this way. If I create my own version of the above, I can avoid using them entirely:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- we use these types to "tag" our list values. essentially,
</span><span style=color:#75715e>-- they form a type level description that mirrors what we are
</span><span style=color:#75715e>-- doing with values. We can improve on this with DataKinds, later.
</span><span style=color:#f92672>data </span><span style=color:#ae81ff>Cons</span><span> a b
</span><span style=color:#f92672>data </span><span style=color:#ae81ff>Nil
</span><span>
</span><span style=color:#75715e>-- the list itself, where the type 'a' is built from the above tags
</span><span style=color:#f92672>data </span><span style=color:#ae81ff>MyList</span><span> a </span><span style=color:#f92672>where
</span><span>    </span><span style=color:#ae81ff>LCons </span><span style=color:#f92672>::</span><span> itemty </span><span style=color:#f92672>-> </span><span style=color:#ae81ff>MyList</span><span> a </span><span style=color:#f92672>-> </span><span style=color:#ae81ff>MyList</span><span> (</span><span style=color:#ae81ff>Cons</span><span> itemty a)
</span><span>    </span><span style=color:#ae81ff>LNil  </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>MyList Nil
</span><span>
</span><span style=color:#75715e>-- this type family converts that type 'a' to a function signature.
</span><span style=color:#f92672>type</span><span> family </span><span style=color:#ae81ff>MyListFn</span><span> a output </span><span style=color:#f92672>where
</span><span>    </span><span style=color:#ae81ff>MyListFn</span><span> (</span><span style=color:#ae81ff>Cons</span><span> a b) output </span><span style=color:#f92672>=</span><span> a </span><span style=color:#f92672>-></span><span> (</span><span style=color:#ae81ff>MyListFn</span><span> b output)
</span><span>    </span><span style=color:#ae81ff>MyListFn Nil</span><span> output </span><span style=color:#f92672>=</span><span> output
</span><span>
</span><span style=color:#75715e>-- this function applies items in `MyList a` to a `MyListFn a` just
</span><span style=color:#75715e>-- like we did with tuples. Note no type family, because
</span><span style=color:#75715e>-- no type dependant differences in behaviour needed:
</span><span style=color:#a6e22e>applyFnToMyList </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>MyList </span><span>a </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>MyListFn </span><span>a out </span><span style=color:#f92672>-> </span><span>out
</span><span>applyFnToMyList (</span><span style=color:#ae81ff>LCons</span><span> a b) fn </span><span style=color:#f92672>=</span><span> applyFnToMyList b (fn a)
</span><span>applyFnToMyList </span><span style=color:#ae81ff>LNil</span><span> fn </span><span style=color:#f92672>=</span><span> fn
</span></code></pre><p>The crucial steps here are:<ol><li>We create a basic list type to use, here of type <code>MyList a</code>.<li>We want to record the type of each item we put into the list in the type <code>a</code> in some way that is easy to work with. Here we use a couple of new types, <code>Cons a b</code> and <code>Nil</code> to represent at the type level what my list's <code>LCons</code> and <code>LNil</code> constructors are doing at the value level.<li>Now that we have recorded the types in <code>a</code>, we use a type family to take the type <code>a</code> and convert it into some desired type <code>b</code>, here a function signature.<li>Finally, we use this in <code>applyFnToMyList</code>, which takes in first a <code>MyList a</code> (remember, that <code>a</code> is the record of all types within), second a function of type <code>MyListFn a out</code>, and finally returns <code>out</code>. The definition of this function basically applies the function to each item in the list in the same order as the signature dictates.</ol><p>We can use it just like the earlier tuple version:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>applyFnToMyList (</span><span style=color:#ae81ff>LCons </span><span style=color:#e6db74>'a'</span><span> (</span><span style=color:#ae81ff>LCons </span><span style=color:#e6db74>'b' </span><span style=color:#ae81ff>LNil</span><span>)) </span><span style=color:#f92672>$ \</span><span>a b </span><span style=color:#f92672>-></span><span> [a,b] </span><span style=color:#f92672>== </span><span style=color:#e6db74>"ab"
</span><span>applyFnToMyList (</span><span style=color:#ae81ff>LCons </span><span style=color:#e6db74>"hello"</span><span> (</span><span style=color:#ae81ff>LCons 12</span><span> (</span><span style=color:#ae81ff>LCons </span><span style=color:#e6db74>'r' </span><span style=color:#ae81ff>LNil</span><span>))) </span><span style=color:#f92672>$ \</span><span>h n r </span><span style=color:#f92672>-></span><span> h </span><span style=color:#f92672>++</span><span> show n </span><span style=color:#f92672>++</span><span> [r] </span><span style=color:#f92672>== </span><span style=color:#e6db74>"hello12r"
</span></code></pre><p>Awesome.<h2 id=the-equality-constraint>The Equality Constraint</h2><p>Before looking at data families, another goodie that comes with the TypeFamily extension (and also with <code>GADTs</code>) is the type equality constraint <code>~</code>. This basically allows us to tell the compiler that some type <code>a</code> is equal to some other type <code>b</code>. As an example, our earlier example avoiding <code>FlexibleInstances</code> could be redefined from the original, which was:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>class </span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>Truthy </span><span>a </span><span style=color:#f92672>where
</span><span>    </span><span style=color:#a6e22e>truthy </span><span style=color:#f92672>:: </span><span>a </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>Bool
</span><span>
</span><span style=color:#f92672>class </span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>CharType </span><span>a
</span><span>instance </span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>CharType Char
</span><span>
</span><span>instance </span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>CharType </span><span>a => </span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>Truthy</span><span> [a] </span><span style=color:#f92672>where
</span><span>    truthy s </span><span style=color:#f92672>=</span><span> length s </span><span style=color:#f92672>/= </span><span style=color:#ae81ff>0
</span></code></pre><p>To (now using an equality constraint):<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>class </span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>Truthy' </span><span>a </span><span style=color:#f92672>where
</span><span>    </span><span style=color:#a6e22e>truthy' </span><span style=color:#f92672>:: </span><span>a </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>Bool
</span><span>
</span><span style=color:#f92672>instance </span><span>a ~ </span><span style=font-style:italic;color:#66d9ef>Char </span><span style=color:#f92672>=> </span><span style=font-style:italic;color:#66d9ef>Truthy</span><span>' [a] </span><span style=color:#f92672>where
</span><span>    truthy' s </span><span style=color:#f92672>=</span><span> length s </span><span style=color:#f92672>/= </span><span style=color:#ae81ff>0
</span></code></pre><p>Here, we define an instance for the general case of <code>Truthy [a]</code>, but then add the constraint that <code>a</code> must be a <code>Char</code>. I expect this comes in particularly handy when you wish to define a function that operates on some type family but only when certain types match up (thus enabling the use of functions specific to those types). At times, it is useful just to provide the compiler with a little extra information if it is struggling to deduce some types.<h2 id=data-families>Data Families</h2><p>Also enabled with the TypeFamilies extension, these are the <code>data</code> equivalent to type families as described above. Unlike type families where multiple type aliases can map to the same thing, each data instance is expected to have unique constructors; just like in any other data declaration we cant have multiple constructors with the same name.<p>An example I've seen before which I liked was that of storing different types in specialised key/value stores. Here, we define a new type <code>MyMap key val</code> and then a constructor for each of <code>MyMap Bool Val</code> and <code>MyMap Int Val</code>. This shares the property of <code>GADTs</code> in that we can set the type of <code>key</code> and <code>val</code> in <code>MyMap key val</code> to whatever we like for each constructor:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>data</span><span> family </span><span style=color:#ae81ff>MyMap</span><span> key val
</span><span style=color:#f92672>data instance </span><span style=font-style:italic;color:#66d9ef>MyMap Bool </span><span>val = </span><span style=font-style:italic;color:#66d9ef>BoolMap</span><span> (</span><span style=font-style:italic;color:#66d9ef>Maybe </span><span>val) (</span><span style=font-style:italic;color:#66d9ef>Maybe </span><span>val)
</span><span>    </span><span style=color:#f92672>deriving </span><span style=color:#ae81ff>Show
</span><span style=color:#f92672>data instance </span><span style=font-style:italic;color:#66d9ef>MyMap Int </span><span>val = </span><span style=font-style:italic;color:#66d9ef>IntMap</span><span> [(</span><span style=font-style:italic;color:#66d9ef>Int</span><span>,val)]
</span><span>    </span><span style=color:#f92672>deriving </span><span style=color:#ae81ff>Show
</span></code></pre><p>The equivalent in GADT form would be:<pre style=background:#272822;color:#f8f8f2><code><span>data MyMap key val where
</span><span>    BoolMap :: Maybe val -> Maybe val -> MyMap Bool val
</span><span>    IntMap :: [(Int,val)] -> MyMap Int val
</span></code></pre><p>Though you are unable to automatically derive <code>Show</code> in the GADT version unlike for the data family declarations. The main advantage of data families however is that they are <em>open</em> and can be extended later on, for example if you create a new <code>key</code> type you want a specialised <code>MyMap</code> instance for.<p>We could create a type class and a couple of instances to put our <code>MyMap</code> to use:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>class </span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>MapKey </span><span>k </span><span style=color:#f92672>where
</span><span>    </span><span style=color:#a6e22e>insert </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>MyMap </span><span>k v </span><span style=color:#f92672>-> </span><span>k </span><span style=color:#f92672>-> </span><span>v </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>MyMap </span><span>k v
</span><span>    </span><span style=color:#a6e22e>find </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>MyMap </span><span>k v </span><span style=color:#f92672>-> </span><span>k </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>Maybe </span><span>v
</span><span>    </span><span style=color:#a6e22e>remove </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>MyMap </span><span>k v </span><span style=color:#f92672>-> </span><span>k </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>MyMap </span><span>k v
</span><span>
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>MapKey Bool </span><span style=color:#f92672>where
</span><span>    insert (</span><span style=color:#ae81ff>BoolMap</span><span> _ f) </span><span style=color:#ae81ff>True</span><span> v </span><span style=color:#f92672>= </span><span style=color:#ae81ff>BoolMap</span><span> (</span><span style=color:#ae81ff>Just</span><span> v) f
</span><span>    insert (</span><span style=color:#ae81ff>BoolMap</span><span> t _) </span><span style=color:#ae81ff>False</span><span> v </span><span style=color:#f92672>= </span><span style=color:#ae81ff>BoolMap</span><span> t (</span><span style=color:#ae81ff>Just</span><span> v)
</span><span>    find (</span><span style=color:#ae81ff>BoolMap</span><span> t _) </span><span style=color:#ae81ff>True </span><span style=color:#f92672>=</span><span> t
</span><span>    find (</span><span style=color:#ae81ff>BoolMap</span><span> _ f) </span><span style=color:#ae81ff>False </span><span style=color:#f92672>=</span><span> f
</span><span>    remove (</span><span style=color:#ae81ff>BoolMap</span><span> _ f) </span><span style=color:#ae81ff>True </span><span style=color:#f92672>= </span><span style=color:#ae81ff>BoolMap Nothing</span><span> f
</span><span>    remove (</span><span style=color:#ae81ff>BoolMap</span><span> t _) </span><span style=color:#ae81ff>False </span><span style=color:#f92672>= </span><span style=color:#ae81ff>BoolMap</span><span> t </span><span style=color:#ae81ff>Nothing
</span><span>
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>MapKey Int </span><span style=color:#f92672>where
</span><span>    insert (</span><span style=color:#ae81ff>IntMap</span><span> list) k v </span><span style=color:#f92672>= </span><span style=color:#ae81ff>IntMap</span><span> ((k,v)</span><span style=color:#f92672>:</span><span style=color:#ae81ff>L</span><span style=color:#f92672>.</span><span>filter (</span><span style=color:#f92672>\</span><span>(k1,v1) </span><span style=color:#f92672>-></span><span> k </span><span style=color:#f92672>/=</span><span> k1) list)
</span><span>    find (</span><span style=color:#ae81ff>IntMap</span><span> list) k </span><span style=color:#f92672>= case </span><span style=color:#ae81ff>L</span><span style=color:#f92672>.</span><span>find (</span><span style=color:#f92672>\</span><span>(k1,v1) </span><span style=color:#f92672>-></span><span> k </span><span style=color:#f92672>==</span><span> k1) list </span><span style=color:#f92672>of
</span><span>        </span><span style=color:#ae81ff>Nothing </span><span style=color:#f92672>-> </span><span style=color:#ae81ff>Nothing
</span><span>        </span><span style=color:#ae81ff>Just</span><span> (k,v) </span><span style=color:#f92672>-> </span><span style=color:#ae81ff>Just</span><span> v
</span><span>    remove (</span><span style=color:#ae81ff>IntMap</span><span> list) k </span><span style=color:#f92672>= </span><span style=color:#ae81ff>IntMap</span><span> (</span><span style=color:#ae81ff>L</span><span style=color:#f92672>.</span><span>filter (</span><span style=color:#f92672>\</span><span>(k1,v1) </span><span style=color:#f92672>-></span><span> k </span><span style=color:#f92672>/=</span><span> k1) list)
</span></code></pre><p>For our two map types, we define some basic operations to add, find and remove entries. If we add a new instance to our <code>MyMap</code> data family at a later date for some new type, we can add a new instance to the associated type class for that same type and off we go. Just like type families, we can keep the data type that is clearly tied to this class inside it as an associated data type:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>class </span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>MapKey' </span><span>k </span><span style=color:#f92672>where
</span><span>    </span><span style=color:#f92672>data </span><span style=color:#ae81ff>MyMap</span><span>' k v
</span><span>    </span><span style=color:#a6e22e>insert' </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>MyMap </span><span>k v </span><span style=color:#f92672>-> </span><span>k </span><span style=color:#f92672>-> </span><span>v </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>MyMap </span><span>k v
</span><span>    </span><span style=color:#a6e22e>find' </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>MyMap </span><span>k v </span><span style=color:#f92672>-> </span><span>k </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>Maybe </span><span>v
</span><span>    </span><span style=color:#a6e22e>remove' </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>MyMap </span><span>k v </span><span style=color:#f92672>-> </span><span>k </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>MyMap </span><span>k v
</span><span>
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>MapKey</span><span>' </span><span style=font-style:italic;color:#66d9ef>Bool </span><span style=color:#f92672>where
</span><span>    </span><span style=color:#f92672>data </span><span style=color:#ae81ff>MyMap</span><span>' </span><span style=color:#ae81ff>Bool</span><span> val </span><span style=color:#f92672>= </span><span style=color:#ae81ff>BoolMap</span><span>' (</span><span style=color:#ae81ff>Maybe</span><span> val) (</span><span style=color:#ae81ff>Maybe</span><span> val)
</span><span>    insert' (</span><span style=color:#ae81ff>BoolMap</span><span> _ f) </span><span style=color:#ae81ff>True</span><span> v </span><span style=color:#f92672>= </span><span style=color:#ae81ff>BoolMap</span><span> (</span><span style=color:#ae81ff>Just</span><span> v) f
</span><span>    insert' (</span><span style=color:#ae81ff>BoolMap</span><span> t _) </span><span style=color:#ae81ff>False</span><span> v </span><span style=color:#f92672>= </span><span style=color:#ae81ff>BoolMap</span><span> t (</span><span style=color:#ae81ff>Just</span><span> v)
</span><span>    find' (</span><span style=color:#ae81ff>BoolMap</span><span> t _) </span><span style=color:#ae81ff>True </span><span style=color:#f92672>=</span><span> t
</span><span>    find' (</span><span style=color:#ae81ff>BoolMap</span><span> _ f) </span><span style=color:#ae81ff>False </span><span style=color:#f92672>=</span><span> f
</span><span>    remove' (</span><span style=color:#ae81ff>BoolMap</span><span> _ f) </span><span style=color:#ae81ff>True </span><span style=color:#f92672>= </span><span style=color:#ae81ff>BoolMap Nothing</span><span> f
</span><span>    remove' (</span><span style=color:#ae81ff>BoolMap</span><span> t _) </span><span style=color:#ae81ff>False </span><span style=color:#f92672>= </span><span style=color:#ae81ff>BoolMap</span><span> t </span><span style=color:#ae81ff>Nothing
</span><span>
</span><span style=color:#75715e>-- ...other instances...
</span></code></pre><p>This works exactly as before, except now the requirement that you need to define a new data instance is imposed on adding new type class instances.<h1 id=kindsignatures>KindSignatures</h1><p>This extension allows you to provide <em>kind</em> signatures to types, just as we would add type signatures to values. Basically in Haskell every type (I believe there are exceptions) has the <em>kind</em> <code>*</code>. Just as types are categories of values (<code>Int</code> is the category containing 0, 1, 2, 3.., <code>Char</code> is the category containing 'a', 'b', 'c' and so on), kinds are categories of types (so the kind <code>*</code> is the category containing type types <code>Int</code>, <code>Char</code>, <code>Bool</code> and so on). A function type like <code>Int -> Char -> Int</code> would have the kind <code>* -> * -> *</code>. You could imagine categorising kinds into something too, and so on; some languages let you do this but Haskell currently stops at kinds (every kind is in the same category, and you can't change that).<p>It makes sense to use kind signatures when defining types and type families, as the variables you'd use instead are somewhat meaningless, for example in the data type:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>data </span><span style=color:#ae81ff>MyMap</span><span> key val
</span></code></pre><p>What do <code>key</code> and <code>val</code> mean? Nothing, really. They are just place holders implying that the type <code>MyMap</code> is actually of kind <code>* -> * -> *</code>; it takes in two values (which can each be any normal Haskell type) and returns a normal Haskell type, itself. thus, we could write it instead as:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>data </span><span style=color:#ae81ff>MyMap </span><span style=color:#f92672>::</span><span> * </span><span style=color:#f92672>-></span><span> * </span><span style=color:#f92672>-></span><span> *
</span></code></pre><p>Being explicit about the <em>kind</em> of <code>MyMap</code> without using random variable names.<p>This becomes particularly useful with DataKinds and PolyKinds.<h1 id=datakinds>DataKinds</h1><p>With this extension, we can actually create new kinds of our own that are separate from the existing kind <code>*</code>. This is done by way of automatically promoting any suitable data type declarations one level.<p>Any basic types (not GADT's, and not using already promoted types for instance) are <em>promoted</em> to kinds, and their constructors promoted to types. Thus, if we write the simple data declaration:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>data </span><span style=color:#ae81ff>Number </span><span style=color:#f92672>= </span><span style=color:#ae81ff>One </span><span style=color:#f92672>| </span><span style=color:#ae81ff>Two
</span></code></pre><p>We get, in addition to our type <code>Number</code> with constructors <code>One</code> and <code>Two</code>, the <strong>kind</strong> <code>Number</code> and the <strong>types</strong> <code>One</code> and <code>Two</code>. But wait, wouldn't that potentially be ambiguous. Consider I also write:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>data </span><span style=color:#ae81ff>One
</span><span style=color:#f92672>data </span><span style=color:#ae81ff>Two
</span></code></pre><p>Now when I use the <em>type</em> <code>One</code> somewhere, so I mean the latter type or the promoted type <code>One</code> that belongs to our new <code>Number</code> kind? The answer is the former. To resolve the ambiguity we prefix a promoted type with a single quote if we want instead to use that, so <code>'One</code> would be our promoted type.<p>How can we use this ability to create new kinds? Consider this definition:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>data </span><span style=color:#ae81ff>SomeData </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>Number </span><span style=color:#f92672>-></span><span> * </span><span style=color:#f92672>where
</span><span>    </span><span style=color:#ae81ff>OneS </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>SomeData</span><span> '</span><span style=color:#ae81ff>One
</span><span>    </span><span style=color:#ae81ff>TwoS </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>SomeData</span><span> '</span><span style=color:#ae81ff>Two
</span></code></pre><p>Here, we say that our type <code>SomeData</code> is of kind <code>Number -> *</code> (using KindSignatures). This means that the first type it takes in must now be of kind <code>Number</code>, so either <code>'One</code> or <code>'Two</code> (single quotes to disambiguate). Thus, the following would be an invalid definition:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>a </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>SomeData Int
</span><span>a </span><span style=color:#f92672>=</span><span> undefined
</span></code></pre><p>Since <code>Int</code> is of kind <code>*</code>, rather than our new kind <code>Number</code>. Remember our <code>MyList</code> example from earlier, where we built up a type corresponding to the types of values we input. Let's rewrite that taking advantage of DataKinds:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- use this as the new *kind* ListK with types ConsTy(..) and NilTy:
</span><span style=color:#f92672>data </span><span style=color:#ae81ff>ListK</span><span> a </span><span style=color:#f92672>= </span><span style=color:#ae81ff>ConsTy</span><span> a (</span><span style=color:#ae81ff>ListK</span><span> a) </span><span style=color:#f92672>| </span><span style=color:#ae81ff>NilTy
</span><span>
</span><span style=color:#75715e>-- our MyList must use the above kind as its first argument:
</span><span style=color:#f92672>data </span><span style=color:#ae81ff>MyList</span><span>' </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>ListK</span><span> * </span><span style=color:#f92672>-></span><span> * </span><span style=color:#f92672>where
</span><span>    </span><span style=color:#ae81ff>LCons</span><span>' </span><span style=color:#f92672>::</span><span> itemty </span><span style=color:#f92672>-> </span><span style=color:#ae81ff>MyList</span><span>' a </span><span style=color:#f92672>-> </span><span style=color:#ae81ff>MyList</span><span>' (</span><span style=color:#ae81ff>ConsTy</span><span> itemty a)
</span><span>    </span><span style=color:#ae81ff>LNil</span><span>'  </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>MyList</span><span>' </span><span style=color:#ae81ff>NilTy
</span></code></pre><p>This all works exactly as it did before, but by doing this we've locked <code>MyList</code> down so that the compiler will throw a hissy if we try using any invalid types like <code>MyMap Int</code> or <code>MyMap Bool</code>, whereas before the compiler would have let those types slip (and gone on to complain about the values of those nonsense types instead!)<h1 id=typeoperators>TypeOperators</h1><p>Type operators let us declare operators at the type level just like we would at the value level. For example, rather than our <code>ListK</code>s <code>ConsTy</code> type , we could use an operator. Here's a tweaked version of <code>ListK</code> which does that:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>data </span><span style=color:#ae81ff>ListK2</span><span> a </span><span style=color:#f92672>=</span><span> a </span><span style=color:#f92672>:+: </span><span style=color:#ae81ff>ListK2</span><span> a </span><span style=color:#f92672>| </span><span style=color:#ae81ff>NilTy2
</span></code></pre><p>Now, we can use this new type operator in place of <code>ConsTy</code>:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>data </span><span style=color:#ae81ff>MyList2 </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>ListK2</span><span> * </span><span style=color:#f92672>-></span><span> * </span><span style=color:#f92672>where
</span><span>    </span><span style=color:#ae81ff>LCons2 </span><span style=color:#f92672>::</span><span> itemty </span><span style=color:#f92672>-> </span><span style=color:#ae81ff>MyList2</span><span> a </span><span style=color:#f92672>-> </span><span style=color:#ae81ff>MyList2</span><span> (itemty </span><span style=color:#f92672>:+:</span><span> a)
</span><span>    </span><span style=color:#ae81ff>LNil2  </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>MyList2 NilTy2
</span></code></pre><p>And our types look a little nicer as well:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#ae81ff>LCons2 </span><span style=color:#e6db74>'a'</span><span> (</span><span style=color:#ae81ff>LCons2 </span><span style=color:#e6db74>'b' </span><span style=color:#ae81ff>LNil2</span><span>) </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>MyList2</span><span> (</span><span style=color:#ae81ff>Char</span><span> '</span><span style=color:#f92672>:+:</span><span> (</span><span style=color:#ae81ff>Char</span><span> '</span><span style=color:#f92672>:+:</span><span> '</span><span style=color:#ae81ff>NilTy2</span><span>))
</span></code></pre><p>The DataKinds extension also promoted Haskell's own list type to a kind, and so its operators and syntax become available at the type level (though we need this extension to use the now type-level list operator). Here's yet another implementation of <code>MyList</code>, this time using Haskell's promoted list kind:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>data </span><span style=color:#ae81ff>MyList_ </span><span style=color:#f92672>::</span><span> [*] </span><span style=color:#f92672>-></span><span> * </span><span style=color:#f92672>where
</span><span>    </span><span style=color:#ae81ff>LCons_ </span><span style=color:#f92672>::</span><span> itemty </span><span style=color:#f92672>-> </span><span style=color:#ae81ff>MyList_</span><span> a </span><span style=color:#f92672>-> </span><span style=color:#ae81ff>MyList_</span><span> (itemty '</span><span style=color:#f92672>:</span><span> a)
</span><span>    </span><span style=color:#ae81ff>LNil_  </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>MyList_</span><span> '</span><span style=color:#ae81ff>[]
</span></code></pre><p>And our types get yet nicer:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#ae81ff>LCons_ </span><span style=color:#e6db74>'a'</span><span> (</span><span style=color:#ae81ff>LCons_ 12 LNil_</span><span>) </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>MyList2</span><span> '[</span><span style=color:#ae81ff>Char</span><span>,</span><span style=color:#ae81ff>Int</span><span>]
</span></code></pre><p>Sweet.<h1 id=polykinds>PolyKinds</h1><p>Now we can introduce new kinds, we'll quickly find that we are restricted to working with one kind at a time, unlike types where we can define polymorphic functions to work across different types.<p>PolyKinds gives us this polymorphism at the kind level. Rather than explicitly naming the kind we'll be using (eg <code>*</code> or <code>Number</code>), we can use a variable eg <code>k</code> just as we would for types in polymorphic functions.<p>Let's see why we'd want it with a type family example that reverses a promoted list:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>type </span><span style=color:#ae81ff>Reverse</span><span> (a </span><span style=color:#f92672>::</span><span> [*]) </span><span style=color:#f92672>= </span><span style=color:#ae81ff>DoReverse</span><span> a '</span><span style=color:#ae81ff>[]
</span><span>
</span><span style=color:#75715e>--this type takes a type level array eg [Int,Char,String] and reverses
</span><span style=color:#75715e>--it to eg [String,Char,Int].
</span><span style=color:#f92672>type</span><span> family </span><span style=color:#ae81ff>DoReverse</span><span> (a </span><span style=color:#f92672>::</span><span> [*]) (b </span><span style=color:#f92672>::</span><span> [*]) </span><span style=color:#f92672>::</span><span> [*] </span><span style=color:#f92672>where
</span><span>    </span><span style=color:#ae81ff>DoReverse</span><span> (a '</span><span style=color:#f92672>:</span><span> as) out </span><span style=color:#f92672>= </span><span style=color:#ae81ff>DoReverse</span><span> as (a '</span><span style=color:#f92672>:</span><span> out)
</span><span>    </span><span style=color:#ae81ff>DoReverse</span><span> '</span><span style=color:#ae81ff>[]</span><span> out </span><span style=color:#f92672>=</span><span> out
</span></code></pre><p>Thanks to this type family, these two types would now be equivalent:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#ae81ff>Reverse</span><span> [</span><span style=color:#ae81ff>Int</span><span>,</span><span style=color:#ae81ff>Char</span><span>,</span><span style=color:#ae81ff>String</span><span>] </span><span style=color:#f92672>~</span><span> [</span><span style=color:#ae81ff>String</span><span>,</span><span style=color:#ae81ff>Char</span><span>,</span><span style=color:#ae81ff>Int</span><span>]
</span></code></pre><p>As we've done before when playing with Typefamilies, we could convert this list type into something more useful, for example a nested tuple:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>type</span><span> family </span><span style=color:#ae81ff>TupFromList</span><span> (a </span><span style=color:#f92672>::</span><span> [*]) </span><span style=color:#f92672>where
</span><span>    </span><span style=color:#ae81ff>TupFromList</span><span> (a '</span><span style=color:#f92672>:</span><span> as) </span><span style=color:#f92672>=</span><span> (a, </span><span style=color:#ae81ff>TupFromList</span><span> as)
</span><span>    </span><span style=color:#ae81ff>TupFromList</span><span> '</span><span style=color:#ae81ff>[] </span><span style=color:#f92672>= </span><span style=color:#ae81ff>()
</span></code></pre><p>So these would be now be perfectly valid ways to define tuples:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>(</span><span style=color:#ae81ff>12</span><span>,(</span><span style=color:#e6db74>'a'</span><span>,(</span><span style=color:#e6db74>"hello"</span><span>,</span><span style=color:#ae81ff>()</span><span>))) </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>TupFromList</span><span> [</span><span style=color:#ae81ff>Int</span><span>,</span><span style=color:#ae81ff>Char</span><span>,</span><span style=color:#ae81ff>String</span><span>]
</span><span>
</span><span style=color:#75715e>-- note that we can next type family applications just like functions:
</span><span>(</span><span style=color:#e6db74>"hello"</span><span>,(</span><span style=color:#e6db74>'a'</span><span>,(</span><span style=color:#ae81ff>12</span><span>,</span><span style=color:#ae81ff>()</span><span>))) </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>TupFromList</span><span> (</span><span style=color:#ae81ff>Reverse</span><span> [</span><span style=color:#ae81ff>Int</span><span>,</span><span style=color:#ae81ff>Char</span><span>,</span><span style=color:#ae81ff>String</span><span>])
</span></code></pre><p>But I digress. What's PolyKinds got to do with all this? Well, this would fail to compile:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>data </span><span style=color:#ae81ff>LetterK </span><span style=color:#f92672>= </span><span style=color:#ae81ff>A </span><span style=color:#f92672>| </span><span style=color:#ae81ff>B
</span><span>
</span><span style=color:#a6e22e>a </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>Reverse</span><span> [</span><span style=font-style:italic;color:#66d9ef>A</span><span>,</span><span style=font-style:italic;color:#66d9ef>B</span><span>]
</span><span>a </span><span style=color:#f92672>=</span><span> undefined
</span></code></pre><p>Because we are trying to reverse an array of types of kind <code>[LetterK]</code>, but our <code>Reverse</code> type wants arrays of kind <code>[*]</code>. Just like functions that take <code>Int</code>s can't be passed <code>Char</code>s, types expecting to be of the kind <code>*</code> can't actually be of the kind <code>LetterK</code>. With PolyKinds, we'd tell <code>DoReverse</code> that it was of the kind <code>[k]</code>, to denote that we don't care what concrete kind <code>k</code> is, and any will do.<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>type </span><span style=color:#ae81ff>Reverse_</span><span> (a </span><span style=color:#f92672>::</span><span> [k]) </span><span style=color:#f92672>= </span><span style=color:#ae81ff>DoReverse_</span><span> a '</span><span style=color:#ae81ff>[]
</span><span>
</span><span style=color:#f92672>type</span><span> family </span><span style=color:#ae81ff>DoReverse_</span><span> (a </span><span style=color:#f92672>::</span><span> [k]) (b </span><span style=color:#f92672>::</span><span> [k]) </span><span style=color:#f92672>::</span><span> [k] </span><span style=color:#f92672>where
</span><span>    </span><span style=color:#ae81ff>DoReverse_</span><span> (a '</span><span style=color:#f92672>:</span><span> as) out </span><span style=color:#f92672>= </span><span style=color:#ae81ff>DoReverse_</span><span> as (a '</span><span style=color:#f92672>:</span><span> out)
</span><span>    </span><span style=color:#ae81ff>DoReverse_</span><span> '</span><span style=color:#ae81ff>[]</span><span> out </span><span style=color:#f92672>=</span><span> out
</span></code></pre><h1 id=constraintkinds>ConstraintKinds</h1><p>This extension gives constraints, the things that ordinarily appear only to the left of <code>=></code>, their own <em>kind</em>, <code>Constraint</code>. This allows them to be talked about like other kinds, expanding how we can make use of them somewhat. Let's have a quick look at a little of what we can do with this newfound power.<p>For a start, we can talk about them in type synonyms:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#f92672>type </span><span style=color:#ae81ff>ReadShow</span><span> a </span><span style=color:#f92672>=</span><span> (</span><span style=color:#ae81ff>Show</span><span> a, </span><span style=color:#ae81ff>Read</span><span> a)
</span><span>
</span><span style=color:#75715e>-- we can use these as we would the orignals:
</span><span style=color:#a6e22e>readAndShow </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>ReadShow </span><span>a </span><span style=color:#f92672>=> </span><span>a </span><span style=color:#f92672>-> </span><span>a
</span><span>readAndShow val </span><span style=color:#f92672>=</span><span> read </span><span style=color:#f92672>$</span><span> show val
</span></code></pre><p>This extends to associated types, which means we can (with <code>Typefamilies</code>) use them in type classes to allow instances to alter the constraints used based on the input type. I found a use for this when I wanted to create a type class recently that did the following transformations:<pre class=language-txt data-lang=txt style=background:#272822;color:#f8f8f2><code class=language-txt data-lang=txt><span>Bool       ==>  a -> Bool
</span><span>a -> Bool  ==>  a -> Bool
</span></code></pre><p>The typeclass to do this and its instances ended up looking like the following:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- at this point, I dont know what the input to the function
</span><span style=color:#75715e>-- will be, but I can make a constraint that in some way
</span><span style=color:#75715e>-- connects it with the instance type:
</span><span style=color:#f92672>class </span><span style=text-decoration:underline;font-style:italic;color:#a6e22e>WithFunc </span><span>ty </span><span style=color:#f92672>where
</span><span>    </span><span style=color:#f92672>type </span><span style=color:#ae81ff>WithFuncC</span><span> ty input </span><span style=color:#f92672>:: </span><span style=color:#ae81ff>Constraint
</span><span>    </span><span style=color:#a6e22e>withFunc </span><span style=color:#f92672>:: </span><span style=font-style:italic;color:#66d9ef>WithFuncC </span><span>ty input </span><span style=color:#f92672>=> </span><span>ty </span><span style=color:#f92672>-></span><span> (input </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>Bool</span><span>)
</span><span>
</span><span style=color:#75715e>-- given some function, I now know the input type,
</span><span style=color:#75715e>-- and can thus connect it to the input type of the
</span><span style=color:#75715e>-- returned function using the equality constraint (~):
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>WithFunc</span><span> (a </span><span style=color:#f92672>-> </span><span style=font-style:italic;color:#66d9ef>Bool</span><span>) </span><span style=color:#f92672>where
</span><span>    </span><span style=color:#f92672>type </span><span style=color:#ae81ff>WithFuncC</span><span> (a </span><span style=color:#f92672>-> </span><span style=color:#ae81ff>Bool</span><span>) input </span><span style=color:#f92672>=</span><span> a </span><span style=color:#f92672>~</span><span> input
</span><span>    withFunc </span><span style=color:#f92672>=</span><span> id
</span><span>
</span><span style=color:#75715e>-- I don't care what type the input is, since
</span><span style=color:#75715e>-- I know what i'll be outputting. () as a constraint
</span><span style=color:#75715e>-- means that any type will be fine!
</span><span style=color:#f92672>instance </span><span style=font-style:italic;color:#66d9ef>WithFunc Bool </span><span style=color:#f92672>where
</span><span>    </span><span style=color:#f92672>type </span><span style=color:#ae81ff>WithFuncC Bool</span><span> input </span><span style=color:#f92672>= </span><span style=color:#ae81ff>()
</span><span>    withFunc out </span><span style=color:#f92672>= \</span><span>_ </span><span style=color:#f92672>-></span><span> out
</span></code></pre><p>The <code>Constraint</code> type is used here to restrict the <code>input</code> type mentioned in the class definition in some way, depending on the instance types.<ul><li>The <code>(a -> Bool)</code> instance is able to say that the input to this provided function <code>a</code> will equal the input type of the returned function <code>(input -> Bool)</code> mentioned in the class (since we'll just return it unchanged).<li>For the <code>Bool</code> instance, I can say that I don't care what the input type will be by effectively providing no constraint (since I have the output to the function, the boolean, already!).</ul><p>Using this class, all of these are now perfectly valid:<pre class=language-haskell data-lang=haskell style=background:#272822;color:#f8f8f2><code class=language-haskell data-lang=haskell><span>withFunc </span><span style=color:#ae81ff>True     1   </span><span style=color:#f92672>== </span><span style=color:#ae81ff>True
</span><span>withFunc </span><span style=color:#ae81ff>False    </span><span style=color:#e6db74>'d' </span><span style=color:#f92672>== </span><span style=color:#ae81ff>False
</span><span>withFunc (</span><span style=color:#f92672>== </span><span style=color:#e6db74>'a'</span><span>) </span><span style=color:#e6db74>'b' </span><span style=color:#f92672>== </span><span style=color:#ae81ff>False
</span><span>withFunc (</span><span style=color:#f92672>== </span><span style=color:#e6db74>'a'</span><span>) </span><span style=color:#e6db74>'a' </span><span style=color:#f92672>== </span><span style=color:#ae81ff>True
</span><span>withFunc (</span><span style=color:#f92672>< </span><span style=color:#ae81ff>7</span><span>)    </span><span style=color:#ae81ff>5   </span><span style=color:#f92672>== </span><span style=color:#ae81ff>True
</span></code></pre><p>Which is awesome.<p>Generally, it seems that <code>ConstraintKinds</code> will play a useful role alongside <code>TypeFamilies</code> for allowing the instances of some typeclass to dictate more of the details of their parent type classes definitions. Given some type mentioned in a class definition, <code>TypeFamilies</code> allows it to be transformed depending on the type of each instance, whereas <code>ConstraintKinds</code> can impose different per instance restrictions on it.<h1 id=the-end-for-now>The End (for now)</h1><p>That's all for now! I'll update this post as and when I feel the desire to summarize more language extensions, but for now thanks for stopping by! Let me know if you have any comments or suggestions below!</div></div></section><footer></footer></div><script src=https://jsdw.me/page.js></script>