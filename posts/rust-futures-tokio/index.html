<!doctype html><html><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><title>
    jsdw - Rust: Converting AsyncRead and AsyncWrite to Futures, Sinks and Streams
</title><link href="https://fonts.googleapis.com/css?family=IBM+Plex+Serif|Open+Sans" rel=stylesheet><link href=https://jsdw.me/app.css rel=stylesheet><link href=https://jsdw.me/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><link href=https://jsdw.me/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=https://jsdw.me/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=https://jsdw.me/site.webmanifest rel=manifest><link color=#5bbad5 href=https://jsdw.me/safari-pinned-tab.svg rel=mask-icon><meta content=#f9409c name=msapplication-TileColor><meta content=#ffffff name=theme-color><body><div class="body post"><header><div class=title-inner><div class=jsdw><a href=https://jsdw.me>JSDW</a></div><nav><a href=https://jsdw.me/posts/>posts</a><a href=https://jsdw.me/projects/>projects</a></nav></div></header><section><div class=top><div class=top-scene><svg class="polygon two" viewbox="0 0 100 100" height=100% style=fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421 version=1.1 width=100% xml:space=preserve xmlns=http://www.w3.org/2000/svg xmlns:serif=http://www.serif.com/ xmlns:xlink=http://www.w3.org/1999/xlink><polygon points="0 100, 15 40, 60 0, 100 30"/></svg><svg class="polygon one" viewbox="0 0 100 100" height=100% style=fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421 version=1.1 width=100% xml:space=preserve xmlns=http://www.w3.org/2000/svg xmlns:serif=http://www.serif.com/ xmlns:xlink=http://www.w3.org/1999/xlink><polygon points="0 40, 30 0, 80 33, 100 100"/></svg></div><div class=top-inner><h1 class=title>Rust: Converting AsyncRead and AsyncWrite to Futures, Sinks and Streams <span class=date>2018-11-25</span></h1></div></div><div class=content-inner><div class=post><div class=table-of-contents><ul><li><a href=https://jsdw.me/posts/rust-futures-tokio/#converting-an-asyncread-to-a-future-for-one-off-reads>Converting an AsyncRead to a Future, for one-off reads</a><li><a href=https://jsdw.me/posts/rust-futures-tokio/#converting-an-asyncread-to-a-stream-for-continuous-reading>Converting an AsyncRead to a Stream, for continuous reading</a><li><a href=https://jsdw.me/posts/rust-futures-tokio/#converting-an-asyncwrite-to-a-sink-for-continuous-writing>Converting an AsyncWrite to a Sink, for continuous writing</a><li><a href=https://jsdw.me/posts/rust-futures-tokio/#converting-an-asyncwrite-to-a-future-for-one-off-writing>Converting an AsyncWrite to a Future, for one-off writing</a><li><a href=https://jsdw.me/posts/rust-futures-tokio/#conclusion>Conclusion</a></ul></div><p>Recently, I started having a go at the <a href=http://boundvariable.org>boundvariable</a> programming challenge (you can find my results <a href=https://github.com/jsdw/boundvariable>here</a>, but there be spoilers!).<p>The first step in the challenge is to write an interpreter. You're given the spec that you need to adhere to. The interpreter that you create is capable of being fed ASCII input one byte at a time, as well as handing back ASCII output one byte at a time.<p>I eventually decided that it would be nice if my interpreter could allow TCP connections to be established to it; input from these connections would be sent into the interpreter, and output from the interpreter would be sent to any current TCP connections as well as to stdout. This seemed like a good opportunity to have another go with <em>Tokio</em>; an asynchronous IO framework for Rust.<p>Prior to this experience, I had thought that Futures, Sinks and Streams were the smallest building blocks in the world of Tokio, and so I went looking through the Tokio documentation for these things. Actually, all of the fundamental objects to read and write bytes to things implement one or both of <code>AsyncRead</code> and <code>AsyncWrite</code>, but not the <code>Future</code>, <code>Sink</code> or <code>Stream</code> traits. In fact, there are lots of <code>poll_x</code> methods dotted around, so I realised I needed to figure out how to make use of them.<p>My goal was simple—reading and writing single bytes at a time—so that is the focus of my examples. You should be able to build on these foundations to add things like buffering, or to encode/decode bytes into more complex structures. I'll look at each of the possible ways to convert these things:<ul><li><code>AsyncRead</code> to <code>Future</code>, for one-off reads<li><code>AsyncRead</code> to <code>Stream</code>, for continuous reading<li><code>AsyncWrite</code> to <code>Sink</code>, for continuous writing<li><code>AsyncWrite</code> to <code>Future</code>, for one-off writes</ul><p>Complete code samples can be found <a href=https://github.com/jsdw/jsdw.me/blob/master/content/posts/rust-futures-tokio/src/main.rs>here</a>.<p>So, let's begin!<h1 id=converting-an-asyncread-to-a-future-for-one-off-reads>Converting an <code>AsyncRead</code> to a <code>Future</code>, for one-off reads</h1><p>The most verbose way to turn a thing implementing AsyncRead into a future that emits a single byte when completed is by manually implementing the <code>Future</code> trait on an appropriate type to do this for us:<pre class=language-rust data-lang=rust style=background:#272822;color:#f8f8f2><code class=language-rust data-lang=rust><span style=font-style:italic;color:#66d9ef>struct </span><span>ByteFuture&LTR>(R);
</span><span>
</span><span style=color:#75715e>// As long as R implements AsyncRead, ByteFuture&LTR> is
</span><span style=color:#75715e>// a valid Future:
</span><span style=font-style:italic;color:#66d9ef>impl </span><span>&LTR: AsyncRead> Future </span><span style=color:#f92672>for </span><span>ByteFuture&LTR> {
</span><span>
</span><span>    </span><span style=color:#75715e>// We want to get a single byte back:
</span><span>    </span><span style=font-style:italic;color:#66d9ef>type </span><span>Item </span><span style=color:#f92672>= </span><span style=font-style:italic;color:#66d9ef>u8</span><span>;
</span><span>
</span><span>    </span><span style=color:#75715e>// If things go wrong, it'll be a tokio::io::Error:
</span><span>    </span><span style=font-style:italic;color:#66d9ef>type </span><span>Error </span><span style=color:#f92672>= </span><span>io::Error;
</span><span>
</span><span>    </span><span style=color:#75715e>// Each time the future is polled, we run the poll_read method
</span><span>    </span><span style=color:#75715e>// on the AsyncReader, to try and read a single byte into a buffer.
</span><span>    </span><span style=color:#75715e>// If we succeed, we give back the byte, otherwise we say we're not
</span><span>    </span><span style=color:#75715e>// ready yet:
</span><span>    </span><span style=font-style:italic;color:#66d9ef>fn </span><span style=color:#a6e22e>poll</span><span>(</span><span style=color:#f92672>&mut </span><span style=font-style:italic;color:#fd971f>self</span><span>) -> </span><span style=font-style:italic;color:#66d9ef>Result</span><span>&LTAsync<</span><span style=font-style:italic;color:#66d9ef>u8</span><span>>, io::Error> {
</span><span>        </span><span style=font-style:italic;color:#66d9ef>let </span><span style=color:#f92672>mut</span><span> buf </span><span style=color:#f92672>= </span><span>[</span><span style=color:#ae81ff>0</span><span>;</span><span style=color:#ae81ff>1</span><span>];
</span><span>        </span><span style=color:#f92672>match </span><span>self.</span><span style=color:#ae81ff>0.</span><span style=color:#66d9ef>poll_read</span><span>(</span><span style=color:#f92672>&mut</span><span> buf) {
</span><span>            </span><span style=font-style:italic;color:#66d9ef>Ok</span><span>(Async::Ready(_num_bytes_read)) </span><span style=color:#f92672>=> </span><span style=font-style:italic;color:#66d9ef>Ok</span><span>(Async::Ready(buf[</span><span style=color:#ae81ff>0</span><span>])),
</span><span>            </span><span style=font-style:italic;color:#66d9ef>Ok</span><span>(Async::NotReady) </span><span style=color:#f92672>=> </span><span style=font-style:italic;color:#66d9ef>Ok</span><span>(Async::NotReady),
</span><span>            </span><span style=font-style:italic;color:#66d9ef>Err</span><span>(e) </span><span style=color:#f92672>=> </span><span style=font-style:italic;color:#66d9ef>Err</span><span>(e)
</span><span>        }
</span><span>    }
</span><span>
</span><span>}
</span><span>
</span><span style=color:#75715e>// Now we can use the above to create a future that
</span><span style=color:#75715e>// will resolve to a single byte read from stdin:
</span><span style=font-style:italic;color:#66d9ef>let</span><span> byte_future </span><span style=color:#f92672>=</span><span> ByteFuture(io::stdin());
</span></code></pre><p>The nice thing about implementing the Future yourself is that you have complete control over things like buffering and error handling. You can also replace <code>poll_read</code> with any similar <code>poll_x</code> method you find to create a Future that resolves when it returns something.<p>It's important to note that the <code>poll</code> method on a future will only be called when something notifies the current Task (just the term given to a future that's been handed back to Tokio to be executed) that it can make progress. This means that if your Future implementation returns <code>NotReady</code>, it must be because either:<ul><li>The underlying <code>poll_x</code> method did (and so <em>it</em> will have arranged to wake the Task up when needed)<li>You arrange to wake the Task up yourself.</ul><p>If neither of these are true, the task will never resume and your Future will therefore never be polled again, and never finish.<p>One step less verbose than implementing your own Future is using the <code>futures::future::poll_fn</code> helper function, which transforms any poll method into an ad-hoc future on the fly, without the need for custom types and such. This achieves the same as above, reading from <code>stdin</code>:<pre class=language-rust data-lang=rust style=background:#272822;color:#f8f8f2><code class=language-rust data-lang=rust><span style=font-style:italic;color:#66d9ef>let</span><span> byte_future </span><span style=color:#f92672>= </span><span>future::poll_fn(</span><span style=color:#f92672>move || </span><span>{
</span><span>    </span><span style=font-style:italic;color:#66d9ef>let </span><span style=color:#f92672>mut</span><span> buf </span><span style=color:#f92672>= </span><span>[</span><span style=color:#ae81ff>0</span><span>;</span><span style=color:#ae81ff>1</span><span>];
</span><span>    </span><span style=color:#f92672>match </span><span>io::stdin().</span><span style=color:#66d9ef>poll_read</span><span>(</span><span style=color:#f92672>&mut</span><span> buf) {
</span><span>        </span><span style=font-style:italic;color:#66d9ef>Ok</span><span>(Async::Ready(_num_bytes_read)) </span><span style=color:#f92672>=> </span><span style=font-style:italic;color:#66d9ef>Ok</span><span>(Async::Ready(buf[</span><span style=color:#ae81ff>0</span><span>])),
</span><span>        </span><span style=font-style:italic;color:#66d9ef>Ok</span><span>(Async::NotReady) </span><span style=color:#f92672>=> </span><span style=font-style:italic;color:#66d9ef>Ok</span><span>(Async::NotReady),
</span><span>        </span><span style=font-style:italic;color:#66d9ef>Err</span><span>(e) </span><span style=color:#f92672>=> </span><span style=font-style:italic;color:#66d9ef>Err</span><span>(e)
</span><span>    }
</span><span>});
</span></code></pre><p>Note how the method is practically identical to the <code>poll</code> implementation of the future. By making the closure passed to the <code>poll_fn</code> method <code>move</code>, you can pass in and make available whatever state you need for buffering and things.<p>Using the <code>try_ready!</code> macro, which is a bit like <code>try!</code>/<code>?</code> but also returns if the thing passed to it returns <code>Ok(Async::NotReady)</code>, we can shorten the above slightly (though you may need to provide explicit type information because the error can be converted):<pre class=language-rust data-lang=rust style=background:#272822;color:#f8f8f2><code class=language-rust data-lang=rust><span style=font-style:italic;color:#66d9ef>let</span><span> byte_future </span><span style=color:#f92672>= </span><span>future::poll_fn(</span><span style=color:#f92672>move || </span><span>{
</span><span>    </span><span style=font-style:italic;color:#66d9ef>let </span><span style=color:#f92672>mut</span><span> buf </span><span style=color:#f92672>= </span><span>[</span><span style=color:#ae81ff>0</span><span>;</span><span style=color:#ae81ff>1</span><span>];
</span><span>    </span><span style=font-style:italic;color:#66d9ef>let</span><span> _num_bytes_read </span><span style=color:#f92672>= </span><span>try_ready!(io::stdin().</span><span style=color:#66d9ef>poll_read</span><span>(</span><span style=color:#f92672>&mut</span><span> buf));
</span><span>    </span><span style=font-style:italic;color:#66d9ef>Ok</span><span>(Async::Ready(buf[</span><span style=color:#ae81ff>0</span><span>]))
</span><span>});
</span></code></pre><p>We're down to just 4 lines of code now, but it turns out we can do even better by making use of the handy <code>tokio::io::read</code> helper:<pre class=language-rust data-lang=rust style=background:#272822;color:#f8f8f2><code class=language-rust data-lang=rust><span style=font-style:italic;color:#66d9ef>let</span><span> byte_future </span><span style=color:#f92672>= </span><span>io::read(io::stdin(), [</span><span style=color:#ae81ff>0</span><span>;</span><span style=color:#ae81ff>1</span><span>])
</span><span>        .</span><span style=color:#66d9ef>map</span><span>(|(</span><span style=font-style:italic;color:#fd971f>_stdin</span><span>,</span><span style=font-style:italic;color:#fd971f>buf</span><span>,</span><span style=font-style:italic;color:#fd971f>_num_bytes_read</span><span>)| buf[</span><span style=color:#ae81ff>0</span><span>]);
</span></code></pre><p>This helper consumes an <code>AsyncRead</code>er and a buffer, but fortunately gives back the buffer (and how many bytes were read into it) when it resolves, so it's easy to map this result to the single byte we're interested in.<h1 id=converting-an-asyncread-to-a-stream-for-continuous-reading>Converting an <code>AsyncRead</code> to a <code>Stream</code>, for continuous reading</h1><p>A <em>Stream</em> is very similar to a Future, except that it can keep yielding items indefinitely. Once again, we can create a thing that takes an <code>AsyncRead</code> and implements the <code>Stream</code> trait for us:<pre class=language-rust data-lang=rust style=background:#272822;color:#f8f8f2><code class=language-rust data-lang=rust><span style=font-style:italic;color:#66d9ef>struct </span><span>ByteStream&LTR>(R);
</span><span>
</span><span style=font-style:italic;color:#66d9ef>impl </span><span>&LTR: AsyncRead> Stream </span><span style=color:#f92672>for </span><span>ByteStream&LTR> {
</span><span>
</span><span>    </span><span style=color:#75715e>// The same as our future above:
</span><span>    </span><span style=font-style:italic;color:#66d9ef>type </span><span>Item </span><span style=color:#f92672>= </span><span style=font-style:italic;color:#66d9ef>u8</span><span>;
</span><span>    </span><span style=font-style:italic;color:#66d9ef>type </span><span>Error </span><span style=color:#f92672>= </span><span>io::Error;
</span><span>
</span><span>    </span><span style=color:#75715e>// poll is very similar to our Future implementation, except that
</span><span>    </span><span style=color:#75715e>// it returns an `Option&LTu8>` instead of a `u8`. This is so that the
</span><span>    </span><span style=color:#75715e>// Stream can signal that it's finished by returning `None`:
</span><span>    </span><span style=font-style:italic;color:#66d9ef>fn </span><span style=color:#a6e22e>poll</span><span>(</span><span style=color:#f92672>&mut </span><span style=font-style:italic;color:#fd971f>self</span><span>) -> </span><span style=font-style:italic;color:#66d9ef>Result</span><span>&LTAsync<</span><span style=font-style:italic;color:#66d9ef>Option</span><span><</span><span style=font-style:italic;color:#66d9ef>u8</span><span>>>, io::Error> {
</span><span>        </span><span style=font-style:italic;color:#66d9ef>let </span><span style=color:#f92672>mut</span><span> buf </span><span style=color:#f92672>= </span><span>[</span><span style=color:#ae81ff>0</span><span>;</span><span style=color:#ae81ff>1</span><span>];
</span><span>        </span><span style=color:#f92672>match </span><span>self.</span><span style=color:#ae81ff>0.</span><span style=color:#66d9ef>poll_read</span><span>(</span><span style=color:#f92672>&mut</span><span> buf) {
</span><span>            </span><span style=font-style:italic;color:#66d9ef>Ok</span><span>(Async::Ready(n)) </span><span style=color:#f92672>=> </span><span>{
</span><span>                </span><span style=color:#75715e>// By convention, if an AsyncRead says that it read 0 bytes,
</span><span>                </span><span style=color:#75715e>// we should assume that it has got to the end, so we signal that
</span><span>                </span><span style=color:#75715e>// the Stream is done in this case by returning None:
</span><span>                </span><span style=color:#f92672>if</span><span> n </span><span style=color:#f92672>== </span><span style=color:#ae81ff>0 </span><span>{
</span><span>                    </span><span style=font-style:italic;color:#66d9ef>Ok</span><span>(Async::Ready(</span><span style=font-style:italic;color:#66d9ef>None</span><span>))
</span><span>                } </span><span style=color:#f92672>else </span><span>{
</span><span>                    </span><span style=font-style:italic;color:#66d9ef>Ok</span><span>(Async::Ready(</span><span style=font-style:italic;color:#66d9ef>Some</span><span>(buf[</span><span style=color:#ae81ff>0</span><span>])))
</span><span>                }
</span><span>            },
</span><span>            </span><span style=font-style:italic;color:#66d9ef>Ok</span><span>(Async::NotReady) </span><span style=color:#f92672>=> </span><span style=font-style:italic;color:#66d9ef>Ok</span><span>(Async::NotReady),
</span><span>            </span><span style=font-style:italic;color:#66d9ef>Err</span><span>(e) </span><span style=color:#f92672>=> </span><span style=font-style:italic;color:#66d9ef>Err</span><span>(e)
</span><span>        }
</span><span>    }
</span><span>}
</span><span style=font-style:italic;color:#66d9ef>let</span><span> byte_stream1 </span><span style=color:#f92672>=</span><span> ByteStream(io::stdin());
</span></code></pre><p>This is very similar to the Future implementation, except that we make a note of when the <code>AsyncRead</code> has made it to the end and signal that the Stream is done too.<p>Once again, we have a helper function that we can use to implement a Stream in a more ad-hoc way:<pre class=language-rust data-lang=rust style=background:#272822;color:#f8f8f2><code class=language-rust data-lang=rust><span style=font-style:italic;color:#66d9ef>let</span><span> byte_stream </span><span style=color:#f92672>= </span><span>stream::poll_fn(</span><span style=color:#f92672>move || </span><span>{
</span><span>    </span><span style=font-style:italic;color:#66d9ef>let </span><span style=color:#f92672>mut</span><span> buf </span><span style=color:#f92672>= </span><span>[</span><span style=color:#ae81ff>0</span><span>;</span><span style=color:#ae81ff>1</span><span>];
</span><span>    </span><span style=color:#f92672>match </span><span>io::stdin().</span><span style=color:#66d9ef>poll_read</span><span>(</span><span style=color:#f92672>&mut</span><span> buf) {
</span><span>        </span><span style=font-style:italic;color:#66d9ef>Ok</span><span>(Async::Ready(n)) </span><span style=color:#f92672>=> </span><span>{
</span><span>            </span><span style=color:#f92672>if</span><span> n </span><span style=color:#f92672>== </span><span style=color:#ae81ff>0 </span><span>{
</span><span>                </span><span style=font-style:italic;color:#66d9ef>Ok</span><span>(Async::Ready(</span><span style=font-style:italic;color:#66d9ef>None</span><span>))
</span><span>            } </span><span style=color:#f92672>else </span><span>{
</span><span>                </span><span style=font-style:italic;color:#66d9ef>Ok</span><span>(Async::Ready(</span><span style=font-style:italic;color:#66d9ef>Some</span><span>(buf[</span><span style=color:#ae81ff>0</span><span>])))
</span><span>            }
</span><span>        },
</span><span>        </span><span style=font-style:italic;color:#66d9ef>Ok</span><span>(Async::NotReady) </span><span style=color:#f92672>=> </span><span style=font-style:italic;color:#66d9ef>Ok</span><span>(Async::NotReady),
</span><span>        </span><span style=font-style:italic;color:#66d9ef>Err</span><span>(e) </span><span style=color:#f92672>=> </span><span style=font-style:italic;color:#66d9ef>Err</span><span>(e)
</span><span>    }
</span><span>});
</span></code></pre><p>This is almost a copy of the <code>poll</code> method above, just like our usage of <code>futures::poll_fn</code> above.<p>If you wonder whether there is a way to put the nice <code>io::read</code> helper function to use again, but this time for a Stream, there is! We can combine it with the <code>stream::unfold</code> function to convert a Future into a Stream of Futures:<pre class=language-rust data-lang=rust style=background:#272822;color:#f8f8f2><code class=language-rust data-lang=rust><span style=font-style:italic;color:#66d9ef>let</span><span> byte_stream </span><span style=color:#f92672>= </span><span>stream::unfold((), |_| {
</span><span>    </span><span style=font-style:italic;color:#66d9ef>let</span><span> next </span><span style=color:#f92672>= </span><span>io::read(io::stdin(), [</span><span style=color:#ae81ff>0</span><span>;</span><span style=color:#ae81ff>1</span><span>]).</span><span style=color:#66d9ef>map</span><span>(|(</span><span style=font-style:italic;color:#fd971f>_stdin</span><span>,</span><span style=font-style:italic;color:#fd971f>buf</span><span>,</span><span style=font-style:italic;color:#fd971f>n</span><span>)| (buf[</span><span style=color:#ae81ff>0</span><span>], ()));
</span><span>    </span><span style=font-style:italic;color:#66d9ef>Some</span><span>(next)
</span><span>});
</span></code></pre><p>This has a notable downside however; there is no way to decide whether to return or not after running the <code>io::read</code>, and so I can't signal that the reader has reached the end. This is fine however for something like <code>stdin</code>, which you might expect never to be closed, but no good for streaming file data and such.<p>A nicer, and even more concise approach, is to use functionality from the <code>tokio::codec</code> module, which allows you to describe how to encode and decode bytes from <code>AsyncRead</code>/<code>AsyncWrite</code> things, and wraps them into Streams and Sinks for you. This is how we could make our one-byte-at-a-time Stream:<pre class=language-rust data-lang=rust style=background:#272822;color:#f8f8f2><code class=language-rust data-lang=rust><span style=font-style:italic;color:#66d9ef>let</span><span> byte_stream </span><span style=color:#f92672>= </span><span>codec::FramedRead::new(io::stdin(), codec::BytesCodec::new())
</span><span>    </span><span style=color:#75715e>// convert our bytes buffer into a stream that emits one byte at a time:
</span><span>    .</span><span style=color:#66d9ef>map</span><span>(|</span><span style=font-style:italic;color:#fd971f>bytes</span><span>| stream::iter_ok::<</span><span style=color:#f92672>_</span><span>, io::Error>(bytes))
</span><span>    </span><span style=color:#75715e>// flatten our stream of streams down into one stream:
</span><span>    .</span><span style=color:#66d9ef>flatten</span><span>();
</span></code></pre><p>If we were happy being fed a Stream of byte buffers, we'd be finished in one line, but because we want a stream of bytes we map each buffer into a stream of bytes and then flatten the resulting stream-of-streams into one stream. I would also expect this approach to be faster than the previous ones as well, since it reads more than one byte at a time from the underlying reader.<p>To do more complex encoding and decoding, implement <code>tokio::codec::Decode</code> and/or <code>tokio::codec::Encode</code> on some type, and then pass that in instead of <code>BytesCodec</code> to make use of it.<h1 id=converting-an-asyncwrite-to-a-sink-for-continuous-writing>Converting an <code>AsyncWrite</code> to a <code>Sink</code>, for continuous writing</h1><p>Implementing <code>Sink</code> is a little harder than implementing <code>Stream</code>, because writing to a Sink is a two-stage process; first you begin sending data to the Sink (which might queue it up in a buffer), and then you flush the data out to the Sink to ensure it has all been written out. Here's a simple one-byte-at-a-time implementation:<pre class=language-rust data-lang=rust style=background:#272822;color:#f8f8f2><code class=language-rust data-lang=rust><span style=font-style:italic;color:#66d9ef>struct </span><span>ByteSink&LTW>(W);
</span><span>
</span><span style=font-style:italic;color:#66d9ef>impl </span><span>&LTW: AsyncWrite> Sink </span><span style=color:#f92672>for </span><span>ByteSink&LTW> {
</span><span>
</span><span>    </span><span style=color:#75715e>// We want to send single bytes to the sink:
</span><span>    </span><span style=font-style:italic;color:#66d9ef>type </span><span>SinkItem </span><span style=color:#f92672>= </span><span style=font-style:italic;color:#66d9ef>u8</span><span>;
</span><span>
</span><span>    </span><span style=color:#75715e>// An error will be of this type:
</span><span>    </span><span style=font-style:italic;color:#66d9ef>type </span><span>SinkError </span><span style=color:#f92672>= </span><span>io::Error;
</span><span>
</span><span>    </span><span style=color:#75715e>// This is called to provide an item to the Sink. We might want to
</span><span>    </span><span style=color:#75715e>// push it to a buffer here, but to keep things simple we just forward
</span><span>    </span><span style=color:#75715e>// it on to the underlying `AsyncWrite` by calling `poll_write`. The item
</span><span>    </span><span style=color:#75715e>// is returned if nothing can be done with it yet, which is why the return
</span><span>    </span><span style=color:#75715e>// type is a little different here:
</span><span>    </span><span style=font-style:italic;color:#66d9ef>fn </span><span style=color:#a6e22e>start_send</span><span>(</span><span style=color:#f92672>&mut </span><span style=font-style:italic;color:#fd971f>self</span><span>, </span><span style=font-style:italic;color:#fd971f>item</span><span>: </span><span style=font-style:italic;color:#66d9ef>u8</span><span>) -> </span><span style=font-style:italic;color:#66d9ef>Result</span><span>&LTAsyncSink<</span><span style=font-style:italic;color:#66d9ef>u8</span><span>>, io::Error> {
</span><span>        </span><span style=color:#f92672>match </span><span>self.</span><span style=color:#ae81ff>0.</span><span style=color:#66d9ef>poll_write</span><span>(</span><span style=color:#f92672>&</span><span>[item])</span><span style=color:#f92672>? </span><span>{
</span><span>            Async::NotReady </span><span style=color:#f92672>=> </span><span style=font-style:italic;color:#66d9ef>Ok</span><span>(AsyncSink::NotReady(item)),
</span><span>            Async::Ready(</span><span style=color:#f92672>_</span><span>) </span><span style=color:#f92672>=> </span><span style=font-style:italic;color:#66d9ef>Ok</span><span>(AsyncSink::Ready)
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#75715e>// This is called after potentially multiple calls to `start_send`. Its goal is
</span><span>    </span><span style=color:#75715e>// to flush the data out to ensure it's been fully written.
</span><span>    </span><span style=font-style:italic;color:#66d9ef>fn </span><span style=color:#a6e22e>poll_complete</span><span>(</span><span style=color:#f92672>&mut </span><span style=font-style:italic;color:#fd971f>self</span><span>) -> </span><span style=font-style:italic;color:#66d9ef>Result</span><span>&LTAsync<()>,io::Error> {
</span><span>        </span><span style=color:#f92672>match </span><span>self.</span><span style=color:#ae81ff>0.</span><span style=color:#66d9ef>poll_flush</span><span>()</span><span style=color:#f92672>? </span><span>{
</span><span>            Async::Ready(</span><span style=color:#f92672>_</span><span>) </span><span style=color:#f92672>=> </span><span style=font-style:italic;color:#66d9ef>Ok</span><span>(Async::Ready(())),
</span><span>            Async::NotReady </span><span style=color:#f92672>=> </span><span style=font-style:italic;color:#66d9ef>Ok</span><span>(Async::NotReady)
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#75715e>// Convert our stdout `AsyncWrite` into a single-byte Sink:
</span><span style=font-style:italic;color:#66d9ef>let</span><span> byte_sink </span><span style=color:#f92672>=</span><span> ByteSink(io::stdout());
</span></code></pre><p>There's room for improvement here, for instance I don't attempt to buffer anything at all, and rely on the underlying <code>AsyncWrite</code> to be performant for me. As with implementing Futures and Streams, you must only return <code>NotReady</code> if the underlying writer did, to be sure that the underlying writer will wake the task up and call these methods again when appropriate.<p>As with our <code>Stream</code> implementation, <code>tokio::codec</code> comes to the rescue again to give us a significantly more concise way to implement the above:<pre class=language-rust data-lang=rust style=background:#272822;color:#f8f8f2><code class=language-rust data-lang=rust><span style=font-style:italic;color:#66d9ef>let</span><span> byte_sink </span><span style=color:#f92672>= </span><span>codec::FramedWrite::new(io::stdout(), codec::BytesCodec::new())
</span><span>    .</span><span style=color:#66d9ef>with</span><span>(|</span><span style=font-style:italic;color:#fd971f>byte</span><span>| {
</span><span>        </span><span style=color:#75715e>// convert an incoming byte into the Bytes type expected by the codec:
</span><span>        </span><span style=font-style:italic;color:#66d9ef>Ok</span><span>::<</span><span style=color:#f92672>_</span><span>, io::Error>([byte][</span><span style=color:#f92672>..</span><span>].</span><span style=color:#66d9ef>into</span><span>())
</span><span>    });
</span></code></pre><p>As with the above implementation it does not attempt to do any buffering. the <code>with</code> method is a bit like <code>map</code> in reverse; instead of mapping the value coming out of the Stream/Future, we map the value before it comes into the Sink, to turn it into the required type.<p>There seem to be fewer ways to convert an <code>AsyncWrite</code> into a <code>Sink</code>, I suppose because it is a little more complex.<h1 id=converting-an-asyncwrite-to-a-future-for-one-off-writing>Converting an <code>AsyncWrite</code> to a <code>Future</code>, for one-off writing</h1><p>For completeness sake, I include the final of the possible conversions; one-off writes to an <code>AsyncWrite</code> which leads to a single Future. Once you have a Sink, this can be done by using the <code>send</code> or <code>send_all</code> methods available on the <code>Sink</code> trait. An alternative if you only have an <code>AsyncWrite</code> is to use the <code>tokio::io::write_all</code> helper function:<pre class=language-rust data-lang=rust style=background:#272822;color:#f8f8f2><code class=language-rust data-lang=rust><span style=font-style:italic;color:#66d9ef>let</span><span> write_once </span><span style=color:#f92672>= </span><span>io::write_all(io::stdout(), </span><span style=color:#f92672>&</span><span>[</span><span style=font-style:italic;color:#66d9ef>b</span><span style=color:#e6db74>'x'</span><span>]);
</span></code></pre><p><code>write_once</code> is a Future that resolves when the bytes provided are written and flushed to the output.<h1 id=conclusion>Conclusion</h1><p>Hopefully I've managed to shine some light on how to work with <code>AsyncRead</code>/<code>AsyncWrite</code> things. I've demonstrated various ways to "upgrade" things that have <code>poll_x</code> methods into an appropriate type (be it a Future, Sink or Stream), which will hopefully make them easier to work with!<p>All of the code used above is <a href=https://github.com/jsdw/jsdw.me/blob/master/content/posts/rust-futures-tokio/src/main.rs>available here</a>.</div></div></section><footer></footer></div><script src=https://jsdw.me/page.js></script>